# C++基础

## 1 C++初识

### 1.1  第一个C++程序

编写一个C++程序总共分为4个步骤

* 创建项目
* 创建文件
* 编写代码
* 运行程序

#### 1.1.1 创建项目

​	Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开

![1541383178746](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541383178746.png)



![1541384366413](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541384366413.png)

#### 1.1.2 创建文件

右键源文件，选择添加->新建项

![1541383817248](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541383817248.png)

给C++文件起个名称，然后点击添加即可。

![1541384140042](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541384140042.png)



#### 1.1.3 编写代码

```c++
#include<iostream>
using namespace std;

int main() {

	cout << "Hello world" << endl;

	system("pause");

	return 0;
}
```

#### 1.1.4 运行程序

![1541384818688](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541384818688.png)













### 1.2 注释

**作用**：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码

**两种格式**

1. **单行注释**：`// 描述信息` 
   - 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==
2. **多行注释**： `/* 描述信息 */`
   - 通常放在一段代码的上方，==对该段代码做整体说明==

> 提示：编译器在编译代码时，会忽略注释的内容











### 1.3 变量

**作用**：给一段指定的内存空间起名，方便操作这段内存

**语法**：`数据类型 变量名 = 初始值;`

**示例：**

```C++
#include<iostream>
using namespace std;

int main() {

	//变量的定义
	//语法：数据类型  变量名 = 初始值

	int a = 10;

	cout << "a = " << a << endl;
	
	system("pause");

	return 0;
}
```



> 注意：C++在创建变量时，必须给变量一个初始值，否则会报错















### 1.4  常量

**作用**：用于记录程序中不可更改的数据

C++定义常量两种方式

1. **\#define** 宏常量： `#define 常量名 常量值`
   * ==通常在文件上方定义==，表示一个常量


2. **const**修饰的变量 `const 数据类型 常量名 = 常量值`
   * ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改



**示例：**

```C++
//1、宏常量
#define day 7

int main() {

	cout << "一周里总共有 " << day << " 天" << endl;
	//day = 8;  //报错，宏常量不可以修改

	//2、const修饰变量
	const int month = 12;
	cout << "一年里总共有 " << month << " 个月份" << endl;
	//month = 24; //报错，常量是不可以修改的
	
	
	system("pause");

	return 0;
}
```










### 1.5 关键字

**作用：**关键字是C++中预先保留的单词（标识符）

* **在定义变量或者常量时候，不要用关键字**



C++关键字如下：

| asm        | do           | if               | return      | typedef  |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

`提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。`











### 1.6 标识符命名规则

**作用**：C++规定给标识符（变量、常量）命名时，有一套自己的规则

* 标识符不能是关键字
* 标识符只能由字母、数字、下划线组成
* 第一个字符必须为字母或下划线
* 标识符中字母区分大小写

> 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读















## 2 数据类型

C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存

### 2.1 整型

**作用**：整型变量表示的是==整数类型==的数据

C++中能够表示整型的类型有以下几种方式，**区别在于所占内存空间不同**：

| **数据类型**        | **占用空间**                                    | 取值范围         |
| ------------------- | ----------------------------------------------- | ---------------- |
| short(短整型)       | 2字节                                           | (-2^15 ~ 2^15-1) |
| int(整型)           | 4字节                                           | (-2^31 ~ 2^31-1) |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |
| long long(长长整形) | 8字节                                           | (-2^63 ~ 2^63-1) |













### 2.2 sizeof关键字

**作用：**利用sizeof关键字可以==统计数据类型所占内存大小==

**语法：** `sizeof( 数据类型 / 变量)`

**示例：**

```C++
int main() {

	cout << "short 类型所占内存空间为： " << sizeof(short) << endl;

	cout << "int 类型所占内存空间为： " << sizeof(int) << endl;

	cout << "long 类型所占内存空间为： " << sizeof(long) << endl;

	cout << "long long 类型所占内存空间为： " << sizeof(long long) << endl;

	system("pause");

	return 0;
}
```





> **整型结论**：==short < int <= long <= long long==















### 2.3 实型（浮点型）

**作用**：用于==表示小数==

浮点型变量分为两种：

1. 单精度float 
2. 双精度double

两者的**区别**在于表示的有效数字范围不同。

| **数据类型** | **占用空间** | **有效数字范围** |
| ------------ | ------------ | ---------------- |
| float        | 4字节        | 7位有效数字      |
| double       | 8字节        | 15～16位有效数字 |

**示例：**

```C++
int main() {

	float f1 = 3.14f;
	double d1 = 3.14;

	cout << f1 << endl;
	cout << d1<< endl;

	cout << "float  sizeof = " << sizeof(f1) << endl;
	cout << "double sizeof = " << sizeof(d1) << endl;

	//科学计数法
	float f2 = 3e2; // 3 * 10 ^ 2 
	cout << "f2 = " << f2 << endl;

	float f3 = 3e-2;  // 3 * 0.1 ^ 2
	cout << "f3 = " << f3 << endl;

	system("pause");

	return 0;
}
```











### 2.4 字符型

**作用：**字符型变量用于显示单个字符

**语法：**`char ch = 'a';`



> 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号

> 注意2：单引号内只能有一个字符，不可以是字符串



- C和C++中字符型变量只占用==1个字节==。
- 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元



示例：

```C++
int main() {
	
	char ch = 'a';
	cout << ch << endl;
	cout << sizeof(char) << endl;

	//ch = "abcde"; //错误，不可以用双引号
	//ch = 'abcde'; //错误，单引号内只能引用一个字符

	cout << (int)ch << endl;  //查看字符a对应的ASCII码
	ch = 97; //可以直接用ASCII给字符型变量赋值
	cout << ch << endl;

	system("pause");

	return 0;
}
```

ASCII码表格：

| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |
| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |
| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |
| 1           | SOH          | 33          | !        | 65          | A        | 97          | a        |
| 2           | STX          | 34          | "        | 66          | B        | 98          | b        |
| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |
| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |
| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |
| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |
| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |
| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |
| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |
| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |
| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |
| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |
| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |
| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |
| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |
| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |
| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |
| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |
| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |
| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |
| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |
| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |
| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |
| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |
| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |
| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |
| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |
| 28          | FS           | 60          | <        | 92          | /        | 124         | \|       |
| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |
| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |
| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |

ASCII 码大致由以下**两部分组**成：

* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。













### 2.5 转义字符

**作用：**用于表示一些==不能显示出来的ASCII字符==

现阶段我们常用的转义字符有：` \n  \\  \t`

| **转义字符** | **含义**                                | **ASCII**码值（十进制） |
| ------------ | --------------------------------------- | ----------------------- |
| \a           | 警报                                    | 007                     |
| \b           | 退格(BS) ，将当前位置移到前一列         | 008                     |
| \f           | 换页(FF)，将当前位置移到下页开头        | 012                     |
| **\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |
| \r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |
| **\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |
| \v           | 垂直制表(VT)                            | 011                     |
| **\\\\**     | **代表一个反斜线字符"\"**               | **092**                 |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |

示例：

```C++
int main() {
	
	
	cout << "\\" << endl;
	cout << "\tHello" << endl;
	cout << "\n" << endl;

	system("pause");

	return 0;
}
```













### 2.6 字符串型

**作用**：用于表示一串字符

**两种风格**

1. **C风格字符串**： `char 变量名[] = "字符串值"`

   示例：

   ```C++
   int main() {
   
   	char str1[] = "hello world";
   	cout << str1 << endl;
       
   	system("pause");
   
   	return 0;
   }
   ```

> 注意：C风格的字符串要用双引号括起来

1. **C++风格字符串**：  `string  变量名 = "字符串值"`

   示例：

   ```C++
   int main() {
   
   	string str = "hello world";
   	cout << str << endl;
   	
   	system("pause");
   
   	return 0;
   }
   ```

   

> 注意：C++风格字符串，需要加入头文件==#include\<string>==













### 2.7 布尔类型 bool

**作用：**布尔数据类型代表真或假的值 

bool类型只有两个值：

* true  --- 真（本质是1）
* false --- 假（本质是0）

**bool类型占==1个字节==大小**

示例：

```C++
int main() {

	bool flag = true;
	cout << flag << endl; // 1

	flag = false;
	cout << flag << endl; // 0

	cout << "size of bool = " << sizeof(bool) << endl; //1
	
	system("pause");

	return 0;
}
```















### 2.8 数据的输入

**作用：用于从键盘获取数据**

**关键字：**cin

**语法：** `cin >> 变量 `

示例：

```C++
int main(){

	//整型输入
	int a = 0;
	cout << "请输入整型变量：" << endl;
	cin >> a;
	cout << a << endl;

	//浮点型输入
	double d = 0;
	cout << "请输入浮点型变量：" << endl;
	cin >> d;
	cout << d << endl;

	//字符型输入
	char ch = 0;
	cout << "请输入字符型变量：" << endl;
	cin >> ch;
	cout << ch << endl;

	//字符串型输入
	string str;
	cout << "请输入字符串型变量：" << endl;
	cin >> str;
	cout << str << endl;

	//布尔类型输入
	bool flag = true;
	cout << "请输入布尔型变量：" << endl;
	cin >> flag;
	cout << flag << endl;
	system("pause");
	return EXIT_SUCCESS;
}
```













## 3 运算符

**作用：**用于执行代码的运算

本章我们主要讲解以下几类运算符：

| **运算符类型** | **作用**                               |
| -------------- | -------------------------------------- |
| 算术运算符     | 用于处理四则运算                       |
| 赋值运算符     | 用于将表达式的值赋给变量               |
| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |

### 3.1 算术运算符

**作用**：用于处理四则运算 

算术运算符包括以下符号：

| **运算符** | **术语**   | **示例**    | **结果**  |
| ---------- | ---------- | ----------- | --------- |
| +          | 正号       | +3          | 3         |
| -          | 负号       | -3          | -3        |
| +          | 加         | 10 + 5      | 15        |
| -          | 减         | 10 - 5      | 5         |
| *          | 乘         | 10 * 5      | 50        |
| /          | 除         | 10 / 5      | 2         |
| %          | 取模(取余) | 10 % 3      | 1         |
| ++         | 前置递增   | a=2; b=++a; | a=3; b=3; |
| ++         | 后置递增   | a=2; b=a++; | a=3; b=2; |
| --         | 前置递减   | a=2; b=--a; | a=1; b=1; |
| --         | 后置递减   | a=2; b=a--; | a=1; b=2; |

**示例1：**

```C++
//加减乘除
int main() {

	int a1 = 10;
	int b1 = 3;

	cout << a1 + b1 << endl;
	cout << a1 - b1 << endl;
	cout << a1 * b1 << endl;
	cout << a1 / b1 << endl;  //两个整数相除结果依然是整数

	int a2 = 10;
	int b2 = 20;
	cout << a2 / b2 << endl; 

	int a3 = 10;
	int b3 = 0;
	//cout << a3 / b3 << endl; //报错，除数不可以为0


	//两个小数可以相除
	double d1 = 0.5;
	double d2 = 0.25;
	cout << d1 / d2 << endl;

	system("pause");

	return 0;
}
```

> 总结：在除法运算中，除数不能为0





**示例2：**

```C++
//取模
int main() {

	int a1 = 10;
	int b1 = 3;

	cout << 10 % 3 << endl;

	int a2 = 10;
	int b2 = 20;

	cout << a2 % b2 << endl;

	int a3 = 10;
	int b3 = 0;

	//cout << a3 % b3 << endl; //取模运算时，除数也不能为0

	//两个小数不可以取模
	double d1 = 3.14;
	double d2 = 1.1;

	//cout << d1 % d2 << endl;

	system("pause");

	return 0;
}

```

> 总结：只有整型变量可以进行取模运算



**示例3：**

```C++
//递增
int main() {

	//后置递增
	int a = 10;
	a++; //等价于a = a + 1
	cout << a << endl; // 11

	//前置递增
	int b = 10;
	++b;
	cout << b << endl; // 11

	//区别
	//前置递增先对变量进行++，再计算表达式
	int a2 = 10;
	int b2 = ++a2 * 10;
	cout << b2 << endl;

	//后置递增先计算表达式，后对变量进行++
	int a3 = 10;
	int b3 = a3++ * 10;
	cout << b3 << endl;

	system("pause");

	return 0;
}

```



> 总结：前置递增先对变量进行++，再计算表达式，后置递增相反









### 3.2 赋值运算符

**作用：**用于将表达式的值赋给变量

赋值运算符包括以下几个符号：

| **运算符** | **术语** | **示例**   | **结果**  |
| ---------- | -------- | ---------- | --------- |
| =          | 赋值     | a=2; b=3;  | a=2; b=3; |
| +=         | 加等于   | a=0; a+=2; | a=2;      |
| -=         | 减等于   | a=5; a-=3; | a=2;      |
| *=         | 乘等于   | a=2; a*=2; | a=4;      |
| /=         | 除等于   | a=4; a/=2; | a=2;      |
| %=         | 模等于   | a=3; a%2;  | a=1;      |



**示例：**

```C++
int main() {

	//赋值运算符

	// =
	int a = 10;
	a = 100;
	cout << "a = " << a << endl;

	// +=
	a = 10;
	a += 2; // a = a + 2;
	cout << "a = " << a << endl;

	// -=
	a = 10;
	a -= 2; // a = a - 2
	cout << "a = " << a << endl;

	// *=
	a = 10;
	a *= 2; // a = a * 2
	cout << "a = " << a << endl;

	// /=
	a = 10;
	a /= 2;  // a = a / 2;
	cout << "a = " << a << endl;

	// %=
	a = 10;
	a %= 2;  // a = a % 2;
	cout << "a = " << a << endl;

	system("pause");

	return 0;
}
```









### 3.3 比较运算符

**作用：**用于表达式的比较，并返回一个真值或假值

比较运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果** |
| ---------- | -------- | -------- | -------- |
| ==         | 相等于   | 4 == 3   | 0        |
| !=         | 不等于   | 4 != 3   | 1        |
| <          | 小于     | 4 < 3    | 0        |
| \>         | 大于     | 4 > 3    | 1        |
| <=         | 小于等于 | 4 <= 3   | 0        |
| \>=        | 大于等于 | 4 >= 1   | 1        |

示例：

```C++
int main() {

	int a = 10;
	int b = 20;

	cout << (a == b) << endl; // 0 

	cout << (a != b) << endl; // 1

	cout << (a > b) << endl; // 0

	cout << (a < b) << endl; // 1

	cout << (a >= b) << endl; // 0

	cout << (a <= b) << endl; // 1
	
	system("pause");

	return 0;
}
```



> 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 













### 3.4 逻辑运算符

**作用：**用于根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果**                                                 |
| ---------- | -------- | -------- | -------------------------------------------------------- |
| !          | 非       | !a       | 如果a为假，则!a为真；  如果a为真，则!a为假。             |
| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|       | 或       | a \|\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |

**示例1：**逻辑非

```C++
//逻辑运算符  --- 非
int main() {

	int a = 10;

	cout << !a << endl; // 0

	cout << !!a << endl; // 1

	system("pause");

	return 0;
}
```

> 总结： 真变假，假变真





**示例2：**逻辑与

```C++
//逻辑运算符  --- 与
int main() {

	int a = 10;
	int b = 10;

	cout << (a && b) << endl;// 1

	a = 10;
	b = 0;

	cout << (a && b) << endl;// 0 

	a = 0;
	b = 0;

	cout << (a && b) << endl;// 0

	system("pause");

	return 0;
}

```

> 总结：逻辑==与==运算符总结： ==同真为真，其余为假==







**示例3：**逻辑或

```c++
//逻辑运算符  --- 或
int main() {

	int a = 10;
	int b = 10;

	cout << (a || b) << endl;// 1

	a = 10;
	b = 0;

	cout << (a || b) << endl;// 1 

	a = 0;
	b = 0;

	cout << (a || b) << endl;// 0

	system("pause");

	return 0;
}
```

> 逻辑==或==运算符总结： ==同假为假，其余为真==

















## 4 程序流程结构

C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==

* 顺序结构：程序按顺序执行，不发生跳转
* 选择结构：依据条件是否满足，有选择的执行相应功能
* 循环结构：依据条件是否满足，循环多次执行某段代码



### 4.1 选择结构

#### 4.1.1 if语句

**作用：**执行满足条件的语句

if语句的三种形式

* 单行格式if语句

* 多行格式if语句

* 多条件的if语句

  

1. 单行格式if语句：`if(条件){ 条件满足执行的语句 }`

   ![img](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/clip_image002.png)

   示例：

   ```C++
   int main() {
   
   	//选择结构-单行if语句
   	//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印
   
   	int score = 0;
   	cout << "请输入一个分数：" << endl;
   	cin >> score;
   
   	cout << "您输入的分数为： " << score << endl;
   
   	//if语句
   	//注意事项，在if判断语句后面，不要加分号
   	if (score > 600)
   	{
   		cout << "我考上了一本大学！！！" << endl;
   	}
   
   	system("pause");
   
   	return 0;
   }
   ```

   


> 注意：if条件表达式后不要加分号







2. 多行格式if语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };`

![img](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/clip_image002-1541662519170.png)



示例：

```C++
int main() {

	int score = 0;

	cout << "请输入考试分数：" << endl;

	cin >> score;

	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else
	{
		cout << "我未考上一本大学" << endl;
	}

	system("pause");

	return 0;
}
```











3. 多条件的if语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}`

![img](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/clip_image002-1541662566808.png)







示例：

```C++
	int main() {

	int score = 0;

	cout << "请输入考试分数：" << endl;

	cin >> score;

	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}

	system("pause");

	return 0;
}
```









**嵌套if语句**：在if语句中，可以嵌套使用if语句，达到更精确的条件判断



案例需求：

* 提示用户输入一个高考考试分数，根据分数做如下判断
* 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；
* 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。



**示例：**

```c++
int main() {

	int score = 0;

	cout << "请输入考试分数：" << endl;

	cin >> score;

	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
		if (score > 700)
		{
			cout << "我考上了北大" << endl;
		}
		else if (score > 650)
		{
			cout << "我考上了清华" << endl;
		}
		else
		{
			cout << "我考上了人大" << endl;
		}
		
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}

	system("pause");

	return 0;
}
```







**练习案例：** 三只小猪称体重

有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![三只小猪](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/三只小猪.jpg)









#### 4.1.2 三目运算符

**作用：** 通过三目运算符实现简单的判断

**语法：**`表达式1 ? 表达式2 ：表达式3`

**解释：**

如果表达式1的值为真，执行表达式2，并返回表达式2的结果；

如果表达式1的值为假，执行表达式3，并返回表达式3的结果。

**示例：**

```C++
int main() {

	int a = 10;
	int b = 20;
	int c = 0;

	c = a > b ? a : b;
	cout << "c = " << c << endl;

	//C++中三目运算符返回的是变量,可以继续赋值

	(a > b ? a : b) = 100;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;

	system("pause");

	return 0;
}
```

> 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰









#### 4.1.3 switch语句

**作用：**执行多条件分支语句

**语法：**

```C++
switch(表达式)

{

	case 结果1：执行语句;break;

	case 结果2：执行语句;break;

	...

	default:执行语句;break;

}

```







**示例：**

```C++
int main() {

	//请给电影评分 
	//10 ~ 9   经典   
	// 8 ~ 7   非常好
	// 6 ~ 5   一般
	// 5分以下 烂片

	int score = 0;
	cout << "请给电影打分" << endl;
	cin >> score;

	switch (score)
	{
	case 10:
	case 9:
		cout << "经典" << endl;
		break;
	case 8:
		cout << "非常好" << endl;
		break;
	case 7:
	case 6:
		cout << "一般" << endl;
		break;
	default:
		cout << "烂片" << endl;
		break;
	}

	system("pause");

	return 0;
}
```



> 注意1：switch语句中表达式类型只能是整型或者字符型

> 注意2：case里如果没有break，那么程序会一直向下执行

> 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间















### 4.2 循环结构

#### 4.2.1 while循环语句

**作用：**满足循环条件，执行循环语句

**语法：**` while(循环条件){ 循环语句 }`

**解释：**==只要循环条件的结果为真，就执行循环语句==

![img](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/clip_image002-1541668640382.png)







**示例：**

```C++
int main() {

	int num = 0;
	while (num < 10)
	{
		cout << "num = " << num << endl;
		num++;
	}
	
	system("pause");

	return 0;
}
```



> 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环









**while循环练习案例：**==猜数字==

**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。



![猜数字](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/猜数字.jpg)

















#### 4.2.2 do...while循环语句

**作用：** 满足循环条件，执行循环语句

**语法：** `do{ 循环语句 } while(循环条件);`

**注意：**与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件

![img](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/clip_image002-1541671163478.png)



**示例：**

```C++
int main() {

	int num = 0;

	do
	{
		cout << num << endl;
		num++;

	} while (num < 10);
	
	
	system("pause");

	return 0;
}
```



> 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件













**练习案例：水仙花数**

**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身

例如：1^3 + 5^3+ 3^3 = 153

请利用do...while语句，求出所有3位数中的水仙花数





















#### 4.2.3 for循环语句

**作用：** 满足循环条件，执行循环语句

**语法：**` for(起始表达式;条件表达式;末尾循环体) { 循环语句; }`



**示例：**

```C++
int main() {

	for (int i = 0; i < 10; i++)
	{
		cout << i << endl;
	}
	
	system("pause");

	return 0;
}
```







**详解：**

![1541673704101](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541673704101.png)



> 注意：for循环中的表达式，要用分号进行分隔

> 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用











**练习案例：敲桌子**

案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。

![timg](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/timg.gif)













#### 4.2.4 嵌套循环

**作用：** 在循环体中再嵌套一层循环，解决一些实际问题

例如我们想在屏幕中打印如下图片，就需要利用嵌套循环

![1541676003486](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541676003486.png)











**示例：**

```C++
int main() {

	//外层循环执行1次，内层循环执行1轮
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			cout << "*" << " ";
		}
		cout << endl;
	}

	system("pause");

	return 0;
}
```













**练习案例：**乘法口诀表

案例描述：利用嵌套循环，实现九九乘法表

![0006018857256120_b](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/0006018857256120_b.jpg)





### 4.3 跳转语句

#### 4.3.1 break语句

**作用:** 用于跳出==选择结构==或者==循环结构==

break使用的时机：

* 出现在switch条件语句中，作用是终止case并跳出switch
* 出现在循环语句中，作用是跳出当前的循环语句
* 出现在嵌套循环中，跳出最近的内层循环语句



**示例1：**

```C++
int main() {
	//1、在switch 语句中使用break
	cout << "请选择您挑战副本的难度：" << endl;
	cout << "1、普通" << endl;
	cout << "2、中等" << endl;
	cout << "3、困难" << endl;

	int num = 0;

	cin >> num;

	switch (num)
	{
	case 1:
		cout << "您选择的是普通难度" << endl;
		break;
	case 2:
		cout << "您选择的是中等难度" << endl;
		break;
	case 3:
		cout << "您选择的是困难难度" << endl;
		break;
	}

	system("pause");

	return 0;
}
```



**示例2：**

```C++
int main() {
	//2、在循环语句中用break
	for (int i = 0; i < 10; i++)
	{
		if (i == 5)
		{
			break; //跳出循环语句
		}
		cout << i << endl;
	}

	system("pause");

	return 0;
}
```



**示例3：**

```C++
int main() {
	//在嵌套循环语句中使用break，退出内层循环
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			if (j == 5)
			{
				break;
			}
			cout << "*" << " ";
		}
		cout << endl;
	}
	
	system("pause");

	return 0;
}
```















#### 4.3.2 continue语句

**作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

**示例：**

```C++
int main() {

	for (int i = 0; i < 100; i++)
	{
		if (i % 2 == 0)
		{
			continue;
		}
		cout << i << endl;
	}
	
	system("pause");

	return 0;
}
```



> 注意：continue并没有使整个循环终止，而break会跳出循环











#### 4.3.3 goto语句

**作用：**可以无条件跳转语句



**语法：** `goto 标记;`

**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置



**示例：**

```C++
int main() {

	cout << "1" << endl;

	goto FLAG;

	cout << "2" << endl;
	cout << "3" << endl;
	cout << "4" << endl;

	FLAG:

	cout << "5" << endl;
	
	system("pause");

	return 0;
}
```



> 注意：在程序中不建议使用goto语句，以免造成程序流程混乱













## 5 数组

### 5.1 概述

所谓数组，就是一个集合，里面存放了相同类型的数据元素



**特点1：**数组中的每个==数据元素都是相同的数据类型==

**特点2：**数组是由==连续的内存==位置组成的













![1541748375356](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541748375356.png)













### 5.2 一维数组

#### 5.2.1 一维数组定义方式

一维数组定义的三种方式：

1. ` 数据类型  数组名[ 数组长度 ]; `
2. `数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};`
3. `数据类型  数组名[ ] = { 值1，值2 ...};`



示例

```C++
int main() {

	//定义方式1
	//数据类型 数组名[元素个数];
	int score[10];

	//利用下标赋值
	score[0] = 100;
	score[1] = 99;
	score[2] = 85;

	//利用下标输出
	cout << score[0] << endl;
	cout << score[1] << endl;
	cout << score[2] << endl;


	//第二种定义方式
	//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};
	//如果{}内不足10个数据，剩余数据用0补全
	int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };
	
	//逐个输出
	//cout << score2[0] << endl;
	//cout << score2[1] << endl;

	//一个一个输出太麻烦，因此可以利用循环进行输出
	for (int i = 0; i < 10; i++)
	{
		cout << score2[i] << endl;
	}

	//定义方式3
	//数据类型 数组名[] =  {值1，值2 ，值3 ...};
	int score3[] = { 100,90,80,70,60,50,40,30,20,10 };

	for (int i = 0; i < 10; i++)
	{
		cout << score3[i] << endl;
	}

	system("pause");

	return 0;
}
```



> 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名

> 总结2：数组中下标是从0开始索引









#### 5.2.2 一维数组数组名

一维数组名称的**用途**：

1. 可以统计整个数组在内存中的长度
2. 可以获取数组在内存中的首地址





**示例：**

```C++
int main() {

	//数组名用途
	//1、可以获取整个数组占用内存空间大小
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	cout << "整个数组所占内存空间为： " << sizeof(arr) << endl;
	cout << "每个元素所占内存空间为： " << sizeof(arr[0]) << endl;
	cout << "数组的元素个数为： " << sizeof(arr) / sizeof(arr[0]) << endl;

	//2、可以通过数组名获取到数组首地址
	cout << "数组首地址为： " << (int)arr << endl;
	cout << "数组中第一个元素地址为： " << (int)&arr[0] << endl;
	cout << "数组中第二个元素地址为： " << (int)&arr[1] << endl;

	//arr = 100; 错误，数组名是常量，因此不可以赋值


	system("pause");

	return 0;
}
```



> 注意：数组名是常量，不可以赋值

> 总结1：直接打印数组名，可以查看数组所占内存的首地址

>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小











**练习案例1**：五只小猪称体重

**案例描述：**

在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};

找出并打印最重的小猪体重。









**练习案例2：**数组元素逆置

**案例描述：**请声明一个5个元素的数组，并且将元素逆置.

(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);

















#### 5.2.3 冒泡排序

**作用：** 最常用的排序算法，对数组内元素进行排序

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。
3. 重复以上的步骤，每次比较次数-1，直到不需要比较

![1541905327273](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541905327273.png)

**示例：** 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序

```C++
int main() {

	int arr[9] = { 4,2,8,0,5,7,1,3,9 };

	for (int i = 0; i < 9 - 1; i++)
	{
		for (int j = 0; j < 9 - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}

	for (int i = 0; i < 9; i++)
	{
		cout << arr[i] << endl;
	}
    
	system("pause");

	return 0;
}
```









### 5.3 二维数组

二维数组就是在一维数组上，多加一个维度。

![1541905559138](C:/Users/mm611/Desktop/C++/C++基础入门讲义/assets/1541905559138.png)

#### 5.3.1 二维数组定义方式

二维数组定义的四种方式：

1. ` 数据类型  数组名[ 行数 ][ 列数 ]; `
2. `数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };`
3. `数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};`
4. ` 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};`



> 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==

示例：

```C++
int main() {

	//方式1  
	//数组类型 数组名 [行数][列数]
	int arr[2][3];
	arr[0][0] = 1;
	arr[0][1] = 2;
	arr[0][2] = 3;
	arr[1][0] = 4;
	arr[1][1] = 5;
	arr[1][2] = 6;

	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			cout << arr[i][j] << " ";
		}
		cout << endl;
	}

	//方式2 
	//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };
	int arr2[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};

	//方式3
	//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr3[2][3] = { 1,2,3,4,5,6 }; 

	//方式4 
	//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr4[][3] = { 1,2,3,4,5,6 };
	
	system("pause");

	return 0;
}
```



> 总结：在定义二维数组时，如果初始化了数据，可以省略行数













#### 5.3.2 二维数组数组名



* 查看二维数组所占内存空间
* 获取二维数组首地址





**示例：**

```C++
int main() {

	//二维数组数组名
	int arr[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};

	cout << "二维数组大小： " << sizeof(arr) << endl;
	cout << "二维数组一行大小： " << sizeof(arr[0]) << endl;
	cout << "二维数组元素大小： " << sizeof(arr[0][0]) << endl;

	cout << "二维数组行数： " << sizeof(arr) / sizeof(arr[0]) << endl;
	cout << "二维数组列数： " << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;

	//地址
	cout << "二维数组首地址：" << arr << endl;
	cout << "二维数组第一行地址：" << arr[0] << endl;
	cout << "二维数组第二行地址：" << arr[1] << endl;

	cout << "二维数组第一个元素地址：" << &arr[0][0] << endl;
	cout << "二维数组第二个元素地址：" << &arr[0][1] << endl;

	system("pause");

	return 0;
}
```



> 总结1：二维数组名就是这个数组的首地址

> 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小













#### **5.3.3 二维数组应用案例**

**考试成绩统计：**

案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，**请分别输出三名同学的总成绩**

|      | 语文 | 数学 | 英语 |
| ---- | ---- | ---- | ---- |
| 张三 | 100  | 100  | 100  |
| 李四 | 90   | 50   | 100  |
| 王五 | 60   | 70   | 80   |





**参考答案：**

```C++
int main() {

	int scores[3][3] =
	{
		{100,100,100},
		{90,50,100},
		{60,70,80},
	};

	string names[3] = { "张三","李四","王五" };

	for (int i = 0; i < 3; i++)
	{
		int sum = 0;
		for (int j = 0; j < 3; j++)
		{
			sum += scores[i][j];
		}
		cout << names[i] << "同学总成绩为： " << sum << endl;
	}

	system("pause");

	return 0;
}
```













## 6 函数

### 6.1 概述

**作用：**将一段经常使用的代码封装起来，减少重复代码

一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。

### 6.2 函数的定义

函数的定义一般主要有5个步骤：

1、返回值类型 

2、函数名

3、参数表列

4、函数体语句 

5、return 表达式

**语法：** 

```C++
返回值类型 函数名 （参数列表）
{

       函数体语句

       return表达式

}
```



* 返回值类型 ：一个函数可以返回一个值。在函数定义中
* 函数名：给函数起个名称
* 参数列表：使用该函数时，传入的数据
* 函数体语句：花括号内的代码，函数内需要执行的语句
* return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据





**示例：**定义一个加法函数，实现两个数相加

```C++
//函数定义
int add(int num1, int num2)
{
	int sum = num1 + num2;
	return sum;
}
```











### 6.3 函数的调用

**功能：**使用定义好的函数

**语法：**` 函数名（参数）`

**示例：**

```C++
//函数定义
int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参
{
	int sum = num1 + num2;
	return sum;
}

int main() {

	int a = 10;
	int b = 10;
	//调用add函数
	int sum = add(a, b);//调用时的a，b称为实际参数，简称实参
	cout << "sum = " << sum << endl;

	a = 100;
	b = 100;

	sum = add(a, b);
	cout << "sum = " << sum << endl;

	system("pause");

	return 0;
}
```

> 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参









### 6.4 值传递

* 所谓值传递，就是函数调用时实参将数值传入给形参
* 值传递时，==如果形参发生，并不会影响实参==



**示例：**

```C++
void swap(int num1, int num2)
{
	cout << "交换前：" << endl;
	cout << "num1 = " << num1 << endl;
	cout << "num2 = " << num2 << endl;

	int temp = num1;
	num1 = num2;
	num2 = temp;

	cout << "交换后：" << endl;
	cout << "num1 = " << num1 << endl;
	cout << "num2 = " << num2 << endl;

	//return ; 当函数声明时候，不需要返回值，可以不写return
}

int main() {

	int a = 10;
	int b = 20;

	swap(a, b);

	cout << "mian中的 a = " << a << endl;
	cout << "mian中的 b = " << b << endl;

	system("pause");

	return 0;
}
```



> 总结： 值传递时，形参是修饰不了实参的









### **6.5 函数的常见样式**

常见的函数样式有4种

1. 无参无返
2. 有参无返
3. 无参有返
4. 有参有返

**示例：**

```C++
//函数常见样式
//1、 无参无返
void test01()
{
	//void a = 10; //无类型不可以创建变量,原因无法分配内存
	cout << "this is test01" << endl;
	//test01(); 函数调用
}

//2、 有参无返
void test02(int a)
{
	cout << "this is test02" << endl;
	cout << "a = " << a << endl;
}

//3、无参有返
int test03()
{
	cout << "this is test03 " << endl;
	return 10;
}

//4、有参有返
int test04(int a, int b)
{
	cout << "this is test04 " << endl;
	int sum = a + b;
	return sum;
}
```











### 6.6 函数的声明

**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。



*  函数的**声明可以多次**，但是函数的**定义只能有一次**



**示例：**

```C++
//声明可以多次，定义只能一次
//声明
int max(int a, int b);
int max(int a, int b);
//定义
int max(int a, int b)
{
	return a > b ? a : b;
}

int main() {

	int a = 100;
	int b = 200;

	cout << max(a, b) << endl;

	system("pause");

	return 0;
}
```











### 6.7 函数的分文件编写

**作用：**让代码结构更加清晰

函数分文件编写一般有4个步骤

1. 创建后缀名为.h的头文件  
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

**示例：**

```C++
//swap.h文件
#include<iostream>
using namespace std;

//实现两个数字交换的函数声明
void swap(int a, int b);

```

```C++
//swap.cpp文件
#include "swap.h"

void swap(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
}
```

```C++
//main函数文件
#include "swap.h"
int main() {

	int a = 100;
	int b = 200;
	swap(a, b);

	system("pause");

	return 0;
}

```













## 7 指针

### 7.1 指针的基本概念

**指针的作用：** 可以通过指针间接访问内存



* 内存编号是从0开始记录的，一般用十六进制数字表示

* 可以利用指针变量保存地址

  

### 7.2 指针变量的定义和使用

指针变量定义语法： `数据类型 * 变量名；`

**示例：**

```C++
int main() {

	//1、指针的定义
	int a = 10; //定义整型变量a
	
	//指针定义语法： 数据类型 * 变量名 ;
	int * p;

	//指针变量赋值
	p = &a; //指针指向变量a的地址
	cout << &a << endl; //打印数据a的地址
	cout << p << endl;  //打印指针变量p

	//2、指针的使用
	//通过*操作指针变量指向的内存
	cout << "*p = " << *p << endl;

	system("pause");

	return 0;
}
```



指针变量和普通变量的区别

* 普通变量存放的是数据,指针变量存放的是地址
* 指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用



> 总结1： 我们可以通过 & 符号 获取变量的地址

> 总结2：利用指针可以记录地址

> 总结3：对指针变量解引用，可以操作指针指向的内存











### 7.3 指针所占内存空间



提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？



**示例：**

```C++
int main() {

	int a = 10;

	int * p;
	p = &a; //指针指向数据a的地址

	cout << *p << endl; //* 解引用
	cout << sizeof(p) << endl;
	cout << sizeof(char *) << endl;
	cout << sizeof(float *) << endl;
	cout << sizeof(double *) << endl;

	system("pause");

	return 0;
}
```



> 总结：所有指针类型在32位操作系统下是4个字节











### 7.4 空指针和野指针

**空指针**：指针变量指向内存中编号为0的空间

**用途：**初始化指针变量

**注意：**空指针指向的内存是不可以访问的



**示例1：空指针**

```C++
int main() {

	//指针变量p指向内存地址编号为0的空间
	int * p = NULL;

	//访问空指针报错 
	//内存编号0 ~255为系统占用内存，不允许用户访问
	cout << *p << endl;

	system("pause");

	return 0;
}
```















**野指针**：指针变量指向非法的内存空间

**示例2：野指针**

```C++
int main() {

	//指针变量p指向内存地址编号为0x1100的空间
	int * p = (int *)0x1100;

	//访问野指针报错 
	cout << *p << endl;

	system("pause");

	return 0;
}
```





> 总结：空指针和野指针都不是我们申请的空间，因此不要访问。









### 7.5 const修饰指针

const修饰指针有三种情况

1. const修饰指针   --- 常量指针
2. const修饰常量   --- 指针常量
3. const即修饰指针，又修饰常量




**示例：**


```c++
int main() {

	int a = 10;
	int b = 10;

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &a; 
	p1 = &b; //正确
	//*p1 = 100;  报错
	

	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &a;
	//p2 = &b; //错误
	*p2 = 100; //正确

    //const既修饰指针又修饰常量
	const int * const p3 = &a;
	//p3 = &b; //错误
	//*p3 = 100; //错误

	system("pause");

	return 0;
}
```



> 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量









### 7.6 指针和数组

**作用：**利用指针访问数组中元素

**示例：**

```C++
int main() {

	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };

	int * p = arr;  //指向数组的指针

	cout << "第一个元素： " << arr[0] << endl;
	cout << "指针访问第一个元素： " << *p << endl;

	for (int i = 0; i < 10; i++)
	{
		//利用指针遍历数组
		cout << *p << endl;
		p++;
	}

	system("pause");

	return 0;
}
```











### 7.7 指针和函数

**作用：**利用指针作函数参数，可以修改实参的值



**示例：**

```C++
//值传递
void swap1(int a ,int b)
{
	int temp = a;
	a = b; 
	b = temp;
}
//地址传递
void swap2(int * p1, int *p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main() {

	int a = 10;
	int b = 20;
	swap1(a, b); // 值传递不会改变实参

	swap2(&a, &b); //地址传递会改变实参

	cout << "a = " << a << endl;

	cout << "b = " << b << endl;

	system("pause");

	return 0;
}
```



> 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递













### 7.8 指针、数组、函数

**案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序

例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };



**示例：**

```c++
//冒泡排序函数
void bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}

//打印数组函数
void printArray(int arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << endl;
	}
}

int main() {

	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
	int len = sizeof(arr) / sizeof(int);

	bubbleSort(arr, len);

	printArray(arr, len);

	system("pause");

	return 0;
}
```



> 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针









## 8 结构体

### 8.1 结构体基本概念

结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型



### 8.2 结构体定义和使用

**语法：**`struct 结构体名 { 结构体成员列表 }；`

通过结构体创建变量的方式有三种：

* struct 结构体名 变量名
* struct 结构体名 变量名 = { 成员1值 ， 成员2值...}
* 定义结构体时顺便创建变量

**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}stu3; //结构体变量创建方式3 


int main() {

	//结构体变量创建方式1
	struct student stu1; //struct 关键字可以省略

	stu1.name = "张三";
	stu1.age = 18;
	stu1.score = 100;
	
	cout << "姓名：" << stu1.name << " 年龄：" << stu1.age  << " 分数：" << stu1.score << endl;

	//结构体变量创建方式2
	struct student stu2 = { "李四",19,60 };

	cout << "姓名：" << stu2.name << " 年龄：" << stu2.age  << " 分数：" << stu2.score << endl;


	stu3.name = "王五";
	stu3.age = 18;
	stu3.score = 80;
	

	cout << "姓名：" << stu3.name << " 年龄：" << stu3.age  << " 分数：" << stu3.score << endl;

	system("pause");

	return 0;
}
```



> 总结1：定义结构体时的关键字是struct，不可省略

> 总结2：创建结构体变量时，关键字struct可以省略

> 总结3：结构体变量利用操作符 ''.''  访问成员









### 8.3 结构体数组

**作用：**将自定义的结构体放入到数组中方便维护

**语法：**` struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }`

**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}

int main() {
	
	//结构体数组
	struct student arr[3]=
	{
		{"张三",18,80 },
		{"李四",19,60 },
		{"王五",20,70 }
	};

	for (int i = 0; i < 3; i++)
	{
		cout << "姓名：" << arr[i].name << " 年龄：" << arr[i].age << " 分数：" << arr[i].score << endl;
	}

	system("pause");

	return 0;
}
```











### 8.4 结构体指针

**作用：**通过指针访问结构体中的成员



* 利用操作符 `-> `可以通过结构体指针访问结构体属性



**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};


int main() {
	
	struct student stu = { "张三",18,100, };
	
	struct student * p = &stu;
	
	p->score = 80; //指针通过 -> 操作符可以访问成员

	cout << "姓名：" << p->name << " 年龄：" << p->age << " 分数：" << p->score << endl;
	
	system("pause");

	return 0;
}
```



> 总结：结构体指针可以通过 -> 操作符 来访问结构体中的成员













### 8.5 结构体嵌套结构体

**作用：** 结构体中的成员可以是另一个结构体

**例如：**每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//教师结构体定义
struct teacher
{
    //成员列表
	int id; //职工编号
	string name;  //教师姓名
	int age;   //教师年龄
	struct student stu; //子结构体 学生
};


int main() {

	struct teacher t1;
	t1.id = 10000;
	t1.name = "老王";
	t1.age = 40;

	t1.stu.name = "张三";
	t1.stu.age = 18;
	t1.stu.score = 100;

	cout << "教师 职工编号： " << t1.id << " 姓名： " << t1.name << " 年龄： " << t1.age << endl;
	
	cout << "辅导学员 姓名： " << t1.stu.name << " 年龄：" << t1.stu.age << " 考试分数： " << t1.stu.score << endl;

	system("pause");

	return 0;
}
```



**总结：**在结构体中可以定义另一个结构体作为成员，用来解决实际问题









### 8.6 结构体做函数参数 

**作用：**将结构体作为参数向函数中传递

传递方式有两种：

* 值传递
* 地址传递

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//值传递
void printStudent(student stu )
{
	stu.age = 28;
	cout << "子函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;
}

//地址传递
void printStudent2(student *stu)
{
	stu->age = 28;
	cout << "子函数中 姓名：" << stu->name << " 年龄： " << stu->age  << " 分数：" << stu->score << endl;
}

int main() {

	student stu = { "张三",18,100};
	//值传递
	printStudent(stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age << " 分数：" << stu.score << endl;

	cout << endl;

	//地址传递
	printStudent2(&stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;

	system("pause");

	return 0;
}
```

> 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递







### 8.7 结构体中 const使用场景

**作用：**用const来防止误操作

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//const使用场景
void printStudent(const student *stu) //加const防止函数体中的误操作
{
	//stu->age = 100; //操作失败，因为加了const修饰
	cout << "姓名：" << stu->name << " 年龄：" << stu->age << " 分数：" << stu->score << endl;

}

int main() {

	student stu = { "张三",18,100 };

	printStudent(&stu);

	system("pause");

	return 0;
}
```









### 8.8 结构体案例

#### 8.8.1 案例1

**案例描述：**

学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下

设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员

学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值

最终打印出老师数据以及老师所带的学生数据。



**示例：**

```C++
struct Student
{
	string name;
	int score;
};
struct Teacher
{
	string name;
	Student sArray[5];
};

void allocateSpace(Teacher tArray[] , int len)
{
	string tName = "教师";
	string sName = "学生";
	string nameSeed = "ABCDE";
	for (int i = 0; i < len; i++)
	{
		tArray[i].name = tName + nameSeed[i];
		
		for (int j = 0; j < 5; j++)
		{
			tArray[i].sArray[j].name = sName + nameSeed[j];
			tArray[i].sArray[j].score = rand() % 61 + 40;
		}
	}
}

void printTeachers(Teacher tArray[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << tArray[i].name << endl;
		for (int j = 0; j < 5; j++)
		{
			cout << "\t姓名：" << tArray[i].sArray[j].name << " 分数：" << tArray[i].sArray[j].score << endl;
		}
	}
}

int main() {

	srand((unsigned int)time(NULL)); //随机数种子 头文件 #include <ctime>

	Teacher tArray[3]; //老师数组

	int len = sizeof(tArray) / sizeof(Teacher);

	allocateSpace(tArray, len); //创建数据

	printTeachers(tArray, len); //打印数据
	
	system("pause");

	return 0;
}
```









#### 8.8.2 案例2

**案例描述：**

设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。

通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。



五名英雄信息如下：

```C++
		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},
```









**示例：**

```C++
//英雄结构体
struct hero
{
	string name;
	int age;
	string sex;
};
//冒泡排序
void bubbleSort(hero arr[] , int len)
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - 1 - i; j++)
		{
			if (arr[j].age > arr[j + 1].age)
			{
				hero temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}
//打印数组
void printHeros(hero arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << "姓名： " << arr[i].name << " 性别： " << arr[i].sex << " 年龄： " << arr[i].age << endl;
	}
}

int main() {

	struct hero arr[5] =
	{
		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},
	};

	int len = sizeof(arr) / sizeof(hero); //获取数组元素个数

	bubbleSort(arr, len); //排序

	printHeros(arr, len); //打印

	system("pause");

	return 0;
}
```

# C++核心编程

## 1 内存分区模型

C++程序在执行时，将内存大方向划分为**4个区域**

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

**内存四区意义：**

不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程



### 1.1 程序运行前

​	在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域

​	**代码区：**

​		存放 CPU 执行的机器指令

​		代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

​		代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

​	**全局区：**

​		全局变量和静态变量存放在此.

​		全局区还包含了常量区, 字符串常量和其他常量也存放在此.

​		==该区域的数据在程序结束后由操作系统释放==.

**示例：**

```c++
//全局变量
int g_a = 10;
int g_b = 10;

//全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main() {

	//局部变量
	int a = 10;
	int b = 10;

	//打印地址
	cout << "局部变量a地址为： " << (int)&a << endl;
	cout << "局部变量b地址为： " << (int)&b << endl;

	cout << "全局变量g_a地址为： " <<  (int)&g_a << endl;
	cout << "全局变量g_b地址为： " <<  (int)&g_b << endl;

	//静态变量
	static int s_a = 10;
	static int s_b = 10;

	cout << "静态变量s_a地址为： " << (int)&s_a << endl;
	cout << "静态变量s_b地址为： " << (int)&s_b << endl;

	cout << "字符串常量地址为： " << (int)&"hello world" << endl;
	cout << "字符串常量地址为： " << (int)&"hello world1" << endl;

	cout << "全局常量c_g_a地址为： " << (int)&c_g_a << endl;
	cout << "全局常量c_g_b地址为： " << (int)&c_g_b << endl;

	const int c_l_a = 10;
	const int c_l_b = 10;
	cout << "局部常量c_l_a地址为： " << (int)&c_l_a << endl;
	cout << "局部常量c_l_b地址为： " << (int)&c_l_b << endl;

	system("pause");

	return 0;
}
```

打印结果：

![1545017602518](assets/1545017602518.png)



总结：

* C++中在程序运行前分为全局区和代码区
* 代码区特点是共享和只读
* 全局区中存放全局变量、静态变量、常量
* 常量区中存放 const修饰的全局常量  和 字符串常量






### 1.2 程序运行后



​	**栈区：**

​		由编译器自动分配释放, 存放函数的参数值,局部变量等

​		注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放



**示例：**

```c++
int * func()
{
	int a = 10;
	return &a;
}

int main() {

	int *p = func();

	cout << *p << endl;
	cout << *p << endl;

	system("pause");

	return 0;
}
```







​	**堆区：**

​		由程序员分配释放,若程序员不释放,程序结束时由操作系统回收

​		在C++中主要利用new在堆区开辟内存

**示例：**

```c++
int* func()
{
	int* a = new int(10);
	return a;
}

int main() {

	int *p = func();

	cout << *p << endl;
	cout << *p << endl;
    
	system("pause");

	return 0;
}
```



**总结：**

堆区数据由程序员管理开辟和释放

堆区数据利用new关键字进行开辟内存









### 1.3 new操作符



​	C++中利用==new==操作符在堆区开辟数据

​	堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==

​	语法：` new 数据类型`

​	利用new创建的数据，会返回该数据对应的类型的指针



**示例1： 基本语法**

```c++
int* func()
{
	int* a = new int(10);
	return a;
}

int main() {

	int *p = func();

	cout << *p << endl;
	cout << *p << endl;

	//利用delete释放堆区数据
	delete p;

	//cout << *p << endl; //报错，释放的空间不可访问

	system("pause");

	return 0;
}
```



**示例2：开辟数组**

```c++
//堆区开辟数组
int main() {

	int* arr = new int[10];

	for (int i = 0; i < 10; i++)
	{
		arr[i] = i + 100;
	}

	for (int i = 0; i < 10; i++)
	{
		cout << arr[i] << endl;
	}
	//释放数组 delete 后加 []
	delete[] arr;

	system("pause");

	return 0;
}

```











## 2 引用

### 2.1 引用的基本使用

**作用： **给变量起别名

**语法：** `数据类型 &别名 = 原名`



**示例：**

```C++
int main() {

	int a = 10;
	int &b = a;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	b = 100;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	system("pause");

	return 0;
}
```







### 2.2 引用注意事项

* 引用必须初始化
* 引用在初始化后，不可以改变

示例：

```C++
int main() {

	int a = 10;
	int b = 20;
	//int &c; //错误，引用必须初始化
	int &c = a; //一旦初始化后，就不可以更改
	c = b; //这是赋值操作，不是更改引用

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;

	system("pause");

	return 0;
}
```











### 2.3 引用做函数参数

**作用：**函数传参时，可以利用引用的技术让形参修饰实参

**优点：**可以简化指针修改实参



**示例：**

```C++
//1. 值传递
void mySwap01(int a, int b) {
	int temp = a;
	a = b;
	b = temp;
}

//2. 地址传递
void mySwap02(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}

//3. 引用传递
void mySwap03(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}

int main() {

	int a = 10;
	int b = 20;

	mySwap01(a, b);
	cout << "a:" << a << " b:" << b << endl;

	mySwap02(&a, &b);
	cout << "a:" << a << " b:" << b << endl;

	mySwap03(a, b);
	cout << "a:" << a << " b:" << b << endl;

	system("pause");

	return 0;
}

```



> 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单













### 2.4 引用做函数返回值



作用：引用是可以作为函数的返回值存在的



注意：**不要返回局部变量引用**

用法：函数调用作为左值



**示例：**

```C++
//返回局部变量引用
int& test01() {
	int a = 10; //局部变量
	return a;
}

//返回静态变量引用
int& test02() {
	static int a = 20;
	return a;
}

int main() {

	//不能返回局部变量的引用
	int& ref = test01();
	cout << "ref = " << ref << endl;
	cout << "ref = " << ref << endl;

	//如果函数做左值，那么必须返回引用
	int& ref2 = test02();
	cout << "ref2 = " << ref2 << endl;
	cout << "ref2 = " << ref2 << endl;

	test02() = 1000;

	cout << "ref2 = " << ref2 << endl;
	cout << "ref2 = " << ref2 << endl;

	system("pause");

	return 0;
}
```





​	









### 2.5 引用的本质

本质：**引用的本质在c++内部实现是一个指针常量.**

讲解示例：

```C++
//发现是引用，转换为 int* const ref = &a;
void func(int& ref){
	ref = 100; // ref是引用，转换为*ref = 100
}
int main(){
	int a = 10;
    
    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
	int& ref = a; 
	ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;
    
	cout << "a:" << a << endl;
	cout << "ref:" << ref << endl;
    
	func(a);
	return 0;
}
```

结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了













### 2.6 常量引用



**作用：**常量引用主要用来修饰形参，防止误操作



在函数形参列表中，可以加==const修饰形参==，防止形参改变实参



**示例：**



```C++
//引用使用的场景，通常用来修饰形参
void showValue(const int& v) {
	//v += 10;
	cout << v << endl;
}

int main() {

	//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误
	//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;
	const int& ref = 10;

	//ref = 100;  //加入const后不可以修改变量
	cout << ref << endl;

	//函数中利用常量引用防止误操作修改实参
	int a = 10;
	showValue(a);

	system("pause");

	return 0;
}
```









## 3 函数提高

### 3.1 函数默认参数



在C++中，函数的形参列表中的形参是可以有默认值的。

语法：` 返回值类型  函数名 （参数= 默认值）{}`



**示例：**

```C++
int func(int a, int b = 10, int c = 10) {
	return a + b + c;
}

//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数
int func2(int a = 10, int b = 10);
int func2(int a, int b) {
	return a + b;
}

int main() {

	cout << "ret = " << func(20, 20) << endl;
	cout << "ret = " << func(100) << endl;

	system("pause");

	return 0;
}
```







### 3.2 函数占位参数



C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置



**语法：** `返回值类型 函数名 (数据类型){}`



在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术



**示例：**

```C++
//函数占位参数 ，占位参数也可以有默认参数
void func(int a, int) {
	cout << "this is func" << endl;
}

int main() {

	func(10,10); //占位参数必须填补

	system("pause");

	return 0;
}
```









### 3.3 函数重载

#### 3.3.1 函数重载概述



**作用：**函数名可以相同，提高复用性



**函数重载满足条件：**

* 同一个作用域下
* 函数名称相同
* 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**



**注意:**  函数的返回值不可以作为函数重载的条件



**示例：**

```C++
//函数重载需要函数都在同一个作用域下
void func()
{
	cout << "func 的调用！" << endl;
}
void func(int a)
{
	cout << "func (int a) 的调用！" << endl;
}
void func(double a)
{
	cout << "func (double a)的调用！" << endl;
}
void func(int a ,double b)
{
	cout << "func (int a ,double b) 的调用！" << endl;
}
void func(double a ,int b)
{
	cout << "func (double a ,int b)的调用！" << endl;
}

//函数返回值不可以作为函数重载条件
//int func(double a, int b)
//{
//	cout << "func (double a ,int b)的调用！" << endl;
//}


int main() {

	func();
	func(10);
	func(3.14);
	func(10,3.14);
	func(3.14 , 10);
	
	system("pause");

	return 0;
}
```

#### 3.3.2 函数重载注意事项



* 引用作为重载条件
* 函数重载碰到函数默认参数





**示例：**

```C++
//函数重载注意事项
//1、引用作为重载条件

void func(int &a)
{
	cout << "func (int &a) 调用 " << endl;
}

void func(const int &a)
{
	cout << "func (const int &a) 调用 " << endl;
}


//2、函数重载碰到函数默认参数

void func2(int a, int b = 10)
{
	cout << "func2(int a, int b = 10) 调用" << endl;
}

void func2(int a)
{
	cout << "func2(int a) 调用" << endl;
}

int main() {
	
	int a = 10;
	func(a); //调用无const
	func(10);//调用有const


	//func2(10); //碰到默认参数产生歧义，需要避免

	system("pause");

	return 0;
}
```







## **4** 类和对象



C++面向对象的三大特性为：==封装、继承、多态==



C++认为==万事万物都皆为对象==，对象上有其属性和行为



**例如：**

​	人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...

​	车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...

​	具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类

### 4.1 封装

#### 4.1.1  封装的意义

封装是C++面向对象三大特性之一

封装的意义：

* 将属性和行为作为一个整体，表现生活中的事物
* 将属性和行为加以权限控制



**封装意义一：**

​	在设计类的时候，属性和行为写在一起，表现事物

**语法：** `class 类名{   访问权限： 属性  / 行为  };`



**示例1：**设计一个圆类，求圆的周长

**示例代码：**

```C++
//圆周率
const double PI = 3.14;

//1、封装的意义
//将属性和行为作为一个整体，用来表现生活中的事物

//封装一个圆类，求圆的周长
//class代表设计一个类，后面跟着的是类名
class Circle
{
public:  //访问权限  公共的权限

	//属性
	int m_r;//半径

	//行为
	//获取到圆的周长
	double calculateZC()
	{
		//2 * pi  * r
		//获取圆的周长
		return  2 * PI * m_r;
	}
};

int main() {

	//通过圆类，创建圆的对象
	// c1就是一个具体的圆
	Circle c1;
	c1.m_r = 10; //给圆对象的半径 进行赋值操作

	//2 * pi * 10 = = 62.8
	cout << "圆的周长为： " << c1.calculateZC() << endl;

	system("pause");

	return 0;
}
```





**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号





**示例2代码：**

```C++
//学生类
class Student {
public:
	void setName(string name) {
		m_name = name;
	}
	void setID(int id) {
		m_id = id;
	}

	void showStudent() {
		cout << "name:" << m_name << " ID:" << m_id << endl;
	}
public:
	string m_name;
	int m_id;
};

int main() {

	Student stu;
	stu.setName("德玛西亚");
	stu.setID(250);
	stu.showStudent();

	system("pause");

	return 0;
}

```









**封装意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：



1. public        公共权限  
2. protected 保护权限
3. private      私有权限







**示例：**

```C++
//三种权限
//公共权限  public     类内可以访问  类外可以访问
//保护权限  protected  类内可以访问  类外不可以访问
//私有权限  private    类内可以访问  类外不可以访问

class Person
{
	//姓名  公共权限
public:
	string m_Name;

	//汽车  保护权限
protected:
	string m_Car;

	//银行卡密码  私有权限
private:
	int m_Password;

public:
	void func()
	{
		m_Name = "张三";
		m_Car = "拖拉机";
		m_Password = 123456;
	}
};

int main() {

	Person p;
	p.m_Name = "李四";
	//p.m_Car = "奔驰";  //保护权限类外访问不到
	//p.m_Password = 123; //私有权限类外访问不到

	system("pause");

	return 0;
}
```







#### 4.1.2 struct和class区别



在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**

区别：

* struct 默认权限为公共
* class   默认权限为私有



```C++
class C1
{
	int  m_A; //默认是私有权限
};

struct C2
{
	int m_A;  //默认是公共权限
};

int main() {

	C1 c1;
	c1.m_A = 10; //错误，访问权限是私有

	C2 c2;
	c2.m_A = 10; //正确，访问权限是公共

	system("pause");

	return 0;
}
```













#### 4.1.3 成员属性设置为私有



**优点1：**将所有成员属性设置为私有，可以自己控制读写权限

**优点2：**对于写权限，我们可以检测数据的有效性



**示例：**

```C++
class Person {
public:

	//姓名设置可读可写
	void setName(string name) {
		m_Name = name;
	}
	string getName()
	{
		return m_Name;
	}


	//获取年龄 
	int getAge() {
		return m_Age;
	}
	//设置年龄
	void setAge(int age) {
		if (age < 0 || age > 150) {
			cout << "你个老妖精!" << endl;
			return;
		}
		m_Age = age;
	}

	//情人设置为只写
	void setLover(string lover) {
		m_Lover = lover;
	}

private:
	string m_Name; //可读可写  姓名
	
	int m_Age; //只读  年龄

	string m_Lover; //只写  情人
};


int main() {

	Person p;
	//姓名设置
	p.setName("张三");
	cout << "姓名： " << p.getName() << endl;

	//年龄设置
	p.setAge(50);
	cout << "年龄： " << p.getAge() << endl;

	//情人设置
	p.setLover("苍井");
	//cout << "情人： " << p.m_Lover << endl;  //只写属性，不可以读取

	system("pause");

	return 0;
}
```









**练习案例1：设计立方体类**

设计立方体类(Cube)

求出立方体的面积和体积

分别用全局函数和成员函数判断两个立方体是否相等。



![1545533548532](assets/1545533548532.png)











**练习案例2：点和圆的关系**

设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。



![1545533829184](assets/1545533829184.png)







### 4.2 对象的初始化和清理



*  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
*  C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。





#### 4.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题



c++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**

**编译器提供的构造函数和析构函数是空实现。**



* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。





**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次





**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次





```C++
class Person
{
public:
	//构造函数
	Person()
	{
		cout << "Person的构造函数调用" << endl;
	}
	//析构函数
	~Person()
	{
		cout << "Person的析构函数调用" << endl;
	}

};

void test01()
{
	Person p;
}

int main() {
	
	test01();

	system("pause");

	return 0;
}
```











#### 4.2.2 构造函数的分类及调用

两种分类方式：

​	按参数分为： 有参构造和无参构造

​	按类型分为： 普通构造和拷贝构造

三种调用方式：

​	括号法

​	显示法

​	隐式转换法



**示例：**

```C++
//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

//2、构造函数的调用
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person p5(p4);
}

int main() {

	test01();
	//test02();

	system("pause");

	return 0;
}
```









#### 4.2.3 拷贝构造函数调用时机



C++中拷贝构造函数调用时机通常有三种情况

* 使用一个已经创建完毕的对象来初始化一个新对象
* 值传递的方式给函数参数传值
* 以值方式返回局部对象



**示例：**

```C++
class Person {
public:
	Person() {
		cout << "无参构造函数!" << endl;
		mAge = 0;
	}
	Person(int age) {
		cout << "有参构造函数!" << endl;
		mAge = age;
	}
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout << (int *)&p1 << endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout << (int *)&p << endl;
}


int main() {

	//test01();
	//test02();
	test03();

	system("pause");

	return 0;
}
```





#### 4.2.4 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1．默认构造函数(无参，函数体为空)

2．默认析构函数(无参，函数体为空)

3．默认拷贝构造函数，对属性进行值拷贝



构造函数调用规则如下：

* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造


* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数



示例：

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout << "p2的年龄为： " << p2.age << endl;
}

void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}

int main() {

	test01();

	system("pause");

	return 0;
}
```









#### 4.2.5 深拷贝与浅拷贝



深浅拷贝是面试经典问题，也是常见的一个坑



浅拷贝：简单的赋值拷贝操作



深拷贝：在堆区重新申请空间，进行拷贝操作



**示例：**

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题









#### 4.2.6 初始化列表



**作用：**

C++提供了初始化列表语法，用来初始化属性



**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`



**示例：**

```C++
class Person {
public:

	////传统方式初始化
	//Person(int a, int b, int c) {
	//	m_A = a;
	//	m_B = b;
	//	m_C = c;
	//}

	//初始化列表方式初始化
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
	void PrintPerson() {
		cout << "mA:" << m_A << endl;
		cout << "mB:" << m_B << endl;
		cout << "mC:" << m_C << endl;
	}
private:
	int m_A;
	int m_B;
	int m_C;
};

int main() {

	Person p(1, 2, 3);
	p.PrintPerson();


	system("pause");

	return 0;
}
```





#### 4.2.7 类对象作为类成员



C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员



例如：

```C++
class A {}
class B
{
    A a；
}
```



B类中有对象A作为成员，A为对象成员



那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？



**示例：**

```C++
class Phone
{
public:
	Phone(string name)
	{
		m_PhoneName = name;
		cout << "Phone构造" << endl;
	}

	~Phone()
	{
		cout << "Phone析构" << endl;
	}

	string m_PhoneName;

};


class Person
{
public:

	//初始化列表可以告诉编译器调用哪一个构造函数
	Person(string name, string pName) :m_Name(name), m_Phone(pName)
	{
		cout << "Person构造" << endl;
	}

	~Person()
	{
		cout << "Person析构" << endl;
	}

	void playGame()
	{
		cout << m_Name << " 使用" << m_Phone.m_PhoneName << " 牌手机! " << endl;
	}

	string m_Name;
	Phone m_Phone;

};
void test01()
{
	//当类中成员是其他类对象时，我们称该成员为 对象成员
	//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
	//析构顺序与构造相反
	Person p("张三" , "苹果X");
	p.playGame();

}


int main() {

	test01();

	system("pause");

	return 0;
}
```











#### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：



*  静态成员变量
   *  所有对象共享同一份数据
   *  在编译阶段分配内存
   *  类内声明，类外初始化
*  静态成员函数
   *  所有对象共享同一个函数
   *  静态成员函数只能访问静态成员变量







**示例1 ：**静态成员变量

```C++
class Person
{
	
public:

	static int m_A; //静态成员变量

	//静态成员变量特点：
	//1 在编译阶段分配内存
	//2 类内声明，类外初始化
	//3 所有对象共享同一份数据

private:
	static int m_B; //静态成员变量也是有访问权限的
};
int Person::m_A = 10;
int Person::m_B = 10;

void test01()
{
	//静态成员变量两种访问方式

	//1、通过对象
	Person p1;
	p1.m_A = 100;
	cout << "p1.m_A = " << p1.m_A << endl;

	Person p2;
	p2.m_A = 200;
	cout << "p1.m_A = " << p1.m_A << endl; //共享同一份数据
	cout << "p2.m_A = " << p2.m_A << endl;

	//2、通过类名
	cout << "m_A = " << Person::m_A << endl;


	//cout << "m_B = " << Person::m_B << endl; //私有权限访问不到
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



**示例2：**静态成员函数

```C++
class Person
{

public:

	//静态成员函数特点：
	//1 程序共享一个函数
	//2 静态成员函数只能访问静态成员变量
	
	static void func()
	{
		cout << "func调用" << endl;
		m_A = 100;
		//m_B = 100; //错误，不可以访问非静态成员变量
	}

	static int m_A; //静态成员变量
	int m_B; // 
private:

	//静态成员函数也是有访问权限的
	static void func2()
	{
		cout << "func2调用" << endl;
	}
};
int Person::m_A = 10;


void test01()
{
	//静态成员变量两种访问方式

	//1、通过对象
	Person p1;
	p1.func();

	//2、通过类名
	Person::func();


	//Person::func2(); //私有权限访问不到
}

int main() {

	test01();

	system("pause");

	return 0;
}
```









### 4.3 C++对象模型和this指针



#### 4.3.1 成员变量和成员函数分开存储



在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上



```C++
class Person {
public:
	Person() {
		mA = 0;
	}
	//非静态成员变量占对象空间
	int mA;
	//静态成员变量不占对象空间
	static int mB; 
	//函数也不占对象空间，所有函数共享一个函数实例
	void func() {
		cout << "mA:" << this->mA << endl;
	}
	//静态成员函数也不占对象空间
	static void sfunc() {
	}
};

int main() {

	cout << sizeof(Person) << endl;

	system("pause");

	return 0;
}
```







#### 4.3.2 this指针概念

通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？



c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针的用途：

*  当形参和成员变量同名时，可用this指针来区分
*  在类的非静态成员函数中返回对象本身，可使用return *this

```C++
class Person
{
public:

	Person(int age)
	{
		//1、当形参和成员变量同名时，可用this指针来区分
		this->age = age;
	}

	Person& PersonAddPerson(Person p)
	{
		this->age += p.age;
		//返回对象本身
		return *this;
	}

	int age;
};

void test01()
{
	Person p1(10);
	cout << "p1.age = " << p1.age << endl;

	Person p2(10);
	p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
	cout << "p2.age = " << p2.age << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```









#### 4.3.3 空指针访问成员函数



C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针



如果用到this指针，需要加以判断保证代码的健壮性



**示例：**

```C++
//空指针访问成员函数
class Person {
public:

	void ShowClassName() {
		cout << "我是Person类!" << endl;
	}

	void ShowPerson() {
		if (this == NULL) {
			return;
		}
		cout << mAge << endl;
	}

public:
	int mAge;
};

void test01()
{
	Person * p = NULL;
	p->ShowClassName(); //空指针，可以调用成员函数
	p->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了
}

int main() {

	test01();

	system("pause");

	return 0;
}
```









#### 4.3.4 const修饰成员函数



**常函数：**

* 成员函数后加const后我们称为这个函数为**常函数**
* 常函数内不可以修改成员属性
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改



**常对象：**

* 声明对象前加const称该对象为常对象
* 常对象只能调用常函数







**示例：**

```C++
class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}

	//this指针的本质是一个指针常量，指针的指向不可修改
	//如果想让指针指向的值也不可以修改，需要声明常函数
	void ShowPerson() const {
		//const Type* const pointer;
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this->mA = 100; //但是this指针指向的对象的数据是可以修改的

		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this->m_B = 100;
	}

	void MyFunc() const {
		//mA = 10000;
	}

public:
	int m_A;
	mutable int m_B; //可修改 可变的
};


//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout << person.m_A << endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象不能调用const的函数

}

int main() {

	test01();

	system("pause");

	return 0;
}
```








### 4.4 友元



生活中你的家有客厅(Public)，有你的卧室(Private)

客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去

但是呢，你也可以允许你的好闺蜜好基友进去。



在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术



友元的目的就是让一个函数或者类 访问另一个类中私有成员



友元的关键字为  ==friend==



友元的三种实现

* 全局函数做友元
* 类做友元
* 成员函数做友元





#### 4.4.1 全局函数做友元

```C++
class Building
{
	//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容
	friend void goodGay(Building * building);

public:

	Building()
	{
		this->m_SittingRoom = "客厅";
		this->m_BedRoom = "卧室";
	}


public:
	string m_SittingRoom; //客厅

private:
	string m_BedRoom; //卧室
};


void goodGay(Building * building)
{
	cout << "好基友正在访问： " << building->m_SittingRoom << endl;
	cout << "好基友正在访问： " << building->m_BedRoom << endl;
}


void test01()
{
	Building b;
	goodGay(&b);
}

int main(){

	test01();

	system("pause");
	return 0;
}
```



#### 4.4.2 类做友元



```C++
class Building;
class goodGay
{
public:

	goodGay();
	void visit();

private:
	Building *building;
};


class Building
{
	//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容
	friend class goodGay;

public:
	Building();

public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this->m_SittingRoom = "客厅";
	this->m_BedRoom = "卧室";
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void test01()
{
	goodGay gg;
	gg.visit();

}

int main(){

	test01();

	system("pause");
	return 0;
}
```





#### 4.4.3 成员函数做友元



```C++
class Building;
class goodGay
{
public:

	goodGay();
	void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容
	void visit2(); 

private:
	Building *building;
};


class Building
{
	//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容
	friend void goodGay::visit();

public:
	Building();

public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this->m_SittingRoom = "客厅";
	this->m_BedRoom = "卧室";
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void goodGay::visit2()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	//cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void test01()
{
	goodGay  gg;
	gg.visit();

}

int main(){
    
	test01();

	system("pause");
	return 0;
}
```









### 4.5 运算符重载



运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型



#### 4.5.1 加号运算符重载



作用：实现两个自定义数据类型相加的运算



```C++
class Person {
public:
	Person() {};
	Person(int a, int b)
	{
		this->m_A = a;
		this->m_B = b;
	}
	//成员函数实现 + 号运算符重载
	Person operator+(const Person& p) {
		Person temp;
		temp.m_A = this->m_A + p.m_A;
		temp.m_B = this->m_B + p.m_B;
		return temp;
	}


public:
	int m_A;
	int m_B;
};

//全局函数实现 + 号运算符重载
//Person operator+(const Person& p1, const Person& p2) {
//	Person temp(0, 0);
//	temp.m_A = p1.m_A + p2.m_A;
//	temp.m_B = p1.m_B + p2.m_B;
//	return temp;
//}

//运算符重载 可以发生函数重载 
Person operator+(const Person& p2, int val)  
{
	Person temp;
	temp.m_A = p2.m_A + val;
	temp.m_B = p2.m_B + val;
	return temp;
}

void test() {

	Person p1(10, 10);
	Person p2(20, 20);

	//成员函数方式
	Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)
	cout << "mA:" << p3.m_A << " mB:" << p3.m_B << endl;


	Person p4 = p3 + 10; //相当于 operator+(p3,10)
	cout << "mA:" << p4.m_A << " mB:" << p4.m_B << endl;

}

int main() {

	test();

	system("pause");

	return 0;
}
```



> 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的

> 总结2：不要滥用运算符重载







#### 4.5.2 左移运算符重载



作用：可以输出自定义数据类型



```C++
class Person {
	friend ostream& operator<<(ostream& out, Person& p);

public:

	Person(int a, int b)
	{
		this->m_A = a;
		this->m_B = b;
	}

	//成员函数 实现不了  p << cout 不是我们想要的效果
	//void operator<<(Person& p){
	//}

private:
	int m_A;
	int m_B;
};

//全局函数实现左移重载
//ostream对象只能有一个
ostream& operator<<(ostream& out, Person& p) {
	out << "a:" << p.m_A << " b:" << p.m_B;
	return out;
}

void test() {

	Person p1(10, 20);

	cout << p1 << "hello world" << endl; //链式编程
}

int main() {

	test();

	system("pause");

	return 0;
}
```



> 总结：重载左移运算符配合友元可以实现输出自定义数据类型













#### 4.5.3 递增运算符重载



作用： 通过重载递增运算符，实现自己的整型数据



```C++
class MyInteger {

	friend ostream& operator<<(ostream& out, MyInteger myint);

public:
	MyInteger() {
		m_Num = 0;
	}
	//前置++
	MyInteger& operator++() {
		//先++
		m_Num++;
		//再返回
		return *this;
	}

	//后置++
	MyInteger operator++(int) {
		//先返回
		MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；
		m_Num++;
		return temp;
	}

private:
	int m_Num;
};


ostream& operator<<(ostream& out, MyInteger myint) {
	out << myint.m_Num;
	return out;
}


//前置++ 先++ 再返回
void test01() {
	MyInteger myInt;
	cout << ++myInt << endl;
	cout << myInt << endl;
}

//后置++ 先返回 再++
void test02() {

	MyInteger myInt;
	cout << myInt++ << endl;
	cout << myInt << endl;
}

int main() {

	test01();
	//test02();

	system("pause");

	return 0;
}
```



> 总结： 前置递增返回引用，后置递增返回值













#### 4.5.4 赋值运算符重载



c++编译器至少给一个类添加4个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符 operator=, 对属性进行值拷贝





如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题





**示例：**

```C++
class Person
{
public:

	Person(int age)
	{
		//将年龄数据开辟到堆区
		m_Age = new int(age);
	}

	//重载赋值运算符 
	Person& operator=(Person &p)
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
		//编译器提供的代码是浅拷贝
		//m_Age = p.m_Age;

		//提供深拷贝 解决浅拷贝的问题
		m_Age = new int(*p.m_Age);

		//返回自身
		return *this;
	}


	~Person()
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}

	//年龄的指针
	int *m_Age;

};


void test01()
{
	Person p1(18);

	Person p2(20);

	Person p3(30);

	p3 = p2 = p1; //赋值操作

	cout << "p1的年龄为：" << *p1.m_Age << endl;

	cout << "p2的年龄为：" << *p2.m_Age << endl;

	cout << "p3的年龄为：" << *p3.m_Age << endl;
}

int main() {

	test01();

	//int a = 10;
	//int b = 20;
	//int c = 30;

	//c = b = a;
	//cout << "a = " << a << endl;
	//cout << "b = " << b << endl;
	//cout << "c = " << c << endl;

	system("pause");

	return 0;
}
```









#### 4.5.5 关系运算符重载



**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作



**示例：**

```C++
class Person
{
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	};

	bool operator==(Person & p)
	{
		if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator!=(Person & p)
	{
		if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	string m_Name;
	int m_Age;
};

void test01()
{
	//int a = 0;
	//int b = 0;

	Person a("孙悟空", 18);
	Person b("孙悟空", 18);

	if (a == b)
	{
		cout << "a和b相等" << endl;
	}
	else
	{
		cout << "a和b不相等" << endl;
	}

	if (a != b)
	{
		cout << "a和b不相等" << endl;
	}
	else
	{
		cout << "a和b相等" << endl;
	}
}


int main() {

	test01();

	system("pause");

	return 0;
}
```





#### 4.5.6 函数调用运算符重载



* 函数调用运算符 ()  也可以重载
* 由于重载后使用的方式非常像函数的调用，因此称为仿函数
* 仿函数没有固定写法，非常灵活



**示例：**

```C++
class MyPrint
{
public:
	void operator()(string text)
	{
		cout << text << endl;
	}

};
void test01()
{
	//重载的（）操作符 也称为仿函数
	MyPrint myFunc;
	myFunc("hello world");
}


class MyAdd
{
public:
	int operator()(int v1, int v2)
	{
		return v1 + v2;
	}
};

void test02()
{
	MyAdd add;
	int ret = add(10, 10);
	cout << "ret = " << ret << endl;

	//匿名对象调用  
	cout << "MyAdd()(100,100) = " << MyAdd()(100, 100) << endl;
}

int main() {

	test01();
	test02();

	system("pause");

	return 0;
}
```









### 4.6  继承

**继承是面向对象三大特性之一**

有些类与类之间存在特殊的关系，例如下图中：

![1544861202252](assets/1544861202252.png)

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。

这个时候我们就可以考虑利用继承的技术，减少重复代码



#### 4.6.1 继承的基本语法



例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同

接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处



**普通实现：**

```C++
//Java页面
class Java 
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "JAVA学科视频" << endl;
	}
};
//Python页面
class Python
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};
//C++页面
class CPP 
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "C++学科视频" << endl;
	}
};

void test01()
{
	//Java页面
	cout << "Java下载视频页面如下： " << endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout << "--------------------" << endl;

	//Python页面
	cout << "Python下载视频页面如下： " << endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout << "--------------------" << endl;

	//C++页面
	cout << "C++下载视频页面如下： " << endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();

}

int main() {

	test01();

	system("pause");

	return 0;
}
```



**继承实现：**

```C++
//公共页面
class BasePage
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}

	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}

};

//Java页面
class Java : public BasePage
{
public:
	void content()
	{
		cout << "JAVA学科视频" << endl;
	}
};
//Python页面
class Python : public BasePage
{
public:
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};
//C++页面
class CPP : public BasePage
{
public:
	void content()
	{
		cout << "C++学科视频" << endl;
	}
};

void test01()
{
	//Java页面
	cout << "Java下载视频页面如下： " << endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout << "--------------------" << endl;

	//Python页面
	cout << "Python下载视频页面如下： " << endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout << "--------------------" << endl;

	//C++页面
	cout << "C++下载视频页面如下： " << endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();


}

int main() {

	test01();

	system("pause");

	return 0;
}
```



**总结：**

继承的好处：==可以减少重复的代码==

class A : public B; 

A 类称为子类 或 派生类

B 类称为父类 或 基类



**派生类中的成员，包含两大部分**：

一类是从基类继承过来的，一类是自己增加的成员。

从基类继承过过来的表现其共性，而新增的成员体现了其个性。









#### 4.6.2 继承方式



继承的语法：`class 子类 : 继承方式  父类`



**继承方式一共有三种：**

* 公共继承
* 保护继承
* 私有继承





![img](assets/clip_image002.png)





**示例：**

```C++
class Base1
{
public: 
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};

//公共继承
class Son1 :public Base1
{
public:
	void func()
	{
		m_A; //可访问 public权限
		m_B; //可访问 protected权限
		//m_C; //不可访问
	}
};

void myClass()
{
	Son1 s1;
	s1.m_A; //其他类只能访问到公共权限
}

//保护继承
class Base2
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};
class Son2:protected Base2
{
public:
	void func()
	{
		m_A; //可访问 protected权限
		m_B; //可访问 protected权限
		//m_C; //不可访问
	}
};
void myClass2()
{
	Son2 s;
	//s.m_A; //不可访问
}

//私有继承
class Base3
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};
class Son3:private Base3
{
public:
	void func()
	{
		m_A; //可访问 private权限
		m_B; //可访问 private权限
		//m_C; //不可访问
	}
};
class GrandSon3 :public Son3
{
public:
	void func()
	{
		//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到
		//m_A;
		//m_B;
		//m_C;
	}
};
```









#### 4.6.3 继承中的对象模型



**问题：**从父类继承过来的成员，哪些属于子类对象中？



**示例：**

```C++
class Base
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C; //私有成员只是被隐藏了，但是还是会继承下去
};

//公共继承
class Son :public Base
{
public:
	int m_D;
};

void test01()
{
	cout << "sizeof Son = " << sizeof(Son) << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```





利用工具查看：



![1545881904150](assets/1545881904150.png)



打开工具窗口后，定位到当前CPP文件的盘符

然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名



效果如下图：



![1545882158050](assets/1545882158050.png)



> 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到



















#### 4.6.4 继承中构造和析构顺序



子类继承父类后，当创建子类对象，也会调用父类的构造函数



问题：父类和子类的构造和析构顺序是谁先谁后？



**示例：**

```C++
class Base 
{
public:
	Base()
	{
		cout << "Base构造函数!" << endl;
	}
	~Base()
	{
		cout << "Base析构函数!" << endl;
	}
};

class Son : public Base
{
public:
	Son()
	{
		cout << "Son构造函数!" << endl;
	}
	~Son()
	{
		cout << "Son析构函数!" << endl;
	}

};


void test01()
{
	//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反
	Son s;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



> 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反











#### 4.6.5 继承同名成员处理方式



问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？



* 访问子类同名成员   直接访问即可
* 访问父类同名成员   需要加作用域



**示例：**

```C++
class Base {
public:
	Base()
	{
		m_A = 100;
	}

	void func()
	{
		cout << "Base - func()调用" << endl;
	}

	void func(int a)
	{
		cout << "Base - func(int a)调用" << endl;
	}

public:
	int m_A;
};


class Son : public Base {
public:
	Son()
	{
		m_A = 200;
	}

	//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数
	//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域
	void func()
	{
		cout << "Son - func()调用" << endl;
	}
public:
	int m_A;
};

void test01()
{
	Son s;

	cout << "Son下的m_A = " << s.m_A << endl;
	cout << "Base下的m_A = " << s.Base::m_A << endl;

	s.func();
	s.Base::func();
	s.Base::func(10);

}
int main() {

	test01();

	system("pause");
	return EXIT_SUCCESS;
}
```

总结：

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数













#### 4.6.6 继承同名静态成员处理方式



问题：继承中同名的静态成员在子类对象上如何进行访问？



静态成员和非静态成员出现同名，处理方式一致



- 访问子类同名成员   直接访问即可
- 访问父类同名成员   需要加作用域



**示例：**

```C++
class Base {
public:
	static void func()
	{
		cout << "Base - static void func()" << endl;
	}
	static void func(int a)
	{
		cout << "Base - static void func(int a)" << endl;
	}

	static int m_A;
};

int Base::m_A = 100;

class Son : public Base {
public:
	static void func()
	{
		cout << "Son - static void func()" << endl;
	}
	static int m_A;
};

int Son::m_A = 200;

//同名成员属性
void test01()
{
	//通过对象访问
	cout << "通过对象访问： " << endl;
	Son s;
	cout << "Son  下 m_A = " << s.m_A << endl;
	cout << "Base 下 m_A = " << s.Base::m_A << endl;

	//通过类名访问
	cout << "通过类名访问： " << endl;
	cout << "Son  下 m_A = " << Son::m_A << endl;
	cout << "Base 下 m_A = " << Son::Base::m_A << endl;
}

//同名成员函数
void test02()
{
	//通过对象访问
	cout << "通过对象访问： " << endl;
	Son s;
	s.func();
	s.Base::func();

	cout << "通过类名访问： " << endl;
	Son::func();
	Son::Base::func();
	//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问
	Son::Base::func(100);
}
int main() {

	//test01();
	test02();

	system("pause");

	return 0;
}
```

> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）













#### 4.6.7 多继承语法



C++允许**一个类继承多个类**



语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...`



多继承可能会引发父类中有同名成员出现，需要加作用域区分



**C++实际开发中不建议用多继承**







**示例：**

```C++
class Base1 {
public:
	Base1()
	{
		m_A = 100;
	}
public:
	int m_A;
};

class Base2 {
public:
	Base2()
	{
		m_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确
	}
public:
	int m_A;
};

//语法：class 子类：继承方式 父类1 ，继承方式 父类2 
class Son : public Base2, public Base1 
{
public:
	Son()
	{
		m_C = 300;
		m_D = 400;
	}
public:
	int m_C;
	int m_D;
};


//多继承容易产生成员同名的情况
//通过使用类名作用域可以区分调用哪一个基类的成员
void test01()
{
	Son s;
	cout << "sizeof Son = " << sizeof(s) << endl;
	cout << s.Base1::m_A << endl;
	cout << s.Base2::m_A << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



> 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域











#### 4.6.8 菱形继承



**菱形继承概念：**

​	两个派生类继承同一个基类

​	又有某个类同时继承者两个派生类

​	这种继承被称为菱形继承，或者钻石继承



**典型的菱形继承案例：**



![IMG_256](assets/clip_image002.jpg)



**菱形继承问题：**



1.     羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。

2.     草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。



**示例：**

```C++
class Animal
{
public:
	int m_Age;
};

//继承前加virtual关键字后，变为虚继承
//此时公共的父类Animal称为虚基类
class Sheep : virtual public Animal {};
class Tuo   : virtual public Animal {};
class SheepTuo : public Sheep, public Tuo {};

void test01()
{
	SheepTuo st;
	st.Sheep::m_Age = 100;
	st.Tuo::m_Age = 200;

	cout << "st.Sheep::m_Age = " << st.Sheep::m_Age << endl;
	cout << "st.Tuo::m_Age = " <<  st.Tuo::m_Age << endl;
	cout << "st.m_Age = " << st.m_Age << endl;
}


int main() {

	test01();

	system("pause");

	return 0;
}
```



总结：

* 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
* 利用虚继承可以解决菱形继承问题



















### 4.7  多态

#### 4.7.1 多态的基本概念



**多态是C++面向对象三大特性之一**

多态分为两类

* 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名
* 动态多态: 派生类和虚函数实现运行时多态



静态多态和动态多态区别：

* 静态多态的函数地址早绑定  -  编译阶段确定函数地址
* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址



下面通过案例进行讲解多态



```C++
class Animal
{
public:
	//Speak函数就是虚函数
	//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。
	virtual void speak()
	{
		cout << "动物在说话" << endl;
	}
};

class Cat :public Animal
{
public:
	void speak()
	{
		cout << "小猫在说话" << endl;
	}
};

class Dog :public Animal
{
public:

	void speak()
	{
		cout << "小狗在说话" << endl;
	}

};
//我们希望传入什么对象，那么就调用什么对象的函数
//如果函数地址在编译阶段就能确定，那么静态联编
//如果函数地址在运行阶段才能确定，就是动态联编

void DoSpeak(Animal & animal)
{
	animal.speak();
}
//
//多态满足条件： 
//1、有继承关系
//2、子类重写父类中的虚函数
//多态使用：
//父类指针或引用指向子类对象

void test01()
{
	Cat cat;
	DoSpeak(cat);


	Dog dog;
	DoSpeak(dog);
}


int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

多态满足条件

* 有继承关系
* 子类重写父类中的虚函数

多态使用条件

* 父类指针或引用指向子类对象

重写：函数返回值类型  函数名 参数列表 完全一致称为重写









#### 4.7.2 多态案例一-计算器类



案例描述：

分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类



多态的优点：

* 代码组织结构清晰
* 可读性强
* 利于前期和后期的扩展以及维护



**示例：**

```C++
//普通实现
class Calculator {
public:
	int getResult(string oper)
	{
		if (oper == "+") {
			return m_Num1 + m_Num2;
		}
		else if (oper == "-") {
			return m_Num1 - m_Num2;
		}
		else if (oper == "*") {
			return m_Num1 * m_Num2;
		}
		//如果要提供新的运算，需要修改源码
	}
public:
	int m_Num1;
	int m_Num2;
};

void test01()
{
	//普通实现测试
	Calculator c;
	c.m_Num1 = 10;
	c.m_Num2 = 10;
	cout << c.m_Num1 << " + " << c.m_Num2 << " = " << c.getResult("+") << endl;

	cout << c.m_Num1 << " - " << c.m_Num2 << " = " << c.getResult("-") << endl;

	cout << c.m_Num1 << " * " << c.m_Num2 << " = " << c.getResult("*") << endl;
}



//多态实现
//抽象计算器类
//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护
class AbstractCalculator
{
public :

	virtual int getResult()
	{
		return 0;
	}

	int m_Num1;
	int m_Num2;
};

//加法计算器
class AddCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 + m_Num2;
	}
};

//减法计算器
class SubCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 - m_Num2;
	}
};

//乘法计算器
class MulCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return m_Num1 * m_Num2;
	}
};


void test02()
{
	//创建加法计算器
	AbstractCalculator *abc = new AddCalculator;
	abc->m_Num1 = 10;
	abc->m_Num2 = 10;
	cout << abc->m_Num1 << " + " << abc->m_Num2 << " = " << abc->getResult() << endl;
	delete abc;  //用完了记得销毁

	//创建减法计算器
	abc = new SubCalculator;
	abc->m_Num1 = 10;
	abc->m_Num2 = 10;
	cout << abc->m_Num1 << " - " << abc->m_Num2 << " = " << abc->getResult() << endl;
	delete abc;  

	//创建乘法计算器
	abc = new MulCalculator;
	abc->m_Num1 = 10;
	abc->m_Num2 = 10;
	cout << abc->m_Num1 << " * " << abc->m_Num2 << " = " << abc->getResult() << endl;
	delete abc;
}

int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

> 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多

















#### 4.7.3 纯虚函数和抽象类



在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容



因此可以将虚函数改为**纯虚函数**



纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`



当类中有了纯虚函数，这个类也称为==抽象类==



**抽象类特点**：

 * 无法实例化对象
 * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类





**示例：**

```C++
class Base
{
public:
	//纯虚函数
	//类中只要有一个纯虚函数就称为抽象类
	//抽象类无法实例化对象
	//子类必须重写父类中的纯虚函数，否则也属于抽象类
	virtual void func() = 0;
};

class Son :public Base
{
public:
	virtual void func() 
	{
		cout << "func调用" << endl;
	};
};

void test01()
{
	Base * base = NULL;
	//base = new Base; // 错误，抽象类无法实例化对象
	base = new Son;
	base->func();
	delete base;//记得销毁
}

int main() {

	test01();

	system("pause");

	return 0;
}
```















#### 4.7.4 多态案例二-制作饮品

**案例描述：**

制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料



利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶



![1545985945198](assets/1545985945198.png)



**示例：**

```C++
//抽象制作饮品
class AbstractDrinking {
public:
	//烧水
	virtual void Boil() = 0;
	//冲泡
	virtual void Brew() = 0;
	//倒入杯中
	virtual void PourInCup() = 0;
	//加入辅料
	virtual void PutSomething() = 0;
	//规定流程
	void MakeDrink() {
		Boil();
		Brew();
		PourInCup();
		PutSomething();
	}
};

//制作咖啡
class Coffee : public AbstractDrinking {
public:
	//烧水
	virtual void Boil() {
		cout << "煮农夫山泉!" << endl;
	}
	//冲泡
	virtual void Brew() {
		cout << "冲泡咖啡!" << endl;
	}
	//倒入杯中
	virtual void PourInCup() {
		cout << "将咖啡倒入杯中!" << endl;
	}
	//加入辅料
	virtual void PutSomething() {
		cout << "加入牛奶!" << endl;
	}
};

//制作茶水
class Tea : public AbstractDrinking {
public:
	//烧水
	virtual void Boil() {
		cout << "煮自来水!" << endl;
	}
	//冲泡
	virtual void Brew() {
		cout << "冲泡茶叶!" << endl;
	}
	//倒入杯中
	virtual void PourInCup() {
		cout << "将茶水倒入杯中!" << endl;
	}
	//加入辅料
	virtual void PutSomething() {
		cout << "加入枸杞!" << endl;
	}
};

//业务函数
void DoWork(AbstractDrinking* drink) {
	drink->MakeDrink();
	delete drink;
}

void test01() {
	DoWork(new Coffee);
	cout << "--------------" << endl;
	DoWork(new Tea);
}


int main() {

	test01();

	system("pause");

	return 0;
}
```



















#### 4.7.5 虚析构和纯虚析构



多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码



解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**



虚析构和纯虚析构共性：

* 可以解决父类指针释放子类对象
* 都需要有具体的函数实现

虚析构和纯虚析构区别：

* 如果是纯虚析构，该类属于抽象类，无法实例化对象



虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：

` virtual ~类名() = 0;`

`类名::~类名(){}`



**示例：**

```C++
class Animal {
public:

	Animal()
	{
		cout << "Animal 构造函数调用！" << endl;
	}
	virtual void Speak() = 0;

	//析构函数加上virtual关键字，变成虚析构函数
	//virtual ~Animal()
	//{
	//	cout << "Animal虚析构函数调用！" << endl;
	//}


	virtual ~Animal() = 0;
};

Animal::~Animal()
{
	cout << "Animal 纯虚析构函数调用！" << endl;
}

//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。

class Cat : public Animal {
public:
	Cat(string name)
	{
		cout << "Cat构造函数调用！" << endl;
		m_Name = new string(name);
	}
	virtual void Speak()
	{
		cout << *m_Name <<  "小猫在说话!" << endl;
	}
	~Cat()
	{
		cout << "Cat析构函数调用!" << endl;
		if (this->m_Name != NULL) {
			delete m_Name;
			m_Name = NULL;
		}
	}

public:
	string *m_Name;
};

void test01()
{
	Animal *animal = new Cat("Tom");
	animal->Speak();

	//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏
	//怎么解决？给基类增加一个虚析构函数
	//虚析构函数就是用来解决通过父类指针释放子类对象
	delete animal;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



总结：

​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象

​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构

​	3. 拥有纯虚析构函数的类也属于抽象类















#### 4.7.6 多态案例三-电脑组装



**案例描述：**



电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）

将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商

创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口

测试时组装三台不同的电脑进行工作





**示例：**

```C++
#include<iostream>
using namespace std;

//抽象CPU类
class CPU
{
public:
	//抽象的计算函数
	virtual void calculate() = 0;
};

//抽象显卡类
class VideoCard
{
public:
	//抽象的显示函数
	virtual void display() = 0;
};

//抽象内存条类
class Memory
{
public:
	//抽象的存储函数
	virtual void storage() = 0;
};

//电脑类
class Computer
{
public:
	Computer(CPU * cpu, VideoCard * vc, Memory * mem)
	{
		m_cpu = cpu;
		m_vc = vc;
		m_mem = mem;
	}

	//提供工作的函数
	void work()
	{
		//让零件工作起来，调用接口
		m_cpu->calculate();

		m_vc->display();

		m_mem->storage();
	}

	//提供析构函数 释放3个电脑零件
	~Computer()
	{

		//释放CPU零件
		if (m_cpu != NULL)
		{
			delete m_cpu;
			m_cpu = NULL;
		}

		//释放显卡零件
		if (m_vc != NULL)
		{
			delete m_vc;
			m_vc = NULL;
		}

		//释放内存条零件
		if (m_mem != NULL)
		{
			delete m_mem;
			m_mem = NULL;
		}
	}

private:

	CPU * m_cpu; //CPU的零件指针
	VideoCard * m_vc; //显卡零件指针
	Memory * m_mem; //内存条零件指针
};

//具体厂商
//Intel厂商
class IntelCPU :public CPU
{
public:
	virtual void calculate()
	{
		cout << "Intel的CPU开始计算了！" << endl;
	}
};

class IntelVideoCard :public VideoCard
{
public:
	virtual void display()
	{
		cout << "Intel的显卡开始显示了！" << endl;
	}
};

class IntelMemory :public Memory
{
public:
	virtual void storage()
	{
		cout << "Intel的内存条开始存储了！" << endl;
	}
};

//Lenovo厂商
class LenovoCPU :public CPU
{
public:
	virtual void calculate()
	{
		cout << "Lenovo的CPU开始计算了！" << endl;
	}
};

class LenovoVideoCard :public VideoCard
{
public:
	virtual void display()
	{
		cout << "Lenovo的显卡开始显示了！" << endl;
	}
};

class LenovoMemory :public Memory
{
public:
	virtual void storage()
	{
		cout << "Lenovo的内存条开始存储了！" << endl;
	}
};


void test01()
{
	//第一台电脑零件
	CPU * intelCpu = new IntelCPU;
	VideoCard * intelCard = new IntelVideoCard;
	Memory * intelMem = new IntelMemory;

	cout << "第一台电脑开始工作：" << endl;
	//创建第一台电脑
	Computer * computer1 = new Computer(intelCpu, intelCard, intelMem);
	computer1->work();
	delete computer1;

	cout << "-----------------------" << endl;
	cout << "第二台电脑开始工作：" << endl;
	//第二台电脑组装
	Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;
	computer2->work();
	delete computer2;

	cout << "-----------------------" << endl;
	cout << "第三台电脑开始工作：" << endl;
	//第三台电脑组装
	Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;
	computer3->work();
	delete computer3;

}
```













## 5 文件操作



程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

通过**文件可以将数据持久化**

C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==



文件类型分为两种：

1. **文本文件**     -  文件以文本的**ASCII码**形式存储在计算机中
2. **二进制文件** -  文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们



操作文件的三大类:

1. ofstream：写操作
2. ifstream： 读操作
3. fstream ： 读写操作



### 5.1文本文件

#### 5.1.1写文件

   写文件步骤如下：

1. 包含头文件   

   \#include <fstream\>

2. 创建流对象  

   ofstream ofs;

3. 打开文件

   ofs.open("文件路径",打开方式);

4. 写数据

   ofs << "写入的数据";

5. 关闭文件

   ofs.close();

   

文件打开方式：

| 打开方式    | 解释                       |
| ----------- | -------------------------- |
| ios::in     | 为读文件而打开文件         |
| ios::out    | 为写文件而打开文件         |
| ios::ate    | 初始位置：文件尾           |
| ios::app    | 追加方式写文件             |
| ios::trunc  | 如果文件存在先删除，再创建 |
| ios::binary | 二进制方式                 |

**注意：** 文件打开方式可以配合使用，利用|操作符

**例如：**用二进制方式写文件 `ios::binary |  ios:: out`





**示例：**

```C++
#include <fstream>

void test01()
{
	ofstream ofs;
	ofs.open("test.txt", ios::out);

	ofs << "姓名：张三" << endl;
	ofs << "性别：男" << endl;
	ofs << "年龄：18" << endl;

	ofs.close();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 文件操作必须包含头文件 fstream
* 读文件可以利用 ofstream  ，或者fstream类
* 打开文件时候需要指定操作文件的路径，以及打开方式
* 利用<<可以向文件中写数据
* 操作完毕，要关闭文件

















#### 5.1.2读文件



读文件与写文件步骤相似，但是读取方式相对于比较多



读文件步骤如下：

1. 包含头文件   

   \#include <fstream\>

2. 创建流对象  

   ifstream ifs;

3. 打开文件并判断文件是否打开成功

   ifs.open("文件路径",打开方式);

4. 读数据

   四种方式读取

5. 关闭文件

   ifs.close();



**示例：**

```C++
#include <fstream>
#include <string>
void test01()
{
	ifstream ifs;
	ifs.open("test.txt", ios::in);

	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}

	//第一种方式
	//char buf[1024] = { 0 };
	//while (ifs >> buf)
	//{
	//	cout << buf << endl;
	//}

	//第二种
	//char buf[1024] = { 0 };
	//while (ifs.getline(buf,sizeof(buf)))
	//{
	//	cout << buf << endl;
	//}

	//第三种
	//string buf;
	//while (getline(ifs, buf))
	//{
	//	cout << buf << endl;
	//}

	char c;
	while ((c = ifs.get()) != EOF)
	{
		cout << c;
	}

	ifs.close();


}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

- 读文件可以利用 ifstream  ，或者fstream类
- 利用is_open函数可以判断文件是否打开成功
- close 关闭文件 















### 5.2 二进制文件

以二进制的方式对文件进行读写操作

打开方式要指定为 ==ios::binary==



#### 5.2.1 写文件

二进制方式写文件主要利用流对象调用成员函数write

函数原型 ：`ostream& write(const char * buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数



**示例：**

```C++
#include <fstream>
#include <string>

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

//二进制文件  写文件
void test01()
{
	//1、包含头文件

	//2、创建输出流对象
	ofstream ofs("person.txt", ios::out | ios::binary);
	
	//3、打开文件
	//ofs.open("person.txt", ios::out | ios::binary);

	Person p = {"张三"  , 18};

	//4、写文件
	ofs.write((const char *)&p, sizeof(p));

	//5、关闭文件
	ofs.close();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 文件输出流对象 可以通过write函数，以二进制方式写数据











#### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员函数read

函数原型：`istream& read(char *buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数

示例：

```C++
#include <fstream>
#include <string>

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

void test01()
{
	ifstream ifs("person.txt", ios::in | ios::binary);
	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
	}

	Person p;
	ifs.read((char *)&p, sizeof(p));

	cout << "姓名： " << p.m_Name << " 年龄： " << p.m_Age << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



- 文件输入流对象 可以通过read函数，以二进制方式读数据

  



# C++提高编程

## 1 模板

### 1.1 模板的概念



模板就是建立**通用的模具**，大大**提高复用性**



例如生活中的模板



一寸照片模板：



![1547105026929](C:/Users/mm611/Desktop/C++/讲义/assets/1547105026929.png)



PPT模板：

![1547103297864](C:/Users/mm611/Desktop/C++/讲义/assets/1547103297864.png)



![1547103359158](C:/Users/mm611/Desktop/C++/讲义/assets/1547103359158.png)





模板的特点：

* 模板不可以直接使用，它只是一个框架
* 模板的通用并不是万能的









### 1.2 函数模板



* C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板


* C++提供两种模板机制:**函数模板**和**类模板** 



#### 1.2.1 函数模板语法

函数模板作用：

建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。



**语法：** 

```C++
template<typename T>
函数声明或定义
```

**解释：**

template  ---  声明创建模板

typename  --- 表面其后面的符号是一种数据类型，可以用class代替

T    ---   通用的数据类型，名称可以替换，通常为大写字母



**示例：**

```C++
//交换整型函数
void swapInt(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}

//交换浮点型函数
void swapDouble(double& a, double& b) {
	double temp = a;
	a = b;
	b = temp;
}

//利用模板提供通用的交换函数
template<typename T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

void test01()
{
	int a = 10;
	int b = 20;
	
	//swapInt(a, b);

	//利用模板实现交换
	//1、自动类型推导
	mySwap(a, b);

	//2、显示指定类型
	mySwap<int>(a, b);

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 函数模板利用关键字 template
* 使用函数模板有两种方式：自动类型推导、显示指定类型
* 模板的目的是为了提高复用性，将类型参数化









#### 1.2.2 函数模板注意事项

注意事项：

* 自动类型推导，必须推导出一致的数据类型T,才可以使用


* 模板必须要确定出T的数据类型，才可以使用



**示例：**

```C++
//利用模板提供通用的交换函数
template<class T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}


// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';

	mySwap(a, b); // 正确，可以推导出一致的T
	//mySwap(a, c); // 错误，推导不出一致的T类型
}


// 2、模板必须要确定出T的数据类型，才可以使用
template<class T>
void func()
{
	cout << "func 调用" << endl;
}

void test02()
{
	//func(); //错误，模板不能独立使用，必须确定出T的类型
	func<int>(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板
}

int main() {

	test01();
	test02();

	system("pause");

	return 0;
}
```

总结：

* 使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型











#### 1.2.3 函数模板案例

案例描述：

* 利用函数模板封装一个排序的函数，可以对**不同数据类型数组**进行排序
* 排序规则从大到小，排序算法为**选择排序**
* 分别利用**char数组**和**int数组**进行测试



示例：

```C++
//交换的函数模板
template<typename T>
void mySwap(T &a, T&b)
{
	T temp = a;
	a = b;
	b = temp;
}


template<class T> // 也可以替换成typename
//利用选择排序，进行对数组从大到小的排序
void mySort(T arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		int max = i; //最大数的下标
		for (int j = i + 1; j < len; j++)
		{
			if (arr[max] < arr[j])
			{
				max = j;
			}
		}
		if (max != i) //如果最大数的下标不是i，交换两者
		{
			mySwap(arr[max], arr[i]);
		}
	}
}
template<typename T>
void printArray(T arr[], int len) {

	for (int i = 0; i < len; i++) {
		cout << arr[i] << " ";
	}
	cout << endl;
}
void test01()
{
	//测试char数组
	char charArr[] = "bdcfeagh";
	int num = sizeof(charArr) / sizeof(char);
	mySort(charArr, num);
	printArray(charArr, num);
}

void test02()
{
	//测试int数组
	int intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 };
	int num = sizeof(intArr) / sizeof(int);
	mySort(intArr, num);
	printArray(intArr, num);
}

int main() {

	test01();
	test02();

	system("pause");

	return 0;
}
```

总结：模板可以提高代码复用，需要熟练掌握











#### 1.2.4 普通函数与函数模板的区别



**普通函数与函数模板区别：**

* 普通函数调用时可以发生自动类型转换（隐式类型转换）
* 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
* 如果利用显示指定类型的方式，可以发生隐式类型转换



**示例：**

```C++
//普通函数
int myAdd01(int a, int b)
{
	return a + b;
}

//函数模板
template<class T>
T myAdd02(T a, T b)  
{
	return a + b;
}

//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';
	
	cout << myAdd01(a, c) << endl; //正确，将char类型的'c'隐式转换为int类型  'c' 对应 ASCII码 99

	//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换

	myAdd02<int>(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T











#### 1.2.5 普通函数与函数模板的调用规则



调用规则如下：

1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配,优先调用函数模板





**示例：**

```C++
//普通函数与函数模板调用规则
void myPrint(int a, int b)
{
	cout << "调用的普通函数" << endl;
}

template<typename T>
void myPrint(T a, T b) 
{ 
	cout << "调用的模板" << endl;
}

template<typename T>
void myPrint(T a, T b, T c) 
{ 
	cout << "调用重载的模板" << endl; 
}

void test01()
{
	//1、如果函数模板和普通函数都可以实现，优先调用普通函数
	// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到
	int a = 10;
	int b = 20;
	myPrint(a, b); //调用普通函数

	//2、可以通过空模板参数列表来强制调用函数模板
	myPrint<>(a, b); //调用函数模板

	//3、函数模板也可以发生重载
	int c = 30;
	myPrint(a, b, c); //调用重载的函数模板

	//4、 如果函数模板可以产生更好的匹配,优先调用函数模板
	char c1 = 'a';
	char c2 = 'b';
	myPrint(c1, c2); //调用函数模板
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性











#### 1.2.6 模板的局限性

**局限性：**

* 模板的通用性并不是万能的



**例如：**

```C++
	template<class T>
	void f(T a, T b)
	{ 
    	a = b;
    }
```

在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了



再例如：

```C++
	template<class T>
	void f(T a, T b)
	{ 
    	if(a > b) { ... }
    }
```

在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行



因此C++为了解决这种问题，提供模板的重载，可以为这些**特定的类型**提供**具体化的模板**



**示例：**

```C++
#include<iostream>
using namespace std;

#include <string>

class Person
{
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}
	string m_Name;
	int m_Age;
};

//普通函数模板
template<class T>
bool myCompare(T& a, T& b)
{
	if (a == b)
	{
		return true;
	}
	else
	{
		return false;
	}
}


//具体化，显示具体化的原型和定意思以template<>开头，并通过名称来指出类型
//具体化优先于常规模板
template<> bool myCompare(Person &p1, Person &p2)
{
	if ( p1.m_Name  == p2.m_Name && p1.m_Age == p2.m_Age)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void test01()
{
	int a = 10;
	int b = 20;
	//内置数据类型可以直接使用通用的函数模板
	bool ret = myCompare(a, b);
	if (ret)
	{
		cout << "a == b " << endl;
	}
	else
	{
		cout << "a != b " << endl;
	}
}

void test02()
{
	Person p1("Tom", 10);
	Person p2("Tom", 10);
	//自定义数据类型，不会调用普通的函数模板
	//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型
	bool ret = myCompare(p1, p2);
	if (ret)
	{
		cout << "p1 == p2 " << endl;
	}
	else
	{
		cout << "p1 != p2 " << endl;
	}
}

int main() {

	test01();

	test02();

	system("pause");

	return 0;
}
```

总结：

* 利用具体化的模板，可以解决自定义类型的通用化
* 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板









### 1.3 类模板

#### 1.3.1 类模板语法

类模板作用：

* 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个**虚拟的类型**来代表。



**语法：** 

```c++
template<typename T>
类
```

**解释：**

template  ---  声明创建模板

typename  --- 表面其后面的符号是一种数据类型，可以用class代替

T    ---   通用的数据类型，名称可以替换，通常为大写字母



**示例：**

```C++
#include <string>
//类模板
template<class NameType, class AgeType> 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

void test01()
{
	// 指定NameType 为string类型，AgeType 为 int类型
	Person<string, int>P1("孙悟空", 999);
	P1.showPerson();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板











#### 1.3.2 类模板与函数模板区别



类模板与函数模板区别主要有两点：

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数




**示例：**

```C++
#include <string>
//类模板
template<class NameType, class AgeType = int> 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

//1、类模板没有自动类型推导的使用方式
void test01()
{
	// Person p("孙悟空", 1000); // 错误 类模板使用时候，不可以用自动类型推导
	Person <string ,int>p("孙悟空", 1000); //必须使用显示指定类型的方式，使用类模板
	p.showPerson();
}

//2、类模板在模板参数列表中可以有默认参数
void test02()
{
	Person <string> p("猪八戒", 999); //类模板中的模板参数列表 可以指定默认参数
	p.showPerson();
}

int main() {

	test01();

	test02();

	system("pause");

	return 0;
}
```

总结：

* 类模板使用只能用显示指定类型方式
* 类模板中的模板参数列表可以有默认参数











#### 1.3.3 类模板中成员函数创建时机



类模板中成员函数和普通类中成员函数创建时机是有区别的：

* 普通类中的成员函数一开始就可以创建
* 类模板中的成员函数在调用时才创建





**示例：**

```C++
class Person1
{
public:
	void showPerson1()
	{
		cout << "Person1 show" << endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout << "Person2 show" << endl;
	}
};

template<class T>
class MyClass
{
public:
	T obj;

	//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成

	void fun1() { obj.showPerson1(); }
	void fun2() { obj.showPerson2(); }

};

void test01()
{
	MyClass<Person1> m;
	
	m.fun1();

	//m.fun2();//编译会出错，说明函数调用才会去创建成员函数
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建









#### 1.3.4 类模板对象做函数参数

学习目标：

* 类模板实例化出的对象，向函数传参的方式



一共有三种传入方式：

1. 指定传入的类型   --- 直接显示对象的数据类型
2. 参数模板化           --- 将对象中的参数变为模板进行传递
3. 整个类模板化       --- 将这个对象类型 模板化进行传递





**示例：**

```C++
#include <string>
//类模板
template<class NameType, class AgeType = int> 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

//1、指定传入的类型
void printPerson1(Person<string, int> &p) 
{
	p.showPerson();
}
void test01()
{
	Person <string, int >p("孙悟空", 100);
	printPerson1(p);
}

//2、参数模板化
template <class T1, class T2>
void printPerson2(Person<T1, T2>&p)
{
	p.showPerson();
	cout << "T1的类型为： " << typeid(T1).name() << endl;
	cout << "T2的类型为： " << typeid(T2).name() << endl;
}
void test02()
{
	Person <string, int >p("猪八戒", 90);
	printPerson2(p);
}

//3、整个类模板化
template<class T>
void printPerson3(T & p)
{
	cout << "T的类型为： " << typeid(T).name() << endl;
	p.showPerson();

}
void test03()
{
	Person <string, int >p("唐僧", 30);
	printPerson3(p);
}

int main() {

	test01();
	test02();
	test03();

	system("pause");

	return 0;
}
```

总结：

* 通过类模板创建的对象，可以有三种方式向函数中进行传参
* 使用比较广泛是第一种：指定传入的类型









#### 1.3.5 类模板与继承



当类模板碰到继承时，需要注意一下几点：

* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
* 如果不指定，编译器无法给子类分配内存
* 如果想灵活指定出父类中T的类型，子类也需变为类模板




**示例：**

```C++
template<class T>
class Base
{
	T m;
};

//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son :public Base<int> //必须指定一个类型
{
};
void test01()
{
	Son c;
}

//类模板继承类模板 ,可以用T2指定父类中的T类型
template<class T1, class T2>
class Son2 :public Base<T2>
{
public:
	Son2()
	{
		cout << typeid(T1).name() << endl;
		cout << typeid(T2).name() << endl;
	}
};

void test02()
{
	Son2<int, char> child1;
}


int main() {

	test01();

	test02();

	system("pause");

	return 0;
}
```

总结：如果父类是类模板，子类需要指定出父类中T的数据类型









#### 1.3.6 类模板成员函数类外实现



学习目标：能够掌握类模板中的成员函数类外实现



**示例：**

```C++
#include <string>

//类模板中成员函数类外实现
template<class T1, class T2>
class Person {
public:
	//成员函数类内声明
	Person(T1 name, T2 age);
	void showPerson();

public:
	T1 m_Name;
	T2 m_Age;
};

//构造函数 类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) {
	this->m_Name = name;
	this->m_Age = age;
}

//成员函数 类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson() {
	cout << "姓名: " << this->m_Name << " 年龄:" << this->m_Age << endl;
}

void test01()
{
	Person<string, int> p("Tom", 20);
	p.showPerson();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：类模板中成员函数类外实现时，需要加上模板参数列表









#### 1.3.7 类模板分文件编写

学习目标：

* 掌握类模板成员函数分文件编写产生的问题以及解决方式



问题：

* 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到


解决：

* 解决方式1：直接包含.cpp源文件
* 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制




**示例：**

person.hpp中代码：

```C++
#pragma once
#include <iostream>
using namespace std;
#include <string>

template<class T1, class T2>
class Person {
public:
	Person(T1 name, T2 age);
	void showPerson();
public:
	T1 m_Name;
	T2 m_Age;
};

//构造函数 类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) {
	this->m_Name = name;
	this->m_Age = age;
}

//成员函数 类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson() {
	cout << "姓名: " << this->m_Name << " 年龄:" << this->m_Age << endl;
}
```



类模板分文件编写.cpp中代码

```C++
#include<iostream>
using namespace std;

//#include "person.h"
#include "person.cpp" //解决方式1，包含cpp源文件

//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp
#include "person.hpp"
void test01()
{
	Person<string, int> p("Tom", 10);
	p.showPerson();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp









#### 1.3.8 类模板与友元



学习目标：

* 掌握类模板配合友元函数的类内和类外实现



全局函数类内实现 - 直接在类内声明友元即可

全局函数类外实现 - 需要提前让编译器知道全局函数的存在



**示例：**

```C++
#include <string>

//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元
template<class T1, class T2> class Person;

//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到
//template<class T1, class T2> void printPerson2(Person<T1, T2> & p); 

template<class T1, class T2>
void printPerson2(Person<T1, T2> & p)
{
	cout << "类外实现 ---- 姓名： " << p.m_Name << " 年龄：" << p.m_Age << endl;
}

template<class T1, class T2>
class Person
{
	//1、全局函数配合友元   类内实现
	friend void printPerson(Person<T1, T2> & p)
	{
		cout << "姓名： " << p.m_Name << " 年龄：" << p.m_Age << endl;
	}


	//全局函数配合友元  类外实现
	friend void printPerson2<>(Person<T1, T2> & p);

public:

	Person(T1 name, T2 age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}


private:
	T1 m_Name;
	T2 m_Age;

};

//1、全局函数在类内实现
void test01()
{
	Person <string, int >p("Tom", 20);
	printPerson(p);
}


//2、全局函数在类外实现
void test02()
{
	Person <string, int >p("Jerry", 30);
	printPerson2(p);
}

int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别











#### 1.3.9 类模板案例

案例描述:  实现一个通用的数组类，要求如下：



* 可以对内置数据类型以及自定义数据类型的数据进行存储
* 将数组中的数据存储到堆区
* 构造函数中可以传入数组的容量
* 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
* 提供尾插法和尾删法对数组中的数据进行增加和删除
* 可以通过下标的方式访问数组中的元素
* 可以获取数组中当前元素个数和数组的容量





**示例：**

myArray.hpp中代码

```C++
#pragma once
#include <iostream>
using namespace std;

template<class T>
class MyArray
{
public:
    
	//构造函数
	MyArray(int capacity)
	{
		this->m_Capacity = capacity;
		this->m_Size = 0;
		pAddress = new T[this->m_Capacity];
	}

	//拷贝构造
	MyArray(const MyArray & arr)
	{
		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，
			// 普通类型可以直接= 但是指针类型需要深拷贝
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	//重载= 操作符  防止浅拷贝问题
	MyArray& operator=(const MyArray& myarray) {

		if (this->pAddress != NULL) {
			delete[] this->pAddress;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}

		this->m_Capacity = myarray.m_Capacity;
		this->m_Size = myarray.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++) {
			this->pAddress[i] = myarray[i];
		}
		return *this;
	}

	//重载[] 操作符  arr[0]
	T& operator [](int index)
	{
		return this->pAddress[index]; //不考虑越界，用户自己去处理
	}

	//尾插法
	void Push_back(const T & val)
	{
		if (this->m_Capacity == this->m_Size)
		{
			return;
		}
		this->pAddress[this->m_Size] = val;
		this->m_Size++;
	}

	//尾删法
	void Pop_back()
	{
		if (this->m_Size == 0)
		{
			return;
		}
		this->m_Size--;
	}

	//获取数组容量
	int getCapacity()
	{
		return this->m_Capacity;
	}

	//获取数组大小
	int	getSize()
	{
		return this->m_Size;
	}


	//析构
	~MyArray()
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->pAddress = NULL;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}
	}

private:
	T * pAddress;  //指向一个堆空间，这个空间存储真正的数据
	int m_Capacity; //容量
	int m_Size;   // 大小
};
```



类模板案例—数组类封装.cpp中

```C++
#include "myArray.hpp"
#include <string>

void printIntArray(MyArray<int>& arr) {
	for (int i = 0; i < arr.getSize(); i++) {
		cout << arr[i] << " ";
	}
	cout << endl;
}

//测试内置数据类型
void test01()
{
	MyArray<int> array1(10);
	for (int i = 0; i < 10; i++)
	{
		array1.Push_back(i);
	}
	cout << "array1打印输出：" << endl;
	printIntArray(array1);
	cout << "array1的大小：" << array1.getSize() << endl;
	cout << "array1的容量：" << array1.getCapacity() << endl;

	cout << "--------------------------" << endl;

	MyArray<int> array2(array1);
	array2.Pop_back();
	cout << "array2打印输出：" << endl;
	printIntArray(array2);
	cout << "array2的大小：" << array2.getSize() << endl;
	cout << "array2的容量：" << array2.getCapacity() << endl;
}

//测试自定义数据类型
class Person {
public:
	Person() {} 
		Person(string name, int age) {
		this->m_Name = name;
		this->m_Age = age;
	}
public:
	string m_Name;
	int m_Age;
};

void printPersonArray(MyArray<Person>& personArr)
{
	for (int i = 0; i < personArr.getSize(); i++) {
		cout << "姓名：" << personArr[i].m_Name << " 年龄： " << personArr[i].m_Age << endl;
	}

}

void test02()
{
	//创建数组
	MyArray<Person> pArray(10);
	Person p1("孙悟空", 30);
	Person p2("韩信", 20);
	Person p3("妲己", 18);
	Person p4("王昭君", 15);
	Person p5("赵云", 24);

	//插入数据
	pArray.Push_back(p1);
	pArray.Push_back(p2);
	pArray.Push_back(p3);
	pArray.Push_back(p4);
	pArray.Push_back(p5);

	printPersonArray(pArray);

	cout << "pArray的大小：" << pArray.getSize() << endl;
	cout << "pArray的容量：" << pArray.getCapacity() << endl;

}

int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

总结：

能够利用所学知识点实现通用的数组





## 2 STL初识

### 2.1 STL的诞生



* 长久以来，软件界一直希望建立一种可重复利用的东西

* C++的**面向对象**和**泛型编程**思想，目的就是**复用性的提升**

* 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作

* 为了建立数据结构和算法的一套标准,诞生了**STL**

  


### 2.2 STL基本概念



* STL(Standard Template Library,**标准模板库**)
* STL 从广义上分为: **容器(container) 算法(algorithm) 迭代器(iterator)**
* **容器**和**算法**之间通过**迭代器**进行无缝连接。
* STL 几乎所有的代码都采用了模板类或者模板函数





### 2.3 STL六大组件

STL大体分为六大组件，分别是:**容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器**



1. 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。
2. 算法：各种常用的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂。
4. 仿函数：行为类似函数，可作为算法的某种策略。
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
6. 空间配置器：负责空间的配置与管理。





### 2.4  STL中容器、算法、迭代器



**容器：**置物之所也

STL**容器**就是将运用**最广泛的一些数据结构**实现出来

常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等

这些容器分为**序列式容器**和**关联式容器**两种:

​	**序列式容器**:强调值的排序，序列式容器中的每个元素均有固定的位置。
​	**关联式容器**:二叉树结构，各元素之间没有严格的物理上的顺序关系



**算法：**问题之解法也

有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)

算法分为:**质变算法**和**非质变算法**。

质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等

非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等



**迭代器：**容器和算法之间粘合剂

提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。

每个容器都有自己专属的迭代器

迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针



迭代器种类：

| 种类           | 功能                                                     | 支持运算                                |
| -------------- | -------------------------------------------------------- | --------------------------------------- |
| 输入迭代器     | 对数据的只读访问                                         | 只读，支持++、==、！=                   |
| 输出迭代器     | 对数据的只写访问                                         | 只写，支持++                            |
| 前向迭代器     | 读写操作，并能向前推进迭代器                             | 读写，支持++、==、！=                   |
| 双向迭代器     | 读写操作，并能向前和向后操作                             | 读写，支持++、--，                      |
| 随机访问迭代器 | 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 | 读写，支持++、--、[n]、-n、<、<=、>、>= |

常用的容器中迭代器种类为双向迭代器，和随机访问迭代器







### 2.5 容器算法迭代器初识



了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力

STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器



#### 2.5.1 vector存放内置数据类型



容器：     `vector`

算法：     `for_each`

迭代器： `vector<int>::iterator`



**示例：**

```C++
#include <vector>
#include <algorithm>

void MyPrint(int val)
{
	cout << val << endl;
}

void test01() {

	//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型
	vector<int> v;
	//向容器中放数据
	v.push_back(10);
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);

	//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素
	//v.begin()返回迭代器，这个迭代器指向容器中第一个数据
	//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置
	//vector<int>::iterator 拿到vector<int>这种容器的迭代器类型

	vector<int>::iterator pBegin = v.begin();
	vector<int>::iterator pEnd = v.end();

	//第一种遍历方式：
	while (pBegin != pEnd) {
		cout << *pBegin << endl;
		pBegin++;
	}

	
	//第二种遍历方式：
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << endl;
	}
	cout << endl;

	//第三种遍历方式：
	//使用STL提供标准遍历算法  头文件 algorithm
	for_each(v.begin(), v.end(), MyPrint);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



#### 2.5.2 Vector存放自定义数据类型



学习目标：vector中存放自定义数据类型，并打印输出



**示例：**

```c++
#include <vector>
#include <string>

//自定义数据类型
class Person {
public:
	Person(string name, int age) {
		mName = name;
		mAge = age;
	}
public:
	string mName;
	int mAge;
};
//存放对象
void test01() {

	vector<Person> v;

	//创建数据
	Person p1("aaa", 10);
	Person p2("bbb", 20);
	Person p3("ccc", 30);
	Person p4("ddd", 40);
	Person p5("eee", 50);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);

	for (vector<Person>::iterator it = v.begin(); it != v.end(); it++) {
		cout << "Name:" << (*it).mName << " Age:" << (*it).mAge << endl;

	}
}


//放对象指针
void test02() {

	vector<Person*> v;

	//创建数据
	Person p1("aaa", 10);
	Person p2("bbb", 20);
	Person p3("ccc", 30);
	Person p4("ddd", 40);
	Person p5("eee", 50);

	v.push_back(&p1);
	v.push_back(&p2);
	v.push_back(&p3);
	v.push_back(&p4);
	v.push_back(&p5);

	for (vector<Person*>::iterator it = v.begin(); it != v.end(); it++) {
		Person * p = (*it);
		cout << "Name:" << p->mName << " Age:" << (*it)->mAge << endl;
	}
}


int main() {

	test01();
    
	test02();

	system("pause");

	return 0;
}
```



#### 2.5.3 Vector容器嵌套容器



学习目标：容器中嵌套容器，我们将所有数据进行遍历输出



**示例：**

```C++
#include <vector>

//容器嵌套容器
void test01() {

	vector< vector<int> >  v;

	vector<int> v1;
	vector<int> v2;
	vector<int> v3;
	vector<int> v4;

	for (int i = 0; i < 4; i++) {
		v1.push_back(i + 1);
		v2.push_back(i + 2);
		v3.push_back(i + 3);
		v4.push_back(i + 4);
	}

	//将容器元素插入到vector v中
	v.push_back(v1);
	v.push_back(v2);
	v.push_back(v3);
	v.push_back(v4);


	for (vector<vector<int>>::iterator it = v.begin(); it != v.end(); it++) {

		for (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); vit++) {
			cout << *vit << " ";
		}
		cout << endl;
	}

}

int main() {

	test01();

	system("pause");

	return 0;
}
```





## 3 STL- 常用容器

### 3.1 string容器



#### 3.1.1 string基本概念

**本质：**

* string是C++风格的字符串，而string本质上是一个类



**string和char * 区别：**

* char * 是一个指针
* string是一个类，类内部封装了char\*，管理这个字符串，是一个char*型的容器。



**特点：**

string 类内部封装了很多成员方法

例如：查找find，拷贝copy，删除delete 替换replace，插入insert

string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责



#### 3.1.2 string构造函数

构造函数原型：

* `string();`          				//创建一个空的字符串 例如: string str;
  `string(const char* s);`	        //使用字符串s初始化
* `string(const string& str);`    //使用一个string对象初始化另一个string对象
* `string(int n, char c);`           //使用n个字符c初始化 



**示例：**

```C++
#include <string>
//string构造
void test01()
{
	string s1; //创建空字符串，调用无参构造函数
	cout << "str1 = " << s1 << endl;

	const char* str = "hello world";
	string s2(str); //把c_string转换成了string

	cout << "str2 = " << s2 << endl;

	string s3(s2); //调用拷贝构造函数
	cout << "str3 = " << s3 << endl;

	string s4(10, 'a');
	cout << "str3 = " << s3 << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：string的多种构造方式没有可比性，灵活使用即可









#### 3.1.3 string赋值操作

功能描述：

* 给string字符串进行赋值



赋值的函数原型：

* `string& operator=(const char* s);`             //char*类型字符串 赋值给当前的字符串
* `string& operator=(const string &s);`         //把字符串s赋给当前的字符串
* `string& operator=(char c);`                          //字符赋值给当前的字符串
* `string& assign(const char *s);`                  //把字符串s赋给当前的字符串
* `string& assign(const char *s, int n);`     //把字符串s的前n个字符赋给当前的字符串
* `string& assign(const string &s);`              //把字符串s赋给当前字符串
* `string& assign(int n, char c);`                  //用n个字符c赋给当前字符串




**示例：**

```C++
//赋值
void test01()
{
	string str1;
	str1 = "hello world";
	cout << "str1 = " << str1 << endl;

	string str2;
	str2 = str1;
	cout << "str2 = " << str2 << endl;

	string str3;
	str3 = 'a';
	cout << "str3 = " << str3 << endl;

	string str4;
	str4.assign("hello c++");
	cout << "str4 = " << str4 << endl;

	string str5;
	str5.assign("hello c++",5);
	cout << "str5 = " << str5 << endl;


	string str6;
	str6.assign(str5);
	cout << "str6 = " << str6 << endl;

	string str7;
	str7.assign(5, 'x');
	cout << "str7 = " << str7 << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

​	string的赋值方式很多，`operator=`  这种方式是比较实用的









#### 3.1.4 string字符串拼接

**功能描述：**

* 实现在字符串末尾拼接字符串



**函数原型：**

* `string& operator+=(const char* str);`                   //重载+=操作符
* `string& operator+=(const char c);`                         //重载+=操作符
* `string& operator+=(const string& str);`                //重载+=操作符
* `string& append(const char *s); `                               //把字符串s连接到当前字符串结尾
* `string& append(const char *s, int n);`                 //把字符串s的前n个字符连接到当前字符串结尾
* `string& append(const string &s);`                           //同operator+=(const string& str)
* `string& append(const string &s, int pos, int n);`//字符串s中从pos开始的n个字符连接到字符串结尾




**示例：**


```C++
//字符串拼接
void test01()
{
	string str1 = "我";

	str1 += "爱玩游戏";

	cout << "str1 = " << str1 << endl;
	
	str1 += ':';

	cout << "str1 = " << str1 << endl;

	string str2 = "LOL DNF";

	str1 += str2;

	cout << "str1 = " << str1 << endl;

	string str3 = "I";
	str3.append(" love ");
	str3.append("game abcde", 4);
	//str3.append(str2);
	str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾
	cout << "str3 = " << str3 << endl;
}
int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：字符串拼接的重载版本很多，初学阶段记住几种即可







#### 3.1.5 string查找和替换

**功能描述：**

* 查找：查找指定字符串是否存在
* 替换：在指定的位置替换字符串



**函数原型：**

* `int find(const string& str, int pos = 0) const;`              //查找str第一次出现位置,从pos开始查找
* `int find(const char* s, int pos = 0) const; `                     //查找s第一次出现位置,从pos开始查找
* `int find(const char* s, int pos, int n) const; `               //从pos位置查找s的前n个字符第一次位置
* `int find(const char c, int pos = 0) const; `                       //查找字符c第一次出现位置
* `int rfind(const string& str, int pos = npos) const;`      //查找str最后一次位置,从pos开始查找
* `int rfind(const char* s, int pos = npos) const;`              //查找s最后一次出现位置,从pos开始查找
* `int rfind(const char* s, int pos, int n) const;`              //从pos查找s的前n个字符最后一次位置
* `int rfind(const char c, int pos = 0) const;  `                      //查找字符c最后一次出现位置
* `string& replace(int pos, int n, const string& str); `       //替换从pos开始n个字符为字符串str
* `string& replace(int pos, int n,const char* s); `                 //替换从pos开始的n个字符为字符串s




**示例：**

```C++
//查找和替换
void test01()
{
	//查找
	string str1 = "abcdefgde";

	int pos = str1.find("de");

	if (pos == -1)
	{
		cout << "未找到" << endl;
	}
	else
	{
		cout << "pos = " << pos << endl;
	}
	

	pos = str1.rfind("de");

	cout << "pos = " << pos << endl;

}

void test02()
{
	//替换
	string str1 = "abcdefgde";
	str1.replace(1, 3, "1111");

	cout << "str1 = " << str1 << endl;
}

int main() {

	//test01();
	//test02();

	system("pause");

	return 0;
}
```

总结：

* find查找是从左往后，rfind从右往左
* find找到字符串后返回查找的第一个字符位置，找不到返回-1
* replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串
















####    3.1.6 string字符串比较

**功能描述：**

* 字符串之间的比较

**比较方式：**

* 字符串比较是按字符的ASCII码进行对比

= 返回   0

\> 返回   1 

< 返回  -1



**函数原型：**

* `int compare(const string &s) const; `  //与字符串s比较
* `int compare(const char *s) const;`      //与字符串s比较





**示例：**

```C++
//字符串比较
void test01()
{

	string s1 = "hello";
	string s2 = "aello";

	int ret = s1.compare(s2);

	if (ret == 0) {
		cout << "s1 等于 s2" << endl;
	}
	else if (ret > 0)
	{
		cout << "s1 大于 s2" << endl;
	}
	else
	{
		cout << "s1 小于 s2" << endl;
	}

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大





#### 3.1.7 string字符存取



string中单个字符存取方式有两种



* `char& operator[](int n); `     //通过[]方式取字符
* `char& at(int n);   `                    //通过at方法获取字符





**示例：**

```C++
void test01()
{
	string str = "hello world";

	for (int i = 0; i < str.size(); i++)
	{
		cout << str[i] << " ";
	}
	cout << endl;

	for (int i = 0; i < str.size(); i++)
	{
		cout << str.at(i) << " ";
	}
	cout << endl;


	//字符修改
	str[0] = 'x';
	str.at(1) = 'x';
	cout << str << endl;
	
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at









#### 3.1.8 string插入和删除

**功能描述：**

* 对string字符串进行插入和删除字符操作

**函数原型：**

* `string& insert(int pos, const char* s);  `                //插入字符串
* `string& insert(int pos, const string& str); `        //插入字符串
* `string& insert(int pos, int n, char c);`                //在指定位置插入n个字符c
* `string& erase(int pos, int n = npos);`                    //删除从Pos开始的n个字符 





**示例：**

```C++
//字符串插入和删除
void test01()
{
	string str = "hello";
	str.insert(1, "111");
	cout << str << endl;

	str.erase(1, 3);  //从1号位置开始3个字符
	cout << str << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**插入和删除的起始下标都是从0开始











#### 3.1.9 string子串

**功能描述：**

* 从字符串中获取想要的子串



**函数原型：**

* `string substr(int pos = 0, int n = npos) const;`   //返回由pos开始的n个字符组成的字符串




**示例：**

```C++
//子串
void test01()
{

	string str = "abcdefg";
	string subStr = str.substr(1, 3);
	cout << "subStr = " << subStr << endl;

	string email = "hello@sina.com";
	int pos = email.find("@");
	string username = email.substr(0, pos);
	cout << "username: " << username << endl;

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息







### 3.2 vector容器



#### 3.2.1 vector基本概念

**功能：**

* vector数据结构和**数组非常相似**，也称为**单端数组**



**vector与普通数组区别：**

* 不同之处在于数组是静态空间，而vector可以**动态扩展**



**动态扩展：**

* 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间



![说明: 2015-11-10_151152](C:/Users/mm611/Desktop/C++/讲义/assets/clip_image002.jpg)



* vector容器的迭代器是支持随机访问的迭代器





#### 3.2.2 vector构造函数



**功能描述：**

* 创建vector容器



**函数原型：**

* `vector<T> v; `               		     //采用模板实现类实现，默认构造函数
* `vector(v.begin(), v.end());   `       //将v[begin(), end())区间中的元素拷贝给本身。
* `vector(n, elem);`                            //构造函数将n个elem拷贝给本身。
* `vector(const vector &vec);`         //拷贝构造函数。

 


**示例：**


```C++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

void test01()
{
	vector<int> v1; //无参构造
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector<int> v2(v1.begin(), v1.end());
	printVector(v2);

	vector<int> v3(10, 100);
	printVector(v3);
	
	vector<int> v4(v3);
	printVector(v4);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**vector的多种构造方式没有可比性，灵活使用即可









#### 3.2.3 vector赋值操作



**功能描述：**

* 给vector容器进行赋值



**函数原型：**

* `vector& operator=(const vector &vec);`//重载等号操作符


* `assign(beg, end);`       //将[beg, end)区间中的数据拷贝赋值给本身。
* `assign(n, elem);`        //将n个elem拷贝赋值给本身。





**示例：**

```C++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

//赋值操作
void test01()
{
	vector<int> v1; //无参构造
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector<int>v2;
	v2 = v1;
	printVector(v2);

	vector<int>v3;
	v3.assign(v1.begin(), v1.end());
	printVector(v3);

	vector<int>v4;
	v4.assign(10, 100);
	printVector(v4);
}

int main() {

	test01();

	system("pause");

	return 0;
}

```

总结： vector赋值方式比较简单，使用operator=，或者assign都可以







#### 3.2.4  vector容量和大小

**功能描述：**

* 对vector容器的容量和大小操作



**函数原型：**

* `empty(); `                            //判断容器是否为空

* `capacity();`                      //容器的容量

* `size();`                              //返回容器中元素的个数

* `resize(int num);`             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。

  ​					      //如果容器变短，则末尾超出容器长度的元素被删除。

* `resize(int num, elem);`  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。

  ​				              //如果容器变短，则末尾超出容器长度的元素被删除




**示例：**


```C++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);
	if (v1.empty())
	{
		cout << "v1为空" << endl;
	}
	else
	{
		cout << "v1不为空" << endl;
		cout << "v1的容量 = " << v1.capacity() << endl;
		cout << "v1的大小 = " << v1.size() << endl;
	}

	//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充
	v1.resize(15,10);
	printVector(v1);

	//resize 重新指定大小 ，若指定的更小，超出部分元素被删除
	v1.resize(5);
	printVector(v1);
}

int main() {

	test01();

	system("pause");

	return 0;
}

```

总结：

* 判断是否为空  --- empty
* 返回元素个数  --- size
* 返回容器容量  --- capacity
* 重新指定大小  ---  resize













#### 3.2.5 vector插入和删除

**功能描述：**

* 对vector容器进行插入、删除操作



**函数原型：**

* `push_back(ele);`                                         //尾部插入元素ele
* `pop_back();`                                                //删除最后一个元素
* `insert(const_iterator pos, ele);`        //迭代器指向位置pos插入元素ele
* `insert(const_iterator pos, int count,ele);`//迭代器指向位置pos插入count个元素ele
* `erase(const_iterator pos);`                     //删除迭代器指向的元素
* `erase(const_iterator start, const_iterator end);`//删除迭代器从start到end之间的元素
* `clear();`                                                        //删除容器中所有元素





**示例：**

```C++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

//插入和删除
void test01()
{
	vector<int> v1;
	//尾插
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);
	v1.push_back(40);
	v1.push_back(50);
	printVector(v1);
	//尾删
	v1.pop_back();
	printVector(v1);
	//插入
	v1.insert(v1.begin(), 100);
	printVector(v1);

	v1.insert(v1.begin(), 2, 1000);
	printVector(v1);

	//删除
	v1.erase(v1.begin());
	printVector(v1);

	//清空
	v1.erase(v1.begin(), v1.end());
	v1.clear();
	printVector(v1);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 尾插  --- push_back
* 尾删  --- pop_back
* 插入  --- insert    (位置迭代器)
* 删除  --- erase  （位置迭代器）
* 清空  ---  clear  













#### 3.2.6 vector数据存取



**功能描述：**

* 对vector中的数据的存取操作



**函数原型：**

* `at(int idx); `     //返回索引idx所指的数据
* `operator[]; `       //返回索引idx所指的数据
* `front(); `            //返回容器中第一个数据元素
* `back();`              //返回容器中最后一个数据元素





**示例：**

```C++
#include <vector>

void test01()
{
	vector<int>v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}

	for (int i = 0; i < v1.size(); i++)
	{
		cout << v1[i] << " ";
	}
	cout << endl;

	for (int i = 0; i < v1.size(); i++)
	{
		cout << v1.at(i) << " ";
	}
	cout << endl;

	cout << "v1的第一个元素为： " << v1.front() << endl;
	cout << "v1的最后一个元素为： " << v1.back() << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 除了用迭代器获取vector容器中元素，[ ]和at也可以
* front返回容器第一个元素
* back返回容器最后一个元素











#### 3.2.7 vector互换容器

**功能描述：**

* 实现两个容器内元素进行互换



**函数原型：**

* `swap(vec);`  // 将vec与本身的元素互换





**示例：**

```C++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

void test01()
{
	vector<int>v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector<int>v2;
	for (int i = 10; i > 0; i--)
	{
		v2.push_back(i);
	}
	printVector(v2);

	//互换容器
	cout << "互换后" << endl;
	v1.swap(v2);
	printVector(v1);
	printVector(v2);
}

void test02()
{
	vector<int> v;
	for (int i = 0; i < 100000; i++) {
		v.push_back(i);
	}

	cout << "v的容量为：" << v.capacity() << endl;
	cout << "v的大小为：" << v.size() << endl;

	v.resize(3);

	cout << "v的容量为：" << v.capacity() << endl;
	cout << "v的大小为：" << v.size() << endl;

	//收缩内存
	vector<int>(v).swap(v); //匿名对象

	cout << "v的容量为：" << v.capacity() << endl;
	cout << "v的大小为：" << v.size() << endl;
}

int main() {

	test01();

	test02();

	system("pause");

	return 0;
}

```

总结：swap可以使两个容器互换，可以达到实用的收缩内存效果









#### 3.2.8 vector预留空间

**功能描述：**

* 减少vector在动态扩展容量时的扩展次数



**函数原型：**

* `reserve(int len);`//容器预留len个元素长度，预留位置不初始化，元素不可访问。

  

**示例：**

```C++
#include <vector>

void test01()
{
	vector<int> v;

	//预留空间
	v.reserve(100000);

	int num = 0;
	int* p = NULL;
	for (int i = 0; i < 100000; i++) {
		v.push_back(i);
		if (p != &v[0]) {
			p = &v[0];
			num++;
		}
	}

	cout << "num:" << num << endl;
}

int main() {

	test01();
    
	system("pause");

	return 0;
}
```

总结：如果数据量较大，可以一开始利用reserve预留空间











### 3.3 deque容器

#### 3.3.1 deque容器基本概念



**功能：**

* 双端数组，可以对头端进行插入删除操作



**deque与vector区别：**

* vector对于头部的插入删除效率低，数据量越大，效率越低
* deque相对而言，对头部的插入删除速度回比vector快
* vector访问元素时的速度会比deque快,这和两者内部实现有关

![说明: 2015-11-19_204101](C:/Users/mm611/Desktop/C++/讲义/assets/clip_image002-1547547642923.jpg)



deque内部工作原理:

deque内部有个**中控器**，维护每段缓冲区中的内容，缓冲区中存放真实数据

中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间

![clip_image002-1547547896341](C:/Users/mm611/Desktop/C++/讲义/assets/clip_image002-1547547896341.jpg)

* deque容器的迭代器也是支持随机访问的



#### 3.3.2 deque构造函数

**功能描述：**

* deque容器构造



**函数原型：**

* `deque<T>` deqT;                      //默认构造形式
* `deque(beg, end);`                  //构造函数将[beg, end)区间中的元素拷贝给本身。
* `deque(n, elem);`                    //构造函数将n个elem拷贝给本身。
* `deque(const deque &deq);`   //拷贝构造函数





**示例：**

```C++
#include <deque>

void printDeque(const deque<int>& d) 
{
	for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
		cout << *it << " ";

	}
	cout << endl;
}
//deque构造
void test01() {

	deque<int> d1; //无参构造函数
	for (int i = 0; i < 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);
	deque<int> d2(d1.begin(),d1.end());
	printDeque(d2);

	deque<int>d3(10,100);
	printDeque(d3);

	deque<int>d4 = d3;
	printDeque(d4);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可









#### 3.3.3 deque赋值操作



**功能描述：**

* 给deque容器进行赋值



**函数原型：**

* `deque& operator=(const deque &deq); `         //重载等号操作符


* `assign(beg, end);`                                           //将[beg, end)区间中的数据拷贝赋值给本身。
* `assign(n, elem);`                                             //将n个elem拷贝赋值给本身。





**示例：**

```C++
#include <deque>

void printDeque(const deque<int>& d) 
{
	for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
		cout << *it << " ";

	}
	cout << endl;
}
//赋值操作
void test01()
{
	deque<int> d1;
	for (int i = 0; i < 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);

	deque<int>d2;
	d2 = d1;
	printDeque(d2);

	deque<int>d3;
	d3.assign(d1.begin(), d1.end());
	printDeque(d3);

	deque<int>d4;
	d4.assign(10, 100);
	printDeque(d4);

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：deque赋值操作也与vector相同，需熟练掌握







#### 3.3.4 deque大小操作

**功能描述：**

* 对deque容器的大小进行操作



**函数原型：**

* `deque.empty();`                       //判断容器是否为空

* `deque.size();`                         //返回容器中元素的个数

* `deque.resize(num);`                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。

  ​			                             //如果容器变短，则末尾超出容器长度的元素被删除。

* `deque.resize(num, elem);`     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。

  ​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。

  



**示例：**

```C++
#include <deque>

void printDeque(const deque<int>& d) 
{
	for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
		cout << *it << " ";

	}
	cout << endl;
}

//大小操作
void test01()
{
	deque<int> d1;
	for (int i = 0; i < 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);

	//判断容器是否为空
	if (d1.empty()) {
		cout << "d1为空!" << endl;
	}
	else {
		cout << "d1不为空!" << endl;
		//统计大小
		cout << "d1的大小为：" << d1.size() << endl;
	}

	//重新指定大小
	d1.resize(15, 1);
	printDeque(d1);

	d1.resize(5);
	printDeque(d1);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* deque没有容量的概念
* 判断是否为空   --- empty
* 返回元素个数   --- size
* 重新指定个数   --- resize









#### 3.3.5 deque 插入和删除

**功能描述：**

* 向deque容器中插入和删除数据



**函数原型：**

两端插入操作：

- `push_back(elem);`          //在容器尾部添加一个数据
- `push_front(elem);`        //在容器头部插入一个数据
- `pop_back();`                   //删除容器最后一个数据
- `pop_front();`                 //删除容器第一个数据

指定位置操作：

* `insert(pos,elem);`         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。

* `insert(pos,n,elem);`     //在pos位置插入n个elem数据，无返回值。

* `insert(pos,beg,end);`    //在pos位置插入[beg,end)区间的数据，无返回值。

* `clear();`                           //清空容器的所有数据

* `erase(beg,end);`             //删除[beg,end)区间的数据，返回下一个数据的位置。

* `erase(pos);`                    //删除pos位置的数据，返回下一个数据的位置。

  

  



**示例：**

```C++
#include <deque>

void printDeque(const deque<int>& d) 
{
	for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
		cout << *it << " ";

	}
	cout << endl;
}
//两端操作
void test01()
{
	deque<int> d;
	//尾插
	d.push_back(10);
	d.push_back(20);
	//头插
	d.push_front(100);
	d.push_front(200);

	printDeque(d);

	//尾删
	d.pop_back();
	//头删
	d.pop_front();
	printDeque(d);
}

//插入
void test02()
{
	deque<int> d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);
	printDeque(d);

	d.insert(d.begin(), 1000);
	printDeque(d);

	d.insert(d.begin(), 2,10000);
	printDeque(d);

	deque<int>d2;
	d2.push_back(1);
	d2.push_back(2);
	d2.push_back(3);

	d.insert(d.begin(), d2.begin(), d2.end());
	printDeque(d);

}

//删除
void test03()
{
	deque<int> d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);
	printDeque(d);

	d.erase(d.begin());
	printDeque(d);

	d.erase(d.begin(), d.end());
	d.clear();
	printDeque(d);
}

int main() {

	//test01();

	//test02();

    test03();
    
	system("pause");

	return 0;
}

```

总结：

* 插入和删除提供的位置是迭代器！
* 尾插   ---  push_back
* 尾删   ---  pop_back
* 头插   ---  push_front
* 头删   ---  pop_front











#### 3.3.6 deque 数据存取



**功能描述：**

* 对deque 中的数据的存取操作



**函数原型：**

- `at(int idx); `     //返回索引idx所指的数据
- `operator[]; `      //返回索引idx所指的数据
- `front(); `            //返回容器中第一个数据元素
- `back();`              //返回容器中最后一个数据元素



**示例：**

```C++
#include <deque>

void printDeque(const deque<int>& d) 
{
	for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
		cout << *it << " ";

	}
	cout << endl;
}

//数据存取
void test01()
{

	deque<int> d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);

	for (int i = 0; i < d.size(); i++) {
		cout << d[i] << " ";
	}
	cout << endl;


	for (int i = 0; i < d.size(); i++) {
		cout << d.at(i) << " ";
	}
	cout << endl;

	cout << "front:" << d.front() << endl;

	cout << "back:" << d.back() << endl;

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

- 除了用迭代器获取deque容器中元素，[ ]和at也可以
- front返回容器第一个元素
- back返回容器最后一个元素













#### 3.3.7  deque 排序

**功能描述：**

* 利用算法实现对deque容器进行排序



**算法：**

* `sort(iterator beg, iterator end)`  //对beg和end区间内元素进行排序





**示例：**

```C++
#include <deque>
#include <algorithm>

void printDeque(const deque<int>& d) 
{
	for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
		cout << *it << " ";

	}
	cout << endl;
}

void test01()
{

	deque<int> d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);

	printDeque(d);
	sort(d.begin(), d.end());
	printDeque(d);

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：sort算法非常实用，使用时包含头文件 algorithm即可











### 3.4 案例-评委打分



#### 3.4.1 案例描述

有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。



#### 3.4.2 实现步骤

1. 创建五名选手，放到vector中
2. 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中
3. sort算法对deque容器中分数排序，去除最高和最低分
4. deque容器遍历一遍，累加总分
5. 获取平均分





**示例代码：**

```C++
//选手类
class Person
{
public:
	Person(string name, int score)
	{
		this->m_Name = name;
		this->m_Score = score;
	}

	string m_Name; //姓名
	int m_Score;  //平均分
};

void createPerson(vector<Person>&v)
{
	string nameSeed = "ABCDE";
	for (int i = 0; i < 5; i++)
	{
		string name = "选手";
		name += nameSeed[i];

		int score = 0;

		Person p(name, score);

		//将创建的person对象 放入到容器中
		v.push_back(p);
	}
}

//打分
void setScore(vector<Person>&v)
{
	for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
	{
		//将评委的分数 放入到deque容器中
		deque<int>d;
		for (int i = 0; i < 10; i++)
		{
			int score = rand() % 41 + 60;  // 60 ~ 100
			d.push_back(score);
		}

		//cout << "选手： " << it->m_Name << " 打分： " << endl;
		//for (deque<int>::iterator dit = d.begin(); dit != d.end(); dit++)
		//{
		//	cout << *dit << " ";
		//}
		//cout << endl;

		//排序
		sort(d.begin(), d.end());

		//去除最高和最低分
		d.pop_back();
		d.pop_front();

		//取平均分
		int sum = 0;
		for (deque<int>::iterator dit = d.begin(); dit != d.end(); dit++)
		{
			sum += *dit; //累加每个评委的分数
		}

		int avg = sum / d.size();

		//将平均分 赋值给选手身上
		it->m_Score = avg;
	}

}

void showScore(vector<Person>&v)
{
	for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << "姓名： " << it->m_Name << " 平均分： " << it->m_Score << endl;
	}
}

int main() {

	//随机数种子
	srand((unsigned int)time(NULL));

	//1、创建5名选手
	vector<Person>v;  //存放选手容器
	createPerson(v);

	//测试
	//for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
	//{
	//	cout << "姓名： " << (*it).m_Name << " 分数： " << (*it).m_Score << endl;
	//}

	//2、给5名选手打分
	setScore(v);

	//3、显示最后得分
	showScore(v);

	system("pause");

	return 0;
}
```

**总结：** 选取不同的容器操作数据，可以提升代码的效率







### 3.5 stack容器

#### 3.5.1 stack 基本概念



**概念：**stack是一种**先进后出**(First In Last Out,FILO)的数据结构，它只有一个出口





![说明: 2015-11-15_195707](C:/Users/mm611/Desktop/C++/讲义/assets/clip_image002-1547604555425.jpg)

栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为

栈中进入数据称为  --- **入栈**  `push`

栈中弹出数据称为  --- **出栈**  `pop`



生活中的栈：

![img](C:/Users/mm611/Desktop/C++/讲义/assets/clip_image002.png)





![img](C:/Users/mm611/Desktop/C++/讲义/assets/clip_image002-1547605111510.jpg)



#### 3.5.2 stack 常用接口

功能描述：栈容器常用的对外接口



构造函数：

* `stack<T> stk;`                                 //stack采用模板类实现， stack对象的默认构造形式
* `stack(const stack &stk);`            //拷贝构造函数

赋值操作：

* `stack& operator=(const stack &stk);`           //重载等号操作符

数据存取：

* `push(elem);`      //向栈顶添加元素
* `pop();`                //从栈顶移除第一个元素
* `top(); `                //返回栈顶元素

大小操作：

* `empty();`            //判断堆栈是否为空
* `size(); `              //返回栈的大小





**示例：**

```C++
#include <stack>

//栈容器常用接口
void test01()
{
	//创建栈容器 栈容器必须符合先进后出
	stack<int> s;

	//向栈中添加元素，叫做 压栈 入栈
	s.push(10);
	s.push(20);
	s.push(30);

	while (!s.empty()) {
		//输出栈顶元素
		cout << "栈顶元素为： " << s.top() << endl;
		//弹出栈顶元素
		s.pop();
	}
	cout << "栈的大小为：" << s.size() << endl;

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 入栈   --- push
* 出栈   --- pop
* 返回栈顶   --- top
* 判断栈是否为空   --- empty
* 返回栈大小   --- size











### 3.6 queue 容器

#### 3.6.1 queue 基本概念



**概念：**Queue是一种**先进先出**(First In First Out,FIFO)的数据结构，它有两个出口







![说明: 2015-11-15_214429](C:/Users/mm611/Desktop/C++/讲义/assets/clip_image002-1547606475892.jpg)

队列容器允许从一端新增元素，从另一端移除元素

队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为

队列中进数据称为 --- **入队**    `push`

队列中出数据称为 --- **出队**    `pop`



生活中的队列：

![1547606785041](C:/Users/mm611/Desktop/C++/讲义/assets/1547606785041.png)







#### 3.6.2 queue 常用接口



功能描述：栈容器常用的对外接口



构造函数：

- `queue<T> que;`                                 //queue采用模板类实现，queue对象的默认构造形式
- `queue(const queue &que);`            //拷贝构造函数

赋值操作：

- `queue& operator=(const queue &que);`           //重载等号操作符

数据存取：

- `push(elem);`                             //往队尾添加元素
- `pop();`                                      //从队头移除第一个元素
- `back();`                                    //返回最后一个元素
- `front(); `                                  //返回第一个元素

大小操作：

- `empty();`            //判断堆栈是否为空
- `size(); `              //返回栈的大小



**示例：**

```C++
#include <queue>
#include <string>
class Person
{
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}

	string m_Name;
	int m_Age;
};

void test01() {

	//创建队列
	queue<Person> q;

	//准备数据
	Person p1("唐僧", 30);
	Person p2("孙悟空", 1000);
	Person p3("猪八戒", 900);
	Person p4("沙僧", 800);

	//向队列中添加元素  入队操作
	q.push(p1);
	q.push(p2);
	q.push(p3);
	q.push(p4);

	//队列不提供迭代器，更不支持随机访问	
	while (!q.empty()) {
		//输出队头元素
		cout << "队头元素-- 姓名： " << q.front().m_Name 
              << " 年龄： "<< q.front().m_Age << endl;
        
		cout << "队尾元素-- 姓名： " << q.back().m_Name  
              << " 年龄： " << q.back().m_Age << endl;
        
		cout << endl;
		//弹出队头元素
		q.pop();
	}

	cout << "队列大小为：" << q.size() << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

- 入队   --- push
- 出队   --- pop
- 返回队头元素   --- front
- 返回队尾元素   --- back
- 判断队是否为空   --- empty
- 返回队列大小   --- size















### 3.7 list容器

#### 3.7.1 list基本概念



**功能：**将数据进行链式存储

**链表**（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的



链表的组成：链表由一系列**结点**组成



结点的组成：一个是存储数据元素的**数据域**，另一个是存储下一个结点地址的**指针域**



STL中的链表是一个双向循环链表



![说明: 2015-11-15_225145](C:/Users/mm611/Desktop/C++/讲义/assets/clip_image002-1547608564071.jpg)

由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于**双向迭代器**



list的优点：

* 采用动态存储分配，不会造成内存浪费和溢出
* 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素

list的缺点：

* 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大



List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。



总结：STL中**List和vector是两个最常被使用的容器**，各有优缺点





#### 3.7.2  list构造函数

**功能描述：**

* 创建list容器



**函数原型：**

* `list<T> lst;`                               //list采用采用模板类实现,对象的默认构造形式：
* `list(beg,end);`                           //构造函数将[beg, end)区间中的元素拷贝给本身。
* `list(n,elem);`                             //构造函数将n个elem拷贝给本身。
* `list(const list &lst);`            //拷贝构造函数。





**示例：**

```C++
#include <list>

void printList(const list<int>& L) {

	for (list<int>::const_iterator it = L.begin(); it != L.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

void test01()
{
	list<int>L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);

	printList(L1);

	list<int>L2(L1.begin(),L1.end());
	printList(L2);

	list<int>L3(L2);
	printList(L3);

	list<int>L4(10, 1000);
	printList(L4);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：list构造方式同其他几个STL常用容器，熟练掌握即可













#### 3.7.3 list 赋值和交换

**功能描述：**

* 给list容器进行赋值，以及交换list容器

**函数原型：**

* `assign(beg, end);`            //将[beg, end)区间中的数据拷贝赋值给本身。
* `assign(n, elem);`              //将n个elem拷贝赋值给本身。
* `list& operator=(const list &lst);`         //重载等号操作符
* `swap(lst);`                         //将lst与本身的元素互换。



**示例：**

```C++
#include <list>

void printList(const list<int>& L) {

	for (list<int>::const_iterator it = L.begin(); it != L.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

//赋值和交换
void test01()
{
	list<int>L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);
	printList(L1);

	//赋值
	list<int>L2;
	L2 = L1;
	printList(L2);

	list<int>L3;
	L3.assign(L2.begin(), L2.end());
	printList(L3);

	list<int>L4;
	L4.assign(10, 100);
	printList(L4);

}

//交换
void test02()
{

	list<int>L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);

	list<int>L2;
	L2.assign(10, 100);

	cout << "交换前： " << endl;
	printList(L1);
	printList(L2);

	cout << endl;

	L1.swap(L2);

	cout << "交换后： " << endl;
	printList(L1);
	printList(L2);

}

int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

总结：list赋值和交换操作能够灵活运用即可















#### 3.7.4 list 大小操作

**功能描述：**

* 对list容器的大小进行操作



**函数原型：**

* `size(); `                             //返回容器中元素的个数

* `empty(); `                           //判断容器是否为空

* `resize(num);`                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。

  ​					    //如果容器变短，则末尾超出容器长度的元素被删除。

* `resize(num, elem); `       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。

   	 	​					    //如果容器变短，则末尾超出容器长度的元素被删除。



**示例：**

```C++
#include <list>

void printList(const list<int>& L) {

	for (list<int>::const_iterator it = L.begin(); it != L.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

//大小操作
void test01()
{
	list<int>L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);

	if (L1.empty())
	{
		cout << "L1为空" << endl;
	}
	else
	{
		cout << "L1不为空" << endl;
		cout << "L1的大小为： " << L1.size() << endl;
	}

	//重新指定大小
	L1.resize(10);
	printList(L1);

	L1.resize(2);
	printList(L1);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

- 判断是否为空   --- empty
- 返回元素个数   --- size
- 重新指定个数   --- resize











#### 3.7.5 list 插入和删除

**功能描述：**

* 对list容器进行数据的插入和删除



**函数原型：**

* push_back(elem);//在容器尾部加入一个元素
* pop_back();//删除容器中最后一个元素
* push_front(elem);//在容器开头插入一个元素
* pop_front();//从容器开头移除第一个元素
* insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
* insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
* insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
* clear();//移除容器的所有数据
* erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
* erase(pos);//删除pos位置的数据，返回下一个数据的位置。
* remove(elem);//删除容器中所有与elem值匹配的元素。





**示例：**

```C++
#include <list>

void printList(const list<int>& L) {

	for (list<int>::const_iterator it = L.begin(); it != L.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

//插入和删除
void test01()
{
	list<int> L;
	//尾插
	L.push_back(10);
	L.push_back(20);
	L.push_back(30);
	//头插
	L.push_front(100);
	L.push_front(200);
	L.push_front(300);

	printList(L);

	//尾删
	L.pop_back();
	printList(L);

	//头删
	L.pop_front();
	printList(L);

	//插入
	list<int>::iterator it = L.begin();
	L.insert(++it, 1000);
	printList(L);

	//删除
	it = L.begin();
	L.erase(++it);
	printList(L);

	//移除
	L.push_back(10000);
	L.push_back(10000);
	L.push_back(10000);
	printList(L);
	L.remove(10000);
	printList(L);
    
    //清空
	L.clear();
	printList(L);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 尾插   --- push_back
* 尾删   --- pop_back
* 头插   --- push_front
* 头删   --- pop_front
* 插入   --- insert
* 删除   --- erase
* 移除   --- remove
* 清空   --- clear

















#### 3.7.6 list 数据存取

**功能描述：**

* 对list容器中数据进行存取



**函数原型：**

* `front();`        //返回第一个元素。
* `back();`         //返回最后一个元素。





**示例：**

```C++
#include <list>

//数据存取
void test01()
{
	list<int>L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);

	
	//cout << L1.at(0) << endl;//错误 不支持at访问数据
	//cout << L1[0] << endl; //错误  不支持[]方式访问数据
	cout << "第一个元素为： " << L1.front() << endl;
	cout << "最后一个元素为： " << L1.back() << endl;

	//list容器的迭代器是双向迭代器，不支持随机访问
	list<int>::iterator it = L1.begin();
	//it = it + 1;//错误，不可以跳跃访问，即使是+1
}

int main() {

	test01();

	system("pause");

	return 0;
}

```

总结：

* list容器中不可以通过[]或者at方式访问数据
* 返回第一个元素   --- front
* 返回最后一个元素   --- back











#### 3.7.7 list 反转和排序

**功能描述：**

* 将容器中的元素反转，以及将容器中的数据进行排序



**函数原型：**

* `reverse();`   //反转链表
* `sort();`        //链表排序





**示例：**

```C++
void printList(const list<int>& L) {

	for (list<int>::const_iterator it = L.begin(); it != L.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

bool myCompare(int val1 , int val2)
{
	return val1 > val2;
}

//反转和排序
void test01()
{
	list<int> L;
	L.push_back(90);
	L.push_back(30);
	L.push_back(20);
	L.push_back(70);
	printList(L);

	//反转容器的元素
	L.reverse();
	printList(L);

	//排序
	L.sort(); //默认的排序规则 从小到大
	printList(L);

	L.sort(myCompare); //指定规则，从大到小
	printList(L);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 反转   --- reverse
* 排序   --- sort （成员函数）











#### 3.7.8 排序案例

案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高

排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序



**示例：**

```C++
#include <list>
#include <string>
class Person {
public:
	Person(string name, int age , int height) {
		m_Name = name;
		m_Age = age;
		m_Height = height;
	}

public:
	string m_Name;  //姓名
	int m_Age;      //年龄
	int m_Height;   //身高
};


bool ComparePerson(Person& p1, Person& p2) {

	if (p1.m_Age == p2.m_Age) {
		return p1.m_Height  > p2.m_Height;
	}
	else
	{
		return  p1.m_Age < p2.m_Age;
	}

}

void test01() {

	list<Person> L;

	Person p1("刘备", 35 , 175);
	Person p2("曹操", 45 , 180);
	Person p3("孙权", 40 , 170);
	Person p4("赵云", 25 , 190);
	Person p5("张飞", 35 , 160);
	Person p6("关羽", 35 , 200);

	L.push_back(p1);
	L.push_back(p2);
	L.push_back(p3);
	L.push_back(p4);
	L.push_back(p5);
	L.push_back(p6);

	for (list<Person>::iterator it = L.begin(); it != L.end(); it++) {
		cout << "姓名： " << it->m_Name << " 年龄： " << it->m_Age 
              << " 身高： " << it->m_Height << endl;
	}

	cout << "---------------------------------" << endl;
	L.sort(ComparePerson); //排序

	for (list<Person>::iterator it = L.begin(); it != L.end(); it++) {
		cout << "姓名： " << it->m_Name << " 年龄： " << it->m_Age 
              << " 身高： " << it->m_Height << endl;
	}
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



总结：

* 对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序


* 高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂



















### 3.8 set/ multiset 容器

#### 3.8.1 set基本概念

**简介：**

* 所有元素都会在插入时自动被排序





**本质：**

* set/multiset属于**关联式容器**，底层结构是用**二叉树**实现。





**set和multiset区别**：

* set不允许容器中有重复的元素
* multiset允许容器中有重复的元素





#### 3.8.2 set构造和赋值

功能描述：创建set容器以及赋值



构造：

* `set<T> st;`                        //默认构造函数：
* `set(const set &st);`       //拷贝构造函数

赋值：

* `set& operator=(const set &st);`    //重载等号操作符



**示例：**

```C++
#include <set>

void printSet(set<int> & s)
{
	for (set<int>::iterator it = s.begin(); it != s.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

//构造和赋值
void test01()
{
	set<int> s1;

	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);
	printSet(s1);

	//拷贝构造
	set<int>s2(s1);
	printSet(s2);

	//赋值
	set<int>s3;
	s3 = s2;
	printSet(s3);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* set容器插入数据时用insert
* set容器插入数据的数据会自动排序











#### 3.8.3 set大小和交换

**功能描述：**

* 统计set容器大小以及交换set容器



**函数原型：**

* `size();`          //返回容器中元素的数目
* `empty();`        //判断容器是否为空
* `swap(st);`      //交换两个集合容器



**示例：**

```C++
#include <set>

void printSet(set<int> & s)
{
	for (set<int>::iterator it = s.begin(); it != s.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

//大小
void test01()
{

	set<int> s1;
	
	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);

	if (s1.empty())
	{
		cout << "s1为空" << endl;
	}
	else
	{
		cout << "s1不为空" << endl;
		cout << "s1的大小为： " << s1.size() << endl;
	}

}

//交换
void test02()
{
	set<int> s1;

	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);

	set<int> s2;

	s2.insert(100);
	s2.insert(300);
	s2.insert(200);
	s2.insert(400);

	cout << "交换前" << endl;
	printSet(s1);
	printSet(s2);
	cout << endl;

	cout << "交换后" << endl;
	s1.swap(s2);
	printSet(s1);
	printSet(s2);
}

int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

总结：

* 统计大小   --- size
* 判断是否为空   --- empty
* 交换容器   --- swap

















#### 3.8.4 set插入和删除

**功能描述：**

* set容器进行插入数据和删除数据





**函数原型：**

* `insert(elem);`           //在容器中插入元素。
* `clear();`                    //清除所有元素
* `erase(pos);`              //删除pos迭代器所指的元素，返回下一个元素的迭代器。
* `erase(beg, end);`    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
* `erase(elem);`            //删除容器中值为elem的元素。





**示例：**

```C++
#include <set>

void printSet(set<int> & s)
{
	for (set<int>::iterator it = s.begin(); it != s.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

//插入和删除
void test01()
{
	set<int> s1;
	//插入
	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);
	printSet(s1);

	//删除
	s1.erase(s1.begin());
	printSet(s1);

	s1.erase(30);
	printSet(s1);

	//清空
	//s1.erase(s1.begin(), s1.end());
	s1.clear();
	printSet(s1);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 插入   --- insert
* 删除   --- erase
* 清空   --- clear











#### 3.8.5 set查找和统计

**功能描述：**

* 对set容器进行查找数据以及统计数据



**函数原型：**

* `find(key);`                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
* `count(key);`                //统计key的元素个数





**示例：**

```C++
#include <set>

//查找和统计
void test01()
{
	set<int> s1;
	//插入
	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);
	
	//查找
	set<int>::iterator pos = s1.find(30);

	if (pos != s1.end())
	{
		cout << "找到了元素 ： " << *pos << endl;
	}
	else
	{
		cout << "未找到元素" << endl;
	}

	//统计
	int num = s1.count(30);
	cout << "num = " << num << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 查找   ---  find    （返回的是迭代器）
* 统计   ---  count  （对于set，结果为0或者1）

















#### 3.8.6 set和multiset区别

**学习目标：**

* 掌握set和multiset的区别



**区别：**

* set不可以插入重复数据，而multiset可以
* set插入数据的同时会返回插入结果，表示插入是否成功
* multiset不会检测数据，因此可以插入重复数据





**示例：**

```C++
#include <set>

//set和multiset区别
void test01()
{
	set<int> s;
	pair<set<int>::iterator, bool>  ret = s.insert(10);
	if (ret.second) {
		cout << "第一次插入成功!" << endl;
	}
	else {
		cout << "第一次插入失败!" << endl;
	}

	ret = s.insert(10);
	if (ret.second) {
		cout << "第二次插入成功!" << endl;
	}
	else {
		cout << "第二次插入失败!" << endl;
	}
    
	//multiset
	multiset<int> ms;
	ms.insert(10);
	ms.insert(10);

	for (multiset<int>::iterator it = ms.begin(); it != ms.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 如果不允许插入重复数据可以利用set
* 如果需要插入重复数据利用multiset











#### 3.8.7 pair对组创建

**功能描述：**

* 成对出现的数据，利用对组可以返回两个数据





**两种创建方式：**

* `pair<type, type> p ( value1, value2 );`
* `pair<type, type> p = make_pair( value1, value2 );`





**示例：**

```C++
#include <string>

//对组创建
void test01()
{
	pair<string, int> p(string("Tom"), 20);
	cout << "姓名： " <<  p.first << " 年龄： " << p.second << endl;

	pair<string, int> p2 = make_pair("Jerry", 10);
	cout << "姓名： " << p2.first << " 年龄： " << p2.second << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

两种方式都可以创建对组，记住一种即可













#### 3.8.8 set容器排序

学习目标：

* set容器默认排序规则为从小到大，掌握如何改变排序规则



主要技术点：

* 利用仿函数，可以改变排序规则





**示例一**   set存放内置数据类型

```C++
#include <set>

class MyCompare 
{
public:
	bool operator()(int v1, int v2) {
		return v1 > v2;
	}
};
void test01() 
{    
	set<int> s1;
	s1.insert(10);
	s1.insert(40);
	s1.insert(20);
	s1.insert(30);
	s1.insert(50);

	//默认从小到大
	for (set<int>::iterator it = s1.begin(); it != s1.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;

	//指定排序规则
	set<int,MyCompare> s2;
	s2.insert(10);
	s2.insert(40);
	s2.insert(20);
	s2.insert(30);
	s2.insert(50);

	for (set<int, MyCompare>::iterator it = s2.begin(); it != s2.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：利用仿函数可以指定set容器的排序规则



**示例二** set存放自定义数据类型

```C++
#include <set>
#include <string>

class Person
{
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}

	string m_Name;
	int m_Age;

};
class comparePerson
{
public:
	bool operator()(const Person& p1, const Person &p2)
	{
		//按照年龄进行排序  降序
		return p1.m_Age > p2.m_Age;
	}
};

void test01()
{
	set<Person, comparePerson> s;

	Person p1("刘备", 23);
	Person p2("关羽", 27);
	Person p3("张飞", 25);
	Person p4("赵云", 21);

	s.insert(p1);
	s.insert(p2);
	s.insert(p3);
	s.insert(p4);

	for (set<Person, comparePerson>::iterator it = s.begin(); it != s.end(); it++)
	{
		cout << "姓名： " << it->m_Name << " 年龄： " << it->m_Age << endl;
	}
}
int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

对于自定义数据类型，set必须指定排序规则才可以插入数据











### 3.9 map/ multimap容器

#### 3.9.1 map基本概念

**简介：**

* map中所有元素都是pair
* pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）
* 所有元素都会根据元素的键值自动排序



**本质：**

* map/multimap属于**关联式容器**，底层结构是用二叉树实现。



**优点：**

* 可以根据key值快速找到value值



map和multimap**区别**：

- map不允许容器中有重复key值元素
- multimap允许容器中有重复key值元素




#### 3.9.2  map构造和赋值

**功能描述：**

* 对map容器进行构造和赋值操作

**函数原型：**

**构造：**

* `map<T1, T2> mp;`                     //map默认构造函数: 
* `map(const map &mp);`             //拷贝构造函数



**赋值：**

* `map& operator=(const map &mp);`    //重载等号操作符



**示例：**

```C++
#include <map>

void printMap(map<int,int>&m)
{
	for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
	{
		cout << "key = " << it->first << " value = " << it->second << endl;
	}
	cout << endl;
}

void test01()
{
	map<int,int>m; //默认构造
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(2, 20));
	m.insert(pair<int, int>(3, 30));
	printMap(m);

	map<int, int>m2(m); //拷贝构造
	printMap(m2);

	map<int, int>m3;
	m3 = m2; //赋值
	printMap(m3);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：map中所有元素都是成对出现，插入数据时候要使用对组











#### 3.9.3 map大小和交换

**功能描述：**

* 统计map容器大小以及交换map容器





函数原型：

- `size();`          //返回容器中元素的数目
- `empty();`        //判断容器是否为空
- `swap(st);`      //交换两个集合容器





**示例：**

```C++
#include <map>

void printMap(map<int,int>&m)
{
	for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
	{
		cout << "key = " << it->first << " value = " << it->second << endl;
	}
	cout << endl;
}

void test01()
{
	map<int, int>m;
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(2, 20));
	m.insert(pair<int, int>(3, 30));

	if (m.empty())
	{
		cout << "m为空" << endl;
	}
	else
	{
		cout << "m不为空" << endl;
		cout << "m的大小为： " << m.size() << endl;
	}
}


//交换
void test02()
{
	map<int, int>m;
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(2, 20));
	m.insert(pair<int, int>(3, 30));

	map<int, int>m2;
	m2.insert(pair<int, int>(4, 100));
	m2.insert(pair<int, int>(5, 200));
	m2.insert(pair<int, int>(6, 300));

	cout << "交换前" << endl;
	printMap(m);
	printMap(m2);

	cout << "交换后" << endl;
	m.swap(m2);
	printMap(m);
	printMap(m2);
}

int main() {

	test01();

	test02();

	system("pause");

	return 0;
}
```

总结：

- 统计大小   --- size
- 判断是否为空   --- empty
- 交换容器   --- swap











#### 3.9.4 map插入和删除

**功能描述：**

- map容器进行插入数据和删除数据





**函数原型：**

- `insert(elem);`           //在容器中插入元素。
- `clear();`                    //清除所有元素
- `erase(pos);`              //删除pos迭代器所指的元素，返回下一个元素的迭代器。
- `erase(beg, end);`    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
- `erase(key);`            //删除容器中值为key的元素。



**示例：**

```C++
#include <map>

void printMap(map<int,int>&m)
{
	for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
	{
		cout << "key = " << it->first << " value = " << it->second << endl;
	}
	cout << endl;
}

void test01()
{
	//插入
	map<int, int> m;
	//第一种插入方式
	m.insert(pair<int, int>(1, 10));
	//第二种插入方式
	m.insert(make_pair(2, 20));
	//第三种插入方式
	m.insert(map<int, int>::value_type(3, 30));
	//第四种插入方式
	m[4] = 40; 
	printMap(m);

	//删除
	m.erase(m.begin());
	printMap(m);

	m.erase(3);
	printMap(m);

	//清空
	m.erase(m.begin(),m.end());
	m.clear();
	printMap(m);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* map插入方式很多，记住其一即可

- 插入   --- insert 
- 删除   --- erase
- 清空   --- clear













#### 3.9.5 map查找和统计

**功能描述：**

- 对map容器进行查找数据以及统计数据



**函数原型：**

- `find(key);`                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
- `count(key);`                //统计key的元素个数



**示例：**

```C++
#include <map>

//查找和统计
void test01()
{
	map<int, int>m; 
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(2, 20));
	m.insert(pair<int, int>(3, 30));

	//查找
	map<int, int>::iterator pos = m.find(3);

	if (pos != m.end())
	{
		cout << "找到了元素 key = " << (*pos).first << " value = " << (*pos).second << endl;
	}
	else
	{
		cout << "未找到元素" << endl;
	}

	//统计
	int num = m.count(3);
	cout << "num = " << num << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

- 查找   ---  find    （返回的是迭代器）
- 统计   ---  count  （对于map，结果为0或者1）















#### 3.9.6 map容器排序

**学习目标：**

- map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则





**主要技术点:**

- 利用仿函数，可以改变排序规则





**示例：**

```C++
#include <map>

class MyCompare {
public:
	bool operator()(int v1, int v2) {
		return v1 > v2;
	}
};

void test01() 
{
	//默认从小到大排序
	//利用仿函数实现从大到小排序
	map<int, int, MyCompare> m;

	m.insert(make_pair(1, 10));
	m.insert(make_pair(2, 20));
	m.insert(make_pair(3, 30));
	m.insert(make_pair(4, 40));
	m.insert(make_pair(5, 50));

	for (map<int, int, MyCompare>::iterator it = m.begin(); it != m.end(); it++) {
		cout << "key:" << it->first << " value:" << it->second << endl;
	}
}
int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：

* 利用仿函数可以指定map容器的排序规则
* 对于自定义数据类型，map必须要指定排序规则,同set容器













### 3.10 案例-员工分组

#### 3.10.1 案例描述

* 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作
* 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发
* 随机给10名员工分配部门和工资
* 通过multimap进行信息的插入  key(部门编号) value(员工)
* 分部门显示员工信息





#### 3.10.2 实现步骤

1. 创建10名员工，放到vector中
2. 遍历vector容器，取出每个员工，进行随机分组
3. 分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中
4. 分部门显示员工信息





**案例代码：**

```C++
#include<iostream>
using namespace std;
#include <vector>
#include <string>
#include <map>
#include <ctime>

/*
- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作
- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发
- 随机给10名员工分配部门和工资
- 通过multimap进行信息的插入  key(部门编号) value(员工)
- 分部门显示员工信息
*/

#define CEHUA  0
#define MEISHU 1
#define YANFA  2

class Worker
{
public:
	string m_Name;
	int m_Salary;
};

void createWorker(vector<Worker>&v)
{
	string nameSeed = "ABCDEFGHIJ";
	for (int i = 0; i < 10; i++)
	{
		Worker worker;
		worker.m_Name = "员工";
		worker.m_Name += nameSeed[i];

		worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999
		//将员工放入到容器中
		v.push_back(worker);
	}
}

//员工分组
void setGroup(vector<Worker>&v,multimap<int,Worker>&m)
{
	for (vector<Worker>::iterator it = v.begin(); it != v.end(); it++)
	{
		//产生随机部门编号
		int deptId = rand() % 3; // 0 1 2 

		//将员工插入到分组中
		//key部门编号，value具体员工
		m.insert(make_pair(deptId, *it));
	}
}

void showWorkerByGourp(multimap<int,Worker>&m)
{
	// 0  A  B  C   1  D  E   2  F G ...
	cout << "策划部门：" << endl;

	multimap<int,Worker>::iterator pos = m.find(CEHUA);
	int count = m.count(CEHUA); // 统计具体人数
	int index = 0;
	for (; pos != m.end() && index < count; pos++ , index++)
	{
		cout << "姓名： " << pos->second.m_Name << " 工资： " << pos->second.m_Salary << endl;
	}

	cout << "----------------------" << endl;
	cout << "美术部门： " << endl;
	pos = m.find(MEISHU);
	count = m.count(MEISHU); // 统计具体人数
	index = 0;
	for (; pos != m.end() && index < count; pos++, index++)
	{
		cout << "姓名： " << pos->second.m_Name << " 工资： " << pos->second.m_Salary << endl;
	}

	cout << "----------------------" << endl;
	cout << "研发部门： " << endl;
	pos = m.find(YANFA);
	count = m.count(YANFA); // 统计具体人数
	index = 0;
	for (; pos != m.end() && index < count; pos++, index++)
	{
		cout << "姓名： " << pos->second.m_Name << " 工资： " << pos->second.m_Salary << endl;
	}

}

int main() {

	srand((unsigned int)time(NULL));

	//1、创建员工
	vector<Worker>vWorker;
	createWorker(vWorker);

	//2、员工分组
	multimap<int, Worker>mWorker;
	setGroup(vWorker, mWorker);


	//3、分组显示员工
	showWorkerByGourp(mWorker);

	////测试
	//for (vector<Worker>::iterator it = vWorker.begin(); it != vWorker.end(); it++)
	//{
	//	cout << "姓名： " << it->m_Name << " 工资： " << it->m_Salary << endl;
	//}

	system("pause");

	return 0;
}
```

总结：

* 当数据以键值对形式存在，可以考虑用map 或 multimap







## 4 STL- 函数对象

### 4.1 函数对象

#### 4.1.1 函数对象概念

**概念：**

* 重载**函数调用操作符**的类，其对象常称为**函数对象**
* **函数对象**使用重载的()时，行为类似函数调用，也叫**仿函数**



**本质：**

函数对象(仿函数)是一个**类**，不是一个函数



#### 4.1.2  函数对象使用

**特点：**

* 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
* 函数对象超出普通函数的概念，函数对象可以有自己的状态
* 函数对象可以作为参数传递





**示例:**

```C++
#include <string>

//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
class MyAdd
{
public :
	int operator()(int v1,int v2)
	{
		return v1 + v2;
	}
};

void test01()
{
	MyAdd myAdd;
	cout << myAdd(10, 10) << endl;
}

//2、函数对象可以有自己的状态
class MyPrint
{
public:
	MyPrint()
	{
		count = 0;
	}
	void operator()(string test)
	{
		cout << test << endl;
		count++; //统计使用次数
	}

	int count; //内部自己的状态
};
void test02()
{
	MyPrint myPrint;
	myPrint("hello world");
	myPrint("hello world");
	myPrint("hello world");
	cout << "myPrint调用次数为： " << myPrint.count << endl;
}

//3、函数对象可以作为参数传递
void doPrint(MyPrint &mp , string test)
{
	mp(test);
}

void test03()
{
	MyPrint myPrint;
	doPrint(myPrint, "Hello C++");
}

int main() {

	//test01();
	//test02();
	test03();

	system("pause");

	return 0;
}
```

总结：

* 仿函数写法非常灵活，可以作为参数进行传递。













### 4.2  谓词

#### 4.2.1 谓词概念



**概念：**

* 返回bool类型的仿函数称为**谓词**
* 如果operator()接受一个参数，那么叫做一元谓词
* 如果operator()接受两个参数，那么叫做二元谓词





#### 4.2.2 一元谓词

**示例：**

```C++
#include <vector>
#include <algorithm>

//1.一元谓词
struct GreaterFive{
	bool operator()(int val) {
		return val > 5;
	}
};

void test01() {

	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	vector<int>::iterator it = find_if(v.begin(), v.end(), GreaterFive());
	if (it == v.end()) {
		cout << "没找到!" << endl;
	}
	else {
		cout << "找到:" << *it << endl;
	}

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：参数只有一个的谓词，称为一元谓词











#### 4.2.3 二元谓词

**示例：**

```C++
#include <vector>
#include <algorithm>
//二元谓词
class MyCompare
{
public:
	bool operator()(int num1, int num2)
	{
		return num1 > num2;
	}
};

void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(40);
	v.push_back(20);
	v.push_back(30);
	v.push_back(50);

	//默认从小到大
	sort(v.begin(), v.end());
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
	cout << "----------------------------" << endl;

	//使用函数对象改变算法策略，排序从大到小
	sort(v.begin(), v.end(), MyCompare());
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：参数只有两个的谓词，称为二元谓词

















### 4.3 内建函数对象

#### 4.3.1 内建函数对象意义

**概念：**

* STL内建了一些函数对象



**分类:**

* 算术仿函数

* 关系仿函数

* 逻辑仿函数

**用法：**

* 这些仿函数所产生的对象，用法和一般函数完全相同
* 使用内建函数对象，需要引入头文件 `#include<functional>`







#### 4.3.2 算术仿函数

**功能描述：**

* 实现四则运算
* 其中negate是一元运算，其他都是二元运算



**仿函数原型：**

* `template<class T> T plus<T>`                //加法仿函数
* `template<class T> T minus<T>`              //减法仿函数
* `template<class T> T multiplies<T>`    //乘法仿函数
* `template<class T> T divides<T>`         //除法仿函数
* `template<class T> T modulus<T>`         //取模仿函数
* `template<class T> T negate<T>`           //取反仿函数



**示例：**

```C++
#include <functional>
//negate
void test01()
{
	negate<int> n;
	cout << n(50) << endl;
}

//plus
void test02()
{
	plus<int> p;
	cout << p(10, 20) << endl;
}

int main() {

	test01();
	test02();

	system("pause");

	return 0;
}
```

总结：使用内建函数对象时，需要引入头文件 `#include <functional>`









#### 4.3.3 关系仿函数

**功能描述：**

- 实现关系对比



**仿函数原型：**

* `template<class T> bool equal_to<T>`                    //等于
* `template<class T> bool not_equal_to<T>`            //不等于
* `template<class T> bool greater<T>`                      //大于
* `template<class T> bool greater_equal<T>`          //大于等于
* `template<class T> bool less<T>`                           //小于
* `template<class T> bool less_equal<T>`               //小于等于



**示例：**

```C++
#include <functional>
#include <vector>
#include <algorithm>

class MyCompare
{
public:
	bool operator()(int v1,int v2)
	{
		return v1 > v2;
	}
};
void test01()
{
	vector<int> v;

	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(40);
	v.push_back(20);

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;

	//自己实现仿函数
	//sort(v.begin(), v.end(), MyCompare());
	//STL内建仿函数  大于仿函数
	sort(v.begin(), v.end(), greater<int>());

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：关系仿函数中最常用的就是greater<>大于











#### 4.3.4 逻辑仿函数

**功能描述：**

- 实现逻辑运算



**函数原型：**

* `template<class T> bool logical_and<T>`              //逻辑与
* `template<class T> bool logical_or<T>`                //逻辑或
* `template<class T> bool logical_not<T>`              //逻辑非



**示例：**

```C++
#include <vector>
#include <functional>
#include <algorithm>
void test01()
{
	vector<bool> v;
	v.push_back(true);
	v.push_back(false);
	v.push_back(true);
	v.push_back(false);

	for (vector<bool>::iterator it = v.begin();it!= v.end();it++)
	{
		cout << *it << " ";
	}
	cout << endl;

	//逻辑非  将v容器搬运到v2中，并执行逻辑非运算
	vector<bool> v2;
	v2.resize(v.size());
	transform(v.begin(), v.end(),  v2.begin(), logical_not<bool>());
	for (vector<bool>::iterator it = v2.begin(); it != v2.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：逻辑仿函数实际应用较少，了解即可







## 5 STL- 常用算法



**概述**:

* 算法主要是由头文件`<algorithm>` `<functional>` `<numeric>`组成。



* `<algorithm>`是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等
* `<numeric>`体积很小，只包括几个在序列上面进行简单数学运算的模板函数
* `<functional>`定义了一些模板类,用以声明函数对象。





### 5.1 常用遍历算法

**学习目标：**

* 掌握常用的遍历算法



**算法简介：**

* `for_each`     //遍历容器
* `transform`   //搬运容器到另一个容器中





#### 5.1.1 for_each

**功能描述：**

* 实现遍历容器

**函数原型：**

* `for_each(iterator beg, iterator end, _func);  `

  // 遍历算法 遍历容器元素

  // beg 开始迭代器

  // end 结束迭代器

  // _func 函数或者函数对象



**示例：**

```C++
#include <algorithm>
#include <vector>

//普通函数
void print01(int val) 
{
	cout << val << " ";
}
//函数对象
class print02 
{
 public:
	void operator()(int val) 
	{
		cout << val << " ";
	}
};

//for_each算法基本用法
void test01() {

	vector<int> v;
	for (int i = 0; i < 10; i++) 
	{
		v.push_back(i);
	}

	//遍历算法
	for_each(v.begin(), v.end(), print01);
	cout << endl;

	for_each(v.begin(), v.end(), print02());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握









#### 5.1.2 transform

**功能描述：**

* 搬运容器到另一个容器中

**函数原型：**

* `transform(iterator beg1, iterator end1, iterator beg2, _func);`

//beg1 源容器开始迭代器

//end1 源容器结束迭代器

//beg2 目标容器开始迭代器

//_func 函数或者函数对象



**示例：**

```C++
#include<vector>
#include<algorithm>

//常用遍历算法  搬运 transform

class TransForm
{
public:
	int operator()(int val)
	{
		return val;
	}

};

class MyPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int>v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	vector<int>vTarget; //目标容器

	vTarget.resize(v.size()); // 目标容器需要提前开辟空间

	transform(v.begin(), v.end(), vTarget.begin(), TransForm());

	for_each(vTarget.begin(), vTarget.end(), MyPrint());
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：** 搬运的目标容器必须要提前开辟空间，否则无法正常搬运







### 5.2 常用查找算法

学习目标：

- 掌握常用的查找算法





**算法简介：**

- `find`                     //查找元素
- `find_if`               //按条件查找元素
- `adjacent_find`    //查找相邻重复元素
- `binary_search`    //二分查找法
- `count`                   //统计元素个数
- `count_if`             //按条件统计元素个数




#### 5.2.1 find

**功能描述：**

* 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()



**函数原型：**

- `find(iterator beg, iterator end, value);  `

  // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置

  // beg 开始迭代器

  // end 结束迭代器

  // value 查找的元素





**示例：**

```C++
#include <algorithm>
#include <vector>
#include <string>
void test01() {

	vector<int> v;
	for (int i = 0; i < 10; i++) {
		v.push_back(i + 1);
	}
	//查找容器中是否有 5 这个元素
	vector<int>::iterator it = find(v.begin(), v.end(), 5);
	if (it == v.end()) 
	{
		cout << "没有找到!" << endl;
	}
	else 
	{
		cout << "找到:" << *it << endl;
	}
}

class Person {
public:
	Person(string name, int age) 
	{
		this->m_Name = name;
		this->m_Age = age;
	}
	//重载==
	bool operator==(const Person& p) 
	{
		if (this->m_Name == p.m_Name && this->m_Age == p.m_Age) 
		{
			return true;
		}
		return false;
	}

public:
	string m_Name;
	int m_Age;
};

void test02() {

	vector<Person> v;

	//创建数据
	Person p1("aaa", 10);
	Person p2("bbb", 20);
	Person p3("ccc", 30);
	Person p4("ddd", 40);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	vector<Person>::iterator it = find(v.begin(), v.end(), p2);
	if (it == v.end()) 
	{
		cout << "没有找到!" << endl;
	}
	else 
	{
		cout << "找到姓名:" << it->m_Name << " 年龄: " << it->m_Age << endl;
	}
}
```

总结： 利用find可以在容器中找指定的元素，返回值是**迭代器**













#### 5.2.2 find_if

**功能描述：**

* 按条件查找元素

**函数原型：**

- `find_if(iterator beg, iterator end, _Pred);  `

  // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置

  // beg 开始迭代器

  // end 结束迭代器

  // _Pred 函数或者谓词（返回bool类型的仿函数）



**示例：**

```C++
#include <algorithm>
#include <vector>
#include <string>

//内置数据类型
class GreaterFive
{
public:
	bool operator()(int val)
	{
		return val > 5;
	}
};

void test01() {

	vector<int> v;
	for (int i = 0; i < 10; i++) {
		v.push_back(i + 1);
	}

	vector<int>::iterator it = find_if(v.begin(), v.end(), GreaterFive());
	if (it == v.end()) {
		cout << "没有找到!" << endl;
	}
	else {
		cout << "找到大于5的数字:" << *it << endl;
	}
}

//自定义数据类型
class Person {
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}
public:
	string m_Name;
	int m_Age;
};

class Greater20
{
public:
	bool operator()(Person &p)
	{
		return p.m_Age > 20;
	}

};

void test02() {

	vector<Person> v;

	//创建数据
	Person p1("aaa", 10);
	Person p2("bbb", 20);
	Person p3("ccc", 30);
	Person p4("ddd", 40);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	vector<Person>::iterator it = find_if(v.begin(), v.end(), Greater20());
	if (it == v.end())
	{
		cout << "没有找到!" << endl;
	}
	else
	{
		cout << "找到姓名:" << it->m_Name << " 年龄: " << it->m_Age << endl;
	}
}

int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略















#### 5.2.3 adjacent_find

**功能描述：**

* 查找相邻重复元素



**函数原型：**

- `adjacent_find(iterator beg, iterator end);  `

  // 查找相邻重复元素,返回相邻元素的第一个位置的迭代器

  // beg 开始迭代器

  // end 结束迭代器

  



**示例：**

```C++
#include <algorithm>
#include <vector>

void test01()
{
	vector<int> v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(5);
	v.push_back(2);
	v.push_back(4);
	v.push_back(4);
	v.push_back(3);

	//查找相邻重复元素
	vector<int>::iterator it = adjacent_find(v.begin(), v.end());
	if (it == v.end()) {
		cout << "找不到!" << endl;
	}
	else {
		cout << "找到相邻重复元素为:" << *it << endl;
	}
}
```

总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法









#### 5.2.4 binary_search

**功能描述：**

* 查找指定元素是否存在



**函数原型：**

- `bool binary_search(iterator beg, iterator end, value);  `

  // 查找指定的元素，查到 返回true  否则false

  // 注意: 在**无序序列中不可用**

  // beg 开始迭代器

  // end 结束迭代器

  // value 查找的元素





**示例：**

```C++
#include <algorithm>
#include <vector>

void test01()
{
	vector<int>v;

	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}
	//二分查找
	bool ret = binary_search(v.begin(), v.end(),2);
	if (ret)
	{
		cout << "找到了" << endl;
	}
	else
	{
		cout << "未找到" << endl;
	}
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列









#### 5.2.5 count

**功能描述：**

* 统计元素个数



**函数原型：**

- `count(iterator beg, iterator end, value);  `

  // 统计元素出现次数

  // beg 开始迭代器

  // end 结束迭代器

  // value 统计的元素





**示例：**

```C++
#include <algorithm>
#include <vector>

//内置数据类型
void test01()
{
	vector<int> v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(4);
	v.push_back(5);
	v.push_back(3);
	v.push_back(4);
	v.push_back(4);

	int num = count(v.begin(), v.end(), 4);

	cout << "4的个数为： " << num << endl;
}

//自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}
	bool operator==(const Person & p)
	{
		if (this->m_Age == p.m_Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	string m_Name;
	int m_Age;
};

void test02()
{
	vector<Person> v;

	Person p1("刘备", 35);
	Person p2("关羽", 35);
	Person p3("张飞", 35);
	Person p4("赵云", 30);
	Person p5("曹操", 25);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);
    
    Person p("诸葛亮",35);

	int num = count(v.begin(), v.end(), p);
	cout << "num = " << num << endl;
}
int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

**总结：** 统计自定义数据类型时候，需要配合重载 `operator==`

















#### 5.2.6 count_if

**功能描述：**

* 按条件统计元素个数

**函数原型：**

- `count_if(iterator beg, iterator end, _Pred);  `

  // 按条件统计元素出现次数

  // beg 开始迭代器

  // end 结束迭代器

  // _Pred 谓词

  

**示例：**

```C++
#include <algorithm>
#include <vector>

class Greater4
{
public:
	bool operator()(int val)
	{
		return val >= 4;
	}
};

//内置数据类型
void test01()
{
	vector<int> v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(4);
	v.push_back(5);
	v.push_back(3);
	v.push_back(4);
	v.push_back(4);

	int num = count_if(v.begin(), v.end(), Greater4());

	cout << "大于4的个数为： " << num << endl;
}

//自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}

	string m_Name;
	int m_Age;
};

class AgeLess35
{
public:
	bool operator()(const Person &p)
	{
		return p.m_Age < 35;
	}
};
void test02()
{
	vector<Person> v;

	Person p1("刘备", 35);
	Person p2("关羽", 35);
	Person p3("张飞", 35);
	Person p4("赵云", 30);
	Person p5("曹操", 25);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);

	int num = count_if(v.begin(), v.end(), AgeLess35());
	cout << "小于35岁的个数：" << num << endl;
}


int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

**总结：**按值统计用count，按条件统计用count_if













### 5.3 常用排序算法

**学习目标：**

- 掌握常用的排序算法

**算法简介：**

- `sort`             //对容器内元素进行排序
- `random_shuffle`   //洗牌   指定范围内的元素随机调整次序
- `merge `           // 容器元素合并，并存储到另一容器中
- `reverse`       // 反转指定范围的元素





#### 5.3.1 sort

**功能描述：**

* 对容器内元素进行排序





**函数原型：**

- `sort(iterator beg, iterator end, _Pred);  `

  // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置

  //  beg    开始迭代器

  //  end    结束迭代器

  // _Pred  谓词





**示例：**

```c++
#include <algorithm>
#include <vector>

void myPrint(int val)
{
	cout << val << " ";
}

void test01() {
	vector<int> v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(20);
	v.push_back(40);

	//sort默认从小到大排序
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint);
	cout << endl;

	//从大到小排序
	sort(v.begin(), v.end(), greater<int>());
	for_each(v.begin(), v.end(), myPrint);
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**sort属于开发中最常用的算法之一，需熟练掌握













#### 5.3.2 random_shuffle

**功能描述：**

* 洗牌   指定范围内的元素随机调整次序



**函数原型：**

- `random_shuffle(iterator beg, iterator end);  `

  // 指定范围内的元素随机调整次序

  // beg 开始迭代器

  // end 结束迭代器

  

**示例：**

```c++
#include <algorithm>
#include <vector>
#include <ctime>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	srand((unsigned int)time(NULL));
	vector<int> v;
	for(int i = 0 ; i < 10;i++)
	{
		v.push_back(i);
	}
	for_each(v.begin(), v.end(), myPrint());
	cout << endl;

	//打乱顺序
	random_shuffle(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**random_shuffle洗牌算法比较实用，使用时记得加随机数种子















#### 5.3.3 merge

**功能描述：**

* 两个容器元素合并，并存储到另一容器中



**函数原型：**

- `merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  `

  // 容器元素合并，并存储到另一容器中

  // 注意: 两个容器必须是**有序的**

  // beg1   容器1开始迭代器
  // end1   容器1结束迭代器
  // beg2   容器2开始迭代器
  // end2   容器2结束迭代器
  // dest    目标容器开始迭代器

  

**示例：**

```c++
#include <algorithm>
#include <vector>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v1;
	vector<int> v2;
	for (int i = 0; i < 10 ; i++) 
    {
		v1.push_back(i);
		v2.push_back(i + 1);
	}

	vector<int> vtarget;
	//目标容器需要提前开辟空间
	vtarget.resize(v1.size() + v2.size());
	//合并  需要两个有序序列
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());
	for_each(vtarget.begin(), vtarget.end(), myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**merge合并的两个容器必须的有序序列











#### 5.3.4 reverse

**功能描述：**

* 将容器内元素进行反转



**函数原型：**

- `reverse(iterator beg, iterator end);  `

  // 反转指定范围的元素

  // beg 开始迭代器

  // end 结束迭代器

  

**示例：**

```c++
#include <algorithm>
#include <vector>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(50);
	v.push_back(20);
	v.push_back(40);

	cout << "反转前： " << endl;
	for_each(v.begin(), v.end(), myPrint());
	cout << endl;

	cout << "反转后： " << endl;

	reverse(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**reverse反转区间内元素，面试题可能涉及到









### 5.4 常用拷贝和替换算法

**学习目标：**

- 掌握常用的拷贝和替换算法

**算法简介：**

- `copy`                      // 容器内指定范围的元素拷贝到另一容器中
- `replace`                // 将容器内指定范围的旧元素修改为新元素
- `replace_if `          // 容器内指定范围满足条件的元素替换为新元素
- `swap`                     // 互换两个容器的元素




#### 5.4.1 copy

**功能描述：**

* 容器内指定范围的元素拷贝到另一容器中



**函数原型：**

- `copy(iterator beg, iterator end, iterator dest);  `

  // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置

  // beg  开始迭代器

  // end  结束迭代器

  // dest 目标起始迭代器



**示例：**

```c++
#include <algorithm>
#include <vector>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++) {
		v1.push_back(i + 1);
	}
	vector<int> v2;
	v2.resize(v1.size());
	copy(v1.begin(), v1.end(), v2.begin());

	for_each(v2.begin(), v2.end(), myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间















#### 5.4.2 replace

**功能描述：**

* 将容器内指定范围的旧元素修改为新元素



**函数原型：**

- `replace(iterator beg, iterator end, oldvalue, newvalue);  `

  // 将区间内旧元素 替换成 新元素

  // beg 开始迭代器

  // end 结束迭代器

  // oldvalue 旧元素

  // newvalue 新元素



**示例：**

```c++
#include <algorithm>
#include <vector>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v;
	v.push_back(20);
	v.push_back(30);
	v.push_back(20);
	v.push_back(40);
	v.push_back(50);
	v.push_back(10);
	v.push_back(20);

	cout << "替换前：" << endl;
	for_each(v.begin(), v.end(), myPrint());
	cout << endl;

	//将容器中的20 替换成 2000
	cout << "替换后：" << endl;
	replace(v.begin(), v.end(), 20,2000);
	for_each(v.begin(), v.end(), myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**replace会替换区间内满足条件的元素













#### 5.4.3 replace_if

**功能描述:**  

* 将区间内满足条件的元素，替换成指定元素



**函数原型：**

- `replace_if(iterator beg, iterator end, _pred, newvalue);  `

  // 按条件替换元素，满足条件的替换成指定元素

  // beg 开始迭代器

  // end 结束迭代器

  // _pred 谓词

  // newvalue 替换的新元素



**示例：**

```c++
#include <algorithm>
#include <vector>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

class ReplaceGreater30
{
public:
	bool operator()(int val)
	{
		return val >= 30;
	}

};

void test01()
{
	vector<int> v;
	v.push_back(20);
	v.push_back(30);
	v.push_back(20);
	v.push_back(40);
	v.push_back(50);
	v.push_back(10);
	v.push_back(20);

	cout << "替换前：" << endl;
	for_each(v.begin(), v.end(), myPrint());
	cout << endl;

	//将容器中大于等于的30 替换成 3000
	cout << "替换后：" << endl;
	replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);
	for_each(v.begin(), v.end(), myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件







#### 5.4.4 swap

**功能描述：**

* 互换两个容器的元素



**函数原型：**

- `swap(container c1, container c2);  `

  // 互换两个容器的元素

  // c1容器1

  // c2容器2

  

**示例：**

```c++
#include <algorithm>
#include <vector>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v1;
	vector<int> v2;
	for (int i = 0; i < 10; i++) {
		v1.push_back(i);
		v2.push_back(i+100);
	}

	cout << "交换前： " << endl;
	for_each(v1.begin(), v1.end(), myPrint());
	cout << endl;
	for_each(v2.begin(), v2.end(), myPrint());
	cout << endl;

	cout << "交换后： " << endl;
	swap(v1, v2);
	for_each(v1.begin(), v1.end(), myPrint());
	cout << endl;
	for_each(v2.begin(), v2.end(), myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**swap交换容器时，注意交换的容器要同种类型













### 5.5 常用算术生成算法

**学习目标：**

- 掌握常用的算术生成算法



**注意：**

* 算术生成算法属于小型算法，使用时包含的头文件为 `#include <numeric>`



**算法简介：**

- `accumulate`      // 计算容器元素累计总和

- `fill`                 // 向容器中添加元素

  

#### 5.5.1 accumulate

**功能描述：**

*  计算区间内 容器元素累计总和



**函数原型：**

- `accumulate(iterator beg, iterator end, value);  `

  // 计算容器元素累计总和

  // beg 开始迭代器

  // end 结束迭代器

  // value 起始值



**示例：**

```c++
#include <numeric>
#include <vector>
void test01()
{
	vector<int> v;
	for (int i = 0; i <= 100; i++) {
		v.push_back(i);
	}

	int total = accumulate(v.begin(), v.end(), 0);

	cout << "total = " << total << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**accumulate使用时头文件注意是 numeric，这个算法很实用



#### 5.5.2 fill

**功能描述：**

* 向容器中填充指定的元素



**函数原型：**

- `fill(iterator beg, iterator end, value);  `

  // 向容器中填充元素

  // beg 开始迭代器

  // end 结束迭代器

  // value 填充的值



**示例：**

```c++
#include <numeric>
#include <vector>
#include <algorithm>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{

	vector<int> v;
	v.resize(10);
	//填充
	fill(v.begin(), v.end(), 100);

	for_each(v.begin(), v.end(), myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：**利用fill可以将容器区间内元素填充为 指定的值





### 5.6 常用集合算法

**学习目标：**

- 掌握常用的集合算法



**算法简介：**

- `set_intersection`          // 求两个容器的交集

- `set_union`                       // 求两个容器的并集

- `set_difference `              // 求两个容器的差集

  



#### 5.6.1 set_intersection

**功能描述：**

* 求两个容器的交集



**函数原型：**

- `set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  `

  // 求两个集合的交集

  // **注意:两个集合必须是有序序列**

  // beg1 容器1开始迭代器
  // end1 容器1结束迭代器
  // beg2 容器2开始迭代器
  // end2 容器2结束迭代器
  // dest 目标容器开始迭代器



**示例：**

```C++
#include <vector>
#include <algorithm>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v1;
	vector<int> v2;
	for (int i = 0; i < 10; i++)
    {
		v1.push_back(i);
		v2.push_back(i+5);
	}

	vector<int> vTarget;
	//取两个里面较小的值给目标容器开辟空间
	vTarget.resize(min(v1.size(), v2.size()));

	//返回目标容器的最后一个元素的迭代器地址
	vector<int>::iterator itEnd = 
        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

	for_each(vTarget.begin(), itEnd, myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：** 

* 求交集的两个集合必须的有序序列
* 目标容器开辟空间需要从**两个容器中取小值**
* set_intersection返回值既是交集中最后一个元素的位置













#### 5.6.2 set_union

**功能描述：**

* 求两个集合的并集



**函数原型：**

- `set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  `

  // 求两个集合的并集

  // **注意:两个集合必须是有序序列**

  // beg1 容器1开始迭代器
  // end1 容器1结束迭代器
  // beg2 容器2开始迭代器
  // end2 容器2结束迭代器
  // dest 目标容器开始迭代器

  

**示例：**

```C++
#include <vector>
#include <algorithm>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v1;
	vector<int> v2;
	for (int i = 0; i < 10; i++) {
		v1.push_back(i);
		v2.push_back(i+5);
	}

	vector<int> vTarget;
	//取两个容器的和给目标容器开辟空间
	vTarget.resize(v1.size() + v2.size());

	//返回目标容器的最后一个元素的迭代器地址
	vector<int>::iterator itEnd = 
        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

	for_each(vTarget.begin(), itEnd, myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：** 

- 求并集的两个集合必须的有序序列
- 目标容器开辟空间需要**两个容器相加**
- set_union返回值既是并集中最后一个元素的位置








#### 5.6.3  set_difference

**功能描述：**

* 求两个集合的差集



**函数原型：**

- `set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  `

  // 求两个集合的差集

  // **注意:两个集合必须是有序序列**

  // beg1 容器1开始迭代器
  // end1 容器1结束迭代器
  // beg2 容器2开始迭代器
  // end2 容器2结束迭代器
  // dest 目标容器开始迭代器

  

**示例：**

```C++
#include <vector>
#include <algorithm>

class myPrint
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v1;
	vector<int> v2;
	for (int i = 0; i < 10; i++) {
		v1.push_back(i);
		v2.push_back(i+5);
	}

	vector<int> vTarget;
	//取两个里面较大的值给目标容器开辟空间
	vTarget.resize( max(v1.size() , v2.size()));

	//返回目标容器的最后一个元素的迭代器地址
	cout << "v1与v2的差集为： " << endl;
	vector<int>::iterator itEnd = 
        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, myPrint());
	cout << endl;


	cout << "v2与v1的差集为： " << endl;
	itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, myPrint());
	cout << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

**总结：** 

- 求差集的两个集合必须的有序序列
- 目标容器开辟空间需要从**两个容器取较大值**
- set_difference返回值既是差集中最后一个元素的位置

# C语言

## 1 关键字

### 1.1 volatile关键字

定义：	提醒编译器它后面所定义的变量随时都有可能变化，与该变量有关的操作，不要进行优化，以免出错;
用处：	

(1)并行设备的硬件寄存器(状态寄存器、控制寄存器)通常加volatile，因为寄存器随时可以被外设硬件修改;
(2)中断服务程序中修改的供其它程序检测的变量，需要加volatile；
(3)多任务环境下各任务间共享的变量，应该加volatile；

```c
XBYTE[2]=0x55;
XBYTE[2]=0x56;
XBYTE[2]=0x57;
XBYTE[2]=0x58;	
```

​	  对外部硬件而言，上述四条语句分别表示不同的操作，会产生四种不同的动作，但是编译器却会对上述四条语句进行优化，认为只有

```c
XBYTE[2]=0x58
```

（即忽略前三条语句，只产生一条机器代码）。如果键入volatile，编译器会逐一的进行编译并产生相应的机器代码（产生四条代码）。  

常见问题	

(1)一个参数可以即是const还是volatile吗?			可以，例如只读的状态寄存器，可能被意想不到改变，同时程序也不应该修改它
(2)一个指针可以是volatile吗?								 可以，当一个中断服务子程序修改一个指向buffer的指针时

### 1.2 const关键字

作用：	 

(1)定义变量未常量

(2)修饰函数的参数，表示在函数体内不能修改这个参数

(3)修饰函数的返回值；若修饰的返回值类型为指针p，那么*p不能被修改，但是p中存的地址可以改(p指向可改)，同时需要用const修饰的指针接收
		 (4)节省空间，避免不必要的内存分配
用处：	 

(1)修饰一般常量

(2)修饰常数组

(3)修饰常对象

(4)修饰常指针

### 1.3 static关键字

作用	

(1)在函数体内，静态变量只会被初始化一次

(2)在模块内，函数体外，静态变量可被模块内所有函数使用，但不能被模块外其他函数访问

(3)在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用
​

在C语言中，为什么 static变量只初始化一次？
​		

​		对于所有的对象（不仅仅是静态对象），初始化都只有一次，而由于静态变量具有“记忆”功能，初始化后，一直都没有被销毁，都会保存在内存区域中，所以不会再次初始化。
​		存放在静态区的变量的生命周期一般比较长，它与整个程序“同生死、共存亡”，所以它只需初始化一次。而auto变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁。

### 1.4 new/delete与malloc/free的区别

**（new释放数组空间时，需要delete[] arr //加个[]）

(1) malloc和free是函数，new和delete是操作符

(2) malloc申请的空间不会初始化，new可以初始化

(3) malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可。

(4) malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型。

(5) malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常。

(6) 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理。

### 1.5 strlen与sizeof

strlen("\0") =0，sizeof("\0")=2。
		strlen用来计算字符串的长度（在C/C++中，字符串是以"\0"作为结束符的），它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描直到碰到第一个字符串结束符\0为止，然后返回计数器值
		sizeof是C语言的关键字，它以字节的形式给出了其操作数的存储大小，操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型决定。

### 1.6 不使用 sizeof 如何求int占用的字节数？	

取地址然后相减

### 1.7 struct与 union的区别

struct（结构体）与 union（联合体）是C语言中两种不同的数据结构，两者都是常见的复合结构，其区别主要表现在以下两个方面。

		1. 结构体与联合体虽然都是由多个不同的数据类型成员组成的，但一个联合型变量的长度等于其最长的成员的长度，而结构体变量长度需要累加并且要考虑字节对齐。
		
		2. 对于联合体的不同成员赋值，将会对它的其他成员重写，原来成员的值就不存在了，而对结构体的不同成员赋值是互不影响的。

### 1.8 左值和右值

​		左值是指可以出现在等号左边的变量或表达式，它最重要的特点就是可写（可寻址）。

​		也就是说，它的值可以被修改，如果一个变量或表达式的值不能被修改，那么它就不能作为左值。

​		右值是指只可以出现在等号右边的变量或表达式。它最重要的特点是可读。一般的使用场景都是把一个右值赋值给一个左值。

​		通常，左值可以作为右值，但是右值不一定是左值。

### 1.9 短路计算

​		对于&&操作，如果两个表达式中有一个为假则整个表达式的值都为假，不用执行后一个表达式，整体判断肯定都为假；

​		对于||操作，若两个表达式中有一个为真，不用执行后一个表达式，整体判断肯定都为真；

## 2 内存

### 2.1 内存分配方式

(1) 静态存储区分配		程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。

(2) 栈上分配		函数执行时，函数内的局部变量的存储单元在栈上创建，函数执行结束时这些存储单元自动释放。

(3) 堆上分配		程序在运行时用malloc或者new申请内存，程序员自己用free或者delete释放，动态内存的生存期由我们自己决定。

### 2.2 堆与栈区别

申请方式：	

栈的空间由操作系统自动分配/释放，堆上的空间手动分配/释放。

申请大小的限制：		

​			栈空间有限。在windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域，栈顶地址和栈的最大容量是系统预先设定好的，若申请的空间超出栈剩余空间，则会溢出
​			堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向
​			是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

申请效率：		

栈由系统自动分配，速度较快。但程序员是无法控制的。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便

### 2.3 栈的作用

(1)C语言中栈用来存储临时变量，临时变量包括函数参数和函数内部定义的临时变量。

(2)多线程编程的基础是栈，栈是多线程编程的基石，每一个线程都最少有一个自己专属的栈。

### 2.4 函数参数压栈顺序		

从右至左；第一个参数最后放入栈顶，方便使用；若参数是可变参数，第一个参数表示可变参数数量，放在栈顶方便确定数量

### 2.5 内存管理			

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。
				

```c
		代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

​		数据段：存储程序中已初始化的全局变量和静态变量

​		BSS 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。

​		堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

​		映射区:存储动态链接库以及调用mmap函数进行的文件映射

​		栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

​		BSS段+数据段又称全局段/静态段
```

2.6 内存泄漏				

内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问，而系统也不能再次将它分配给需要的程序。 
什么是内存溢出？						内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。
如何判断内存泄漏？				

1. 良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄露。

   2.将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

   3. Boost 中的smart pointer。
   4. 一些常见的工具插件，如ccmalloc、Dmalloc、Leaky等等

## 3 指针

### 3.1 数组名和指针的区别与联系		



```
1.数据保存:
	指针保存的是地址（保存目标数据地址，自身地址由编译器分配），内存访问偏移量为4个字节，无论其中保存的是何种数据均已地址类型进行解析。
	
	数组名表示的是第一个元素的地址，内存偏移量是保存数据类型的内存偏移量；只有对数组名取地址（&数组名）时数组名才表示整个数组，内存偏移量是整个数组的大小（sizeof(数组名)）。

2.数据访问方面
    指针对数据的访问方式是间接访问，需要用到解引用符号（*数组名）。
    数组对数据的访问则是直接访问，可通过下标访问或数组名+元素偏移量的方式
             			
3. 使用环境
    指针多用于动态数据结构（如链表，等等）和动态内存开辟。
    数组多用于存储固定个数且类型统一的数据结构（如线性表等等）和隐式分配。
```



### 3.2 指针常量，常量指针，指向常量的常量指针

​					

```c
1. 指针常量		 
    int * const p
    //先看const再看 * ，p是一个常量类型的指针，不能修改这个指针的指向，但是这个指针所指向的地址上存储的值可以修改。
2. 常量指针		
    const int *p
	int const *p
    //先看*再看const，定义一个指针指向一个常量，不能通过指针来修改这个指针指向的值
3. 指向常量的常量指针
     const int *const p
    //对于“指向常量的常量指针”，就必须同时满足上述1和2中的内容，既不可以修改指针的值，也不可以修改指针指向的值。
```

### 3.3 指针和引用的异同与转换

​					

```c
相同			
		1. 都是地址的概念，指针指向某一内存、它的内容是所指内存的地址；引用则是某块内存的别名。
		2. 从内存分配上看：两者都占内存，程序为指针会分配内存，一般是4个字节；而引用的本质是指针常量，指向对象不能变，但指向对象的值可以变。
		两者都是地址概念，所以本身都会占用内存。

区别
		1. 指针是实体，而引用是别名。
		2. 指针和引用的自增（++）运算符意义不同，指针是对内存地址自增，而引用是对值的自增。
		3. 引用使用时无需解引用(*)，指针需要解引用；（关于解引用大家可以看看这篇博客，传送门）。
		4. 引用只能在定义时被初始化一次，之后不可变；指针可变。
		5. 引用不能为空，指针可以为空。
		6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小，在32位系统指针变量一般占用4字节内存
		#include "stdio.h"
			int main(){
					int x = 5;
					int *p = &x;
					int &q = x;
					printf("%d %d\n",*p,sizeof(p));
					printf("%d %d\n",q,sizeof(q));
					}
					//结果
					5 8
					5 4
转换			
		指针转引用：把指针用*就可以转换成对象，可以用在引用参数当中。
		引用转指针：把引用类型的对象用&取地址就获得指针了
        int a = 5;
		int *p = &a;
		void fun(int &x){}//此时调用fun可使用 ： fun（*p）;
		//p是指针，加个*号后可以转换成该指针指向的对象，此时fun的形参是一个引用值,
		//p指针指向的对象会转换成引用X
```

### 3.4  野指针				

```c
1. 野指针是指向不可用内存的指针，当指针被创建时，指针不可能自动指向NULL，这时，默认值是随机的，此时的指针成为野指针。

2. 当指针被free或delete释放掉时，如果没有把指针设置为NULL，则会产生野指针，因为释放掉的仅仅是指针指向的内存，并没有把指针本身释放掉。
      					
3. 第三个造成野指针的原因是指针操作超越了变量的作用范围。
              
如何避免野指针？

1. 对指针进行初始化。
//将指针初始化为NULL。
char * p = NULL;
//用malloc分配内存
char * p = (char * )malloc(sizeof(char));
//用已有合法的可访问的内存地址对指针初始化
char num[ 30] = {0};
char *p = num;

2. 指针用完后释放内存，将指针赋NULL。
delete(p);
p = NULL;
```



### 3.5 智能指针			

1.智能指针是一个类，用来存储指针(指向动态分配对象的指针)，方便进行堆内存管理。

2.智能指针的内存泄漏如何解决？
					为了解决循环引用导致的内存泄漏，引入了弱指针 weak_ptr ， weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，
					但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

3.补充指针：
NULL指针
					NULL用于指示指针未指向有效位置。理想情况下，如果在声明时不知道指针的值，则应将指针初始化为NULL。
					当由它指向的内存在程序中间被释放时，我们应该使指针为NULL。

悬空指针
					悬空指针是没有指向正确内存位置的指针。当删除或释放对象时，如果不修改指针的值或者不置为NULL，就会出现悬空指针。
					这时这个指针指向的内存可能被分配给了其他变量就会造成错误。所以是比较危险的。

野指针
					就是只声明没有被初始化过的指针，他可能指向任何内存。

指针常量与常量指针

```c
int * const p //指针常量：指针在前，常量在后，这个p只能指向一个位置，而不能指向其他位置。指向的变量值可以改变。
const int *p = &a; //常量指针 ： 常量在前，指针在后，指向的变量值不能改变，但是可以改变这个指针指向的位置。
```

指针与指针变量的区别

指针：内存中每⼀个字节都会分配编号，这个编号就是地址, ⽽指针就是内存单元的编号。一个变量的地址就称为该变量的指针他保存的是一个地址。
指针变量：c语言有很多种变量，每种变量都会储存一种数据，而指针变量就是专门来储存指针的变量，本质是变量 只是该变量存放的是空间的地址编号
二级指针：指针本身也是一个变量，也要占用内存空间，而二级指针就是指向这块变量的指针。一般二级指针用在二维数组中。
int *p;
p=&a;
//int *p就是指针变量；对a取地址，p就是一个指针用来保存地址。

## 4 预处理

### 4.1 预处理器标识#error的目的

#error预处理指令的作用是，编译程序时，只要遇到#error就会生成一个编译错误提示消息，并停止编译。其语法格式为：#error error-message。

### 4.2 #define和const差别			

2.const常量有数据类型，而 define常量没有数据类型。编译器可以对 const常量进行类型安全检査，如类型、语句结构等，而 define不行。

3.很多IDE支持调试 const定义的常量，而不支持 define定义的常量由于 const修饰的变量可以排除程序之间的不安全性因素，保护程序中的常量不被修改，而且对数据类型也会进行相应的检查，极大地提高了程序的健壮性，所以一般更加倾向于用const来定义常量类型

### 4.3 typedef和 define区别			

typedef与 define都是替一个对象取一个别名，以此来增强程序的可读性，但是它们在使用和作用上也存在着以下4个方面的不同。

1. 原理不同
   					#define是C语言中定义的语法，它是预处理指令，在预处理时进行简单而机械的字符串替换，不做正确性检査，不管含义是否正确照样代入，只有在编译已被展开的源程序时，才会发现可能的错误并报错
   2. 功能不同
      			typedef用来定义类型的别名，这些类型不仅包含内部类型（int、char等），还包括自定义类型（如struct），可以起到使类型易于记忆的功能。
      3. 作用域不同
         					#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef有自己的作用域。

### 4.4  include< filename. h>和# include" filename. h"区别

​					对于 include< filename. h>，编译器先从标准库路径开始搜索 filename.h，使得系统文件调用较快。

​					对于# include“ filename.h"，编译器先从用户的工作路径开始搜索 filename.h，然后去寻找系统路径，使得自定义文件较快。

### 4.5 头文件的作用			

1. 通过头文件来调用库功能。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口是怎么实现的。编译器会从库中提取相应的代码。

2. 头文件能加强类型安全检查。当某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，大大减轻程序员调试、改错的负担

### 4.6 在头文件中定义静态变量

不可行，如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误。因为如果在使用了该头文件的每个C语言文件中定义静态变量，按照编译的步骤，在每个头文件中都会单独存在一个静态变量，从而会引起空间浪费或者程序错误所以，不推荐在头文件中定义任何变量，当然也包括静态变量

### 4.7 #include<> 与#include " "区别

include<>到系统指定⽬录寻找头⽂件，#include ""先到项⽬所在⽬录寻找头⽂件，如果没有找再到系统指定的⽬录下寻找

### 4.8 ifndef/define/endif 的作用

防止头文件被重复包含和编译。 头文件重复包含会增大程序大小，重复编译增加编译时间

### 4.9 宏与内联区别

内联函数在编译时展开，宏在预处理时展开；
内联函数直接嵌入到目标代码中，宏是简单的做文本替换；
内联函数有类型检测、语法判断等功能，而宏没有；
内联函数是函数，宏不是；

## 5 变量

### 5.1 全局变量和静态变量的区别		

1.全局变量的作用域为程序块，而局部变量的作用域为当前函数。

2.内存存储方式不同，全局变量（静态全局变量，静态局部变量）分配在全局数据区（静态存储空间），后者分配在栈区。

3.生命周期不同。全局变量随主程序创建而创建，随主程序销毁而销毁，局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在了。

4.使用方式不同。通过声明为全局变量，程序的各个部分都可以用到，而局部变量只能在局部使用。

### 5.2 全局变量是否可以被多个.C文件包含的头文件中		

可以，在不同的C文件中以static形式来声明同名全局变量。

可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。

### 5.3 局部变量能否和全局变量重名			

能，局部会屏蔽全局。

局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。

对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。

### 5.4 析构函数必须是虚函数

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

### 5.5 默认的析构函数不是虚函数

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。

而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。

因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

### 5.6 析构函数的作用

如果构造函数打开了一个文件，最后不需要使用时文件就要被关闭。析构函数允许类自动完成类似清理工作，不必调用其他成员函数。

析构函数也是特殊的类成员函数。简单来说，析构函数与构造函数的作用正好相反，它用来完成对象被删除前的一些清理工作，也就是专门的扫尾工作。

### 5.7 静态函数和虚函数的区别

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。

### 5.8.重载和覆盖的区别

```
1. 覆盖是子类和父类之间的关系，垂直关系；重载同一个类之间方法之间的关系，是水平关系。
2. 覆盖只能由一个方法或者只能由一对方法产生关系；重载是多个方法之间的关系。
3. 覆盖是根据对象类型（对象对应存储空间类型）来决定的；而重载关系是根据调用的实参表和形参表来选择方法体的。
```



### 5.9 虚函数表实现运行时多态

原理：

虚函数表是一个类的虚函数的地址表，每个对象在创建时，都会有一个指针指向该类虚函数表，每一个类的虚函数表，按照函数声明的顺序，会将函数地址存在虚函数表中，当子类对象重写父类的虚函数的时候，父类的虚函数表中对应的位置会被子类的虚函数地址覆盖。

作用：
在用父类的指针调用子类对象成员函数时，虚函数表会指明要调用的具体函数是哪个。

### 5.10 函数调用

大多数CPU上的程序实现使用栈来支持函数调用操作，栈被用来传递函数参数、存储返回信息、临时保存寄存器原有的值以备恢复以及用来存储局部变量。

函数调用操作所使用的栈部分叫做栈帧结构，每个函数调用都有属于自己的栈帧结构，栈帧结构由两个指针指定，帧指针（指向起始），栈指针（指向栈顶），函数对大多数数据的访问都是基于帧指针。

栈指针和帧指针一般都有专门的寄存器，通常使用ebp寄存器作为帧指针，使用esp寄存器做栈指针。

帧指针指向栈帧结构的头，存放着上一个栈帧的头部地址，栈指针指向栈顶。

### 5.11 fork,wait,exec函数

父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存;

exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.

调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1。

## 6 数组

### 6.1.表达式含义	

```c
*(a[1]+1)				a[1]是第2行的地址，a[1]+1偏移一个单位（得到第2行第2列的地址），然后解引用取值，得到 a[1][1] ；
*(&a[1][1])				[]优先级高，a[1][1]取地址再取值。
(*(a+1))[1]				a+1相当于&a[1]，所以* (a+1）=a[1]，因此*（a+1）[1]=a[1]
```

### 6.2 数组下标为负数			

下标只是给出了一个与当前地址的偏移量而已，只要根据这个偏移量能定位得到目标地址即可

### 6.3 数组名作为类型、作为地址、对数组名取地址的区别

```c
数组名作为类型：代表的是整个数组的⼤⼩
数组名作为地址：代表的是数组⾸元素的地址
对数组名取地址：代表的是数组的⾸地址

数组首地址与数组首元素地址
    
char arr[]={‘1’,‘2’,‘3’,‘4’,‘5’,‘6’};
char * b = arr; //只能写成这样而不能写成 = &arr
arr //获得数组首元素地址等同于&arr[0]
arr、arr[0]、(arr+0) //获得数组首元素值
&arr //获得数组地址
arr+1 //获得数组第二个元素地址
arr[1]、*(arr+1) //获得数组第二个元素值
```



## 7 位操作				

### 7.1 求解整型数的二进制表示中1的个数	

```c
int func(int x)
{
	int countx = 0;
	while(x)
	{
		countx++;
		x = x&(x-1);
    //1）当一个数被减1时，它最右边的那个值为1的bit将变为0，同时其右边的所有的bit都会变成1。
	//2）每次执行x&（x-1）的作用是把ⅹ对应的二进制数中的最后一位1去掉。因此，循环执行这个操作直到ⅹ等于0的时候，循环的次数就是x对应的二进制数中1的个数。
	}
	return countx;
}
int main()
{
	printf("%d\n",func(9999));
	return 0;
}
//结果为8
```

### 7.2 求解整型数的二进制表示中1的个数			

```c++
int CountZeroBit(int num)
{
	int count = 0;
	while (num + 1)
	{
		count++;
		num |= (num + 1); //算法转换
	}
	return count;
}
int main()
{
	int value = 25;
	int ret = CountZeroBit(value);
	printf("%d的二进制位中0的个数为%d\n",value, ret);
	system("pause");
	return 0;
}
```

### 7.3 交换两个变量的值不使用第三个变量

```c
//a=3,b=5,交换之后a=5,b=3;		
	a = a + b;
​	b = a - b;
​	a = a - b;//加法
​					

​	a = a^b;// 异或
​	b = a^b;
​	a = a^b;
​	或者换个写法	a ^= b ^= a
```



## 8 容器和算法

### 8.1 map和set区别

map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）

由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为

map和set的区别在于：

```c
1.map中的元素是key-value（键值对）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。

2.set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。

 其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。

3.map支持下标操作，set不支持下标操作。

map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。
```

### 8.2 STL的allocator作用

STL的分配器用于封装STL容器在内存管理上的底层细节。

在C++中，其内存配置和释放如下：
					new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容

​					delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存

​					为了精密分工，STL allocator将两个阶段操作区分开来：

​					内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；

​					对象构造由::construct()负责，对象析构由::destroy()负责。

同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器

当分配的空间大小超过128B时，会使用第一级空间配置器；

当分配的空间大小小于128B时，将使用第二级空间配置器。

第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。					

### 8.3 STL迭代器如何删除元素

vector,deque：使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；

map,set：使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。

list：，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。

### 8.4 STL中MAP数据存放			

红黑树。unordered map底层结构是哈希表

### 8.5 STL中map与unordered_map区别	

map在底层使用了红黑树来实现；

unordered_map是C++11标准中新加入的容器，它的底层是使用hash表的形式来完成映射的功能，

map是按照operator<比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中

unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。

### 8.6 vector和list的区别

   					1. vector底层实现是数组；list是双向 链表
                        					2. vector支持随机访问，list不支持
                  					3. vector是顺序内存，list不是
                               					4. vector在中间节点进行插入删除会导致内存拷贝，list不会
                                           					5. vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请
                                    					6. vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。

### 8.7 STL中迭代器作用？有指针为何还要迭代器？

```
1、迭代器

​Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。
​由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。

2、迭代器和指针的区别

​迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

​迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。

3、迭代器产生原因

​Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果
```

### 8.8 epoll的原理			

首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表

### 8.9 STL里resize和reserve的区别

改变当前容器内含有元素的数量(size())，eg: vectorv; v.resize(len);v的 size 变为 len,如果原来 v 的 size小于 len，那么容器新增（len-size）个元素，元素的值为默认为 0.当 v.push_back(3);之后，则是 3 是放在了 v 的末尾，即下标为 len，此时容器是 size为len+1；

改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果=reserve(len)的值大于当前的 capacity()，那么会重新分配一块能存 len 个对象的空间，然后把之前v.size()个对象通过 copy construtor 复制过来，销毁之前的内存；



## 9 类和数据抽象

### 9.1 类成员的访问权限			

通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。

在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。

在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问private、protected 属性的成员

### 9.2 struct和class的区别

在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。另外，class还可以定义模板类形参，比如template。

### 9.3 C++类内可以定义引用数据成员吗？

可以，必须通过成员函数初始化列表初始化。

### 9.4.面向对象与泛型编程

1. 面向对象编程简称OOP,是一种程序设计思想。OOP把对象作为程序的基本单元,一个对象包含了数据和操作数据的函数。
2.  面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。
3. 泛型编程: 让类型参数化,方便程序员编码。
4. 类型参数化: 使的程序(算法)可以从逻辑功能上抽象,把被处理对象(数据)的类型作为参数传递。



### 9.5 左值与右值

左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。
右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。

### 9.6 右值引用和左值引用的区别

   1. 左值可以寻址，而右值不可以。
   2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。
   3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）

### 9.7 析构函数可以为 virtual 型，构造函数则不能

构造函数不能声明为虚函数，析构函数可以声明为虚函数，而且有时是必须声明为虚函数。不建议在构造函数和析构函数里面调用虚函数。

构造函数不能声明为虚函数的原因是:	虚函数的主要意义在于被派生类继承从而产生多态。派生类的构造函数中，编译器会加入构造基类的代码，如果基类的构造函数用到参数，则派生类在其构造函数的初始化列表中必须为基类给出参数，就是这个原因。虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。（动态绑定是根据对象的动态类型而不是函数名，在调用构造函数之前，这个对象根本就不存在，它怎么动态绑定？）

### 9.8 C++中空类默认产生哪些类成员函数

C++中空类默认会产生以下6个函数：默认构造函数、复制构造函数、析构函数、赋值运算符重载函数、取址运算法重载函数、const取址运算符重载函数等。

## 10 面向对象

### 10.1 面向对象和面向过程区别

面向对象与面向过程有以下四个方面的不同：
1.出发点不同

​		面向对象使用符合常规思维的方式来处理客观世界的问题，强调把解决问题领域的“动作”直接映射到对象之间的接口上。

​		面向过程则强调的是过程的抽象化与模块化，是以过程为中心构造或处理客观世界问题。

2.层次逻辑关系不同

​		面向对象使用计算机逻辑来模拟客观世界中的物理存在，以对象的集合类作为处理问题的单位，尽可能地使计算机世界向客观世界靠拢，以使处理问题的方式更清晰直接

​		面向对象使用类的层次结构来体现类之间的继承与发展。面向过程处理问题的基本单位是能清晰准确地表达过程的模块，用模块的层次结构概括模块或模块间的关系与功能，把客观世界的问题抽象成计算机可以处理的过程。

3.数据处理方式与控制程序方式不同

​		面向对象将数据与对应的代码封装成一个整体，原则上其他对象不能直接修改其数据，即对象的修改只能由自身的成员函数完成，控制程序方式上是通过“事件驱动”来激活和运行程序的

​		面向过程是直接通过程序来处理数据，处理完毕后即可显示处理的结果，在控制方式上是按照设计调用或返回程序，不能自由导航，各模块之间存在着控制与被控制，调动与被调用的关系。

4.分析设计与编码转换方式不同

​		面向对象贯穿于软件生命周期的分析、设计及编码中，是一种平滑的过程，从分析到设计再到编码是采用一致性的模型表示，实现的是一种无缝连接

​		面向过程强调分析、设计及编码之间按规则进行转换贯穿于软件生命周期的分析、设计及编码中，实现的是一种有缝的连接。

### 10.2.面向对象的基本特征			

1)抽象：就是忽略一个主题中与当前目标无关的方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。

2) 继承：这是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）				

3) 封装：就是把过程和数据包围起来，对数据的访问只能通过已定义的接口。

4) 多态：是指允许不同类的对象对同一消息做出响应。
					

### 10.3 深拷贝与浅拷贝

深拷贝是彻底的拷贝，两对象中所有的成员都是独立的一份，而且，成员对象中的成员对象也是独立一份。
浅拷贝中的某些成员变量可能是共享的，深拷贝如果不够彻底，就是浅拷贝。

### 10.4 友元				

友元的目的 就是让一个函数或者类 访问另一个类中的私有成员
友元的关键字为 friend
如何实现友元：在类最前面将需要调用的全局函数加上friend 声明一下
两种形式的友元：
					1.友元函数：普通函数对一个访问某个类中的私有或保护成员。
					2.友元类：类A中的成员函数访问类B中的私有或保护成员

### 10.5 基类的构造函数/析构函数是否能被派生类继承？

基类的构造函数析构函数不能被派生类继承。

基类的构造函数不能被派生类继承，派生类中需要声明自己的构造函数。

设计派生类的构造函数时，不仅要考虑派生类所增加的数据成员初始化，也要考虑基类的数据成员的初始化。

声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化，需要调用基类构造函数完成。

基类的析构函数也不能被派生类继承，派生类需要自行声明析构函数。声明方法与一般（无继承关系时）类的析构函数相同，不需要显式地调用基类的析构函数，系统会自动隐式调用。

需要注意的是，析构函数的调用次序与构造函数相反。

### 10.6 初始化列表和构造函数初始化的区别

```c
初始化列表：
Example::Example() : ival(0), dval(0.0) {} //ival 和dval是类的两个数据成员
构造函数初始化：
Example::Example(){
	ival = 0;
	dval = 0.0;
}
效果相同，区别在于：使用初始化列表的构造函数显示的初始化类的成员；而没使用初始化列表的构造函数是对类的成员赋值，并没有进行显示的初始化成员。
```

### 10.7 在C++中只能用初始化列表而不能用赋值的情况一般有以下3种：

	1. 成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。
	2. const成员或引用类型的员。因为const对象或引用类型只能初始化，不能对他们赋值。
	3.派生类在构造函数中要对自身成员初始化，也要对继承过来的基类成员进行初始化当基类没有默认构造函数的时候，通过在派生类的构造函数初始化列表中调用基类的构造函数实现

### 10.8.类的成员变量的初始化顺序

​					1. 成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。
​					2. 如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
​					3. 注意：类成员在定义时，是不能初始化的
​					4. 注意：类中const成员常量必须在构造函数初始化列表中初始化。
​					5. 注意：类中static成员变量，必须在类外初始化。
​					6. 静态变量进行初始化顺序是基类的静态变量先初始化，然后是它的派生类。

### 10.9 构造函数没有返回值，如何得知对象是否构造成功

这里的“构造”不单指分配对象本身的内存，而是指在建立对象时做的初始化操作（如打开文件、连接数据库等）。

因为构造函数没有返回值，所以通知对象的构造失败的唯一方法就是在构造函数中抛出异常。构造函数中抛出异常将导致对象的析构函数不被执行，当对象发生部分构造时，已经构造完毕的子对象将会逆序地被析构。

### 10.10 Public继承、protected继承、private继承的区别	

public（公有）继承、 protected（保护）继承和 private（私有）继承是常见的3种继承方式。
					1. 公有继承
					对于子类的对象而言，采用公有继承时，基类成员对子类对象的可见性与一般类成员对对象的可见性相同，公有成员可见，其他成员不可见。
					对于子类而言，基类的公有成员和保护成员可见；基类的公有成员和保护成员作为派生类的成员时，它们都维持原有的可见性（基类 public成员在子类中还是public，基类 protected成员在子类中还是
					protected）；基类的私有成员不可见，基类的私有成员依然是私有的，子类不可访问。
					2. 保护继承
					保护继承的特点是：基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问。基类的私有成员仍然是私有的。由此可以看出，基类的所有成员对子类的对象都
					是不可见的。
					3. 私有继承
					私有继承的特点是，基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问

## 11. 虚函数

### 11.1 虚函数

指向基类的指针在操作它的多态类对象时，可以根据指向的不同类对象调用其相应的函数，这个函数就是虚函数。

虚函数的作用：在基类定义了虚函数后，可以在派生类中对虚函数进行重新定义，并且可以通过基类指针或引用，在程序的运行阶段动态地选择调用基类和不同派生类中的同名函数。（如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。）

### 11.2 使用虚函数需注意以下几个方面

(1) 只需要在声明函数的类体中使用关键字virtual将函数声明为虚函数，而定义函数时不需要使用关键字virtual。

(2) 当将基类中的某一成员函数声明为虚函数后，派生类中的同名函数自动成为虚函数。

(3) 非类的成员函数不能定义为虚函数，全局函数以及类的成员函数中静态成员函数和构造函数也不能定义为虚函数，但可以将析构函数定义为虚函数。

(4) 基类的析构函数应该定义为虚函数，否则会造成内存泄漏。基类析构函数未声明virtual，基类指针指向派生类时，delete指针不调用派生类析构函数。有 virtual，则先调用派生类析构再调用基类析构。

### 11.3 C++如何实现多态

C++中通过虚函数实现多态。

虚函数的本质就是通过基类指针访问派生类定义的函数。

每个含有虚函数的类，其实例对象内部都有一个虚函数表指针。该虚函数表指针被初始化为本类的虚函数表的内存地址。

所以，在程序中，不管对象类型如何转换，该对象内部的虚函数表指针都是固定的，这样才能实现动态地对对象函数进行调用，这就是C++多态性的原理

### 11.4 纯虚函数

```c++
纯虚函数是一种特殊的虚函数，格式一般如下：

​class <类名>
​{
​	virtual()函数返回值类型 虚函数名（形参表）=0;
​	...
​};
​class <类名>
```

### 11.5 什么函数不能声明为虚函数

​					普通函数（非成员函数）；

​					静态成员函数；

​					内联成员函数；

​					构造函数；

​					友元函数;
1．为什么C++不支持普通函数为虚函数？
​					普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时邦定函数。
2．为什么C++不支持构造函数为虚函数？
​					这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，
​					virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）
3．为什么C++不支持内联成员函数为虚函数？
​					其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数
​					在运行时才能动态的邦定函数）
4．为什么C++不支持静态成员函数为虚函数？
​					这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态邦定的必要性。
5．为什么C++不支持友元函数为虚函数？
​					因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

6.C++中如何阻止一个类被实例化？
					C++中可以通过使用抽象类，或者将构造函数声明为private阻止一个类被实例化。抽象类之所以不能被实例化，是因为抽象类不能代表一类具体的事物，它是对多种具有相似性的具体事物的共同特征的一种
					抽象。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但是动物本身生成对象不合情理

# ARM体系与架构

## 1 硬件基础

### 1.1 NAND FLASH 和NOR FLASH异同？		

```c
不同点
				类别						       NOR							                     NAND

​				读			快 像访问SRAM一样，可以随机访问任意地址的数据；		快,有严格的时序要求，需要通过一个函数才能读取数据，先发送读命令->发																			送地址->判断nandflash是否就绪->读取一页数据读命令、发送地址、判断																			状态、读数据都是通过操作寄存器实现的,如数据寄存器NFDATA

​				写			慢，写之前需要擦除，因为写只能是1->0,擦除可以使0->1		快，写之前需要擦除，因为写只能是1->0,擦除可以使0->1

​				擦除						非常慢（5S） 											快（3ms）

​				XIP(CODE是在FLASH上直接运行)代码可以直接在NOR FLASH上运行 								NO

​				可靠性					比较高，位反转的比例小于NANDFLASH的10% 				比较低，位反转比较常见，必须有校验措施

​				接口					与RAM接口相同，地址和数据总线分开					 				I/O接口

​				可擦除次数					10000~100000 					         			100000~1000000

​				容量						   小，1MB~32MB 					       				  大，16MB~512MB

​				主要用途				   常用于保存代码和关键数据 				                    用于保存数据

​				价格						       高							                         低

相同点				写之前都要先擦除，因为写操作只能使1->0，而擦除动作是为了把所有位都变1
				擦除单元都以块为单位
```

### 1.2 CPU,MPU,MCU,SOC,SOPC联系与差别

```
CPU是一台计算机的运算核心和控制核心。CPU由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。
​	差不多所有的CPU的运作原理可分为四个阶段：提取（Fetch）、解码（Decode）、执行（Execute）和写回（Writeback）。 
​	CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。
​	所谓的计算机的可编程性主要是指对CPU的编程。

​MPU微处理器；一个功能强大的CPU；这种芯片往往是个人计算机和高端工作站的核心CPU。最常见的微处理器是Motorola的68K系列和Intel的X86系列。

​MCU微控制器将计算机的CPU、RAM、ROM、定时计数器和多种I/O接口集成在一片芯片上，形成芯片级的芯片，比如51，avr这些芯片；

​SOC指的是片上系统；MCU+MPU；可运行操作系统

​SOPC可编程片上系统；FPGA系统芯片
```

### 1.3 交叉编译

在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。

这里需要注意的是所谓平台，实际上包含两个概念：体系结构、操作系统。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。

举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。

### 1.4  交叉编译原因

​					1.目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；
​					2.目的平台上的资源贫乏，无法运行我们所需要编译器；
​					3.有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。

## 2 ARM体系结构

### 2.1 计算机指令集				

复杂指令集(CISC)、精简指令集(RISC)、 显示并行指令(EPIC)和超长指令字指令集(VLIW)；
					

RISC指令集相对于CISC指令集，主要有以下特点:
      			1. Load/Store架构，CPU不能直接处理内存中的数据，要先将内存中的数据Load（加载）到寄存器中才能操作，然后将处理结果Store（存储）到内存中。
      			2. 固定的指令长度、单周期指
      			3.  倾向于使用更多的寄存器来存储数据，而不是使用内存中的堆栈，效率更高

### 2.2 ARM指令集与RISC指令集区别			

ARM指令集属于RISC但还是有以下差别：
      					1. ARM有桶型移位寄存器，单周期内可以完成数据的各种移位操作
      					2. 并不是所有的ARM指令都是单周期
      					3. ARM有16位的Thumb指令集，是32位ARM指令集的压缩形式，提高了代码密度
      					4. 条件执行：通过指令组合，减少了分支指令数目，提高了代码密度
      					5. 增加了DSP、SIMD/NEON等指令

### 2.3. ARM处理器中寄存器				

​					1.通用寄存器	R0～R12，除了FIQ工作模式，在其他工作模式下这些寄存器都是共用、共享的：
​							R0～R3通常用来传递函数参数，
​							R4～R11用来保存程序运算的中间结果或函数的局部变量等，
​							R12常用来作为函数调用过程中的临时寄存器。
​					2.专用寄存器		
​							R13、R14、R15、CPSP、SPSR寄存器		
​							R13寄存器又称为堆栈指针寄存器(SP)，用来维护和管理函数调用过程中的栈帧变化，R13总是指向当前正在运行的函数的栈帧
​							R14寄存器又称为链接寄存器(LR)，在函数调用过程中主要用来保存上一级函数调用者的返回地址
​							寄存器R15又称为程序计数器(PC)，CPU从内存取指令执行，就是默认从PC保存的地址中取的，每取一次指令，PC寄存器的地址值自动增加。

### 2.4 ARM寻址方式				

寄存器寻址、立即数寻址、寄存器偏移寻址、寄存器间接寻址、基址寻址、多寄存器寻址、相对寻址

### 2.5 ARM伪指令(辅助指令)			

ADR、ADRL、LDR、NOP：
					LDR伪指令中的操作数前一般会有一个等于号=，用来表示该指令是个伪指令；LDR伪指令的主要用途是将一个32位的内存地址保存到寄存器中
					ADR伪指令的功能与LDR伪指令类似，将基于PC相对偏移的地址值读取到寄存器中
					NOP伪指令为空指令 用于延时或插入流水线中暂停指令的运行
					ADRL伪指令为中等范围地址读取

## 3 ARM处理器

### 3.1 哈佛结构和冯诺依曼结构

	冯诺依曼结构(普林斯顿结构)釆用指令和数据统一编址，使用同条总线传输，CPU读取指令和数据的操作无法重叠。常见：X86、ARM7
	哈佛结构釆用指令和数据独立编址，使用两条独立的总线传输，CPU读取指令和数据的操作可以重叠。常见：8051单片机
```
利弊
		冯诺依曼结构主要用于通用计算机领域，需要对存储器中的代码和数据频繁的进行修改，统一编址有利于节约资源。
		哈佛结构主要用于嵌入式计算机，程序固化在硬件中，有较高的可靠性、运算速度和较大的吞吐。
```

### 3.2 CPU性能提升---Cache机制			

​	物理实现：			    静态随机访问存储器；运行速度介于CPU和内存间，用来解决两者速度不匹配的问题
​	工作流程：				当CPU读取内存中地址为8的数据时，CPU会将内存中地址为8的一片数据缓存到Cache中。等下一次CPU读取内存地址为12的数据时，会首										先到Cache中检查该地址是否在Cache中。如果在，就称为缓存命中，CPU就直接从Cache中取数据；如果该地址不在Cache中，就称为缓										存未命中，CPU就重新转向内存读取数据，并重新缓存从该地址开始的一片数据到Cache中。

### 3.3 没有Cache的处理器 		

C51系列单片机 、 cortex-M0 、 cortex-M1 、cortex-M2、cortex-M3、cortex-M4系列的ARM处理器都没有Cache。
为什么这些处理器不使用Cache呢？		

1.这些处理器都是低功耗、低成本处理器，在CPU内集成Cache会增加芯片的面积和发热量，不仅功耗增加，芯片的成本也会增加不少。

2.这些处理器本来工作频率就不高（从几十兆赫到几百兆赫不等），和RAM之间不存在带宽问题，有些处理器甚至不需要外接RAM，直接使用片内SRAM就可满足面向控制领域的软件开发需求。

3.使用Cache无法保证实时性。当缓存未命中时，CPU从RAM中读取数据的时间是不确定的，这是嵌入式实时控制场景无法接受的。

### 3.4 ARM流水线技术

流水线技术通过多个功能部件并行工作来缩短程序执行时间，提高处理器核的效率和吞吐率，从而成为微处理器设计中最为重要的技术之一。(本质是拿空间换时间)

ARM7处理器核使用了典型三级流水线的冯·诺伊曼结构，ARM系列则采用了基于五级流水线的哈佛结构。

通过增加流水线级数简化了流水线各级的逻辑，进一步提高了处理器的性能。

### 3.5 超流水线结构

拥有5级以上的流水线	Intel:  i7处理器：16级流水线    AMD：速龙64:  20级流水线	最长：Intel：第三代奔腾四：31级

### 3.6.提高CPU主频				

关键在于减少流水线中每一级流水的执行时间，消除木桶短板效应。
	1.优化流水线中各级流水线的性能		

​	2.提升半导体制作工艺，工艺越先进，芯片面积越小，越容易提升主频	

​	3.增加流水线的深度
​					

### 3.7 ARM工作模式

```
1. 用户模式(USR)
      
      用户模式是用户程序的工作模式，它运行在操作系统的用户态，它没有权限去操作其它硬件资源，只能执行处理自己的数据，也不能切换到其它模式下，要想访问硬件资源或切换到其它模式只能通过软中断或产生异常。

2. 系统模式(SYS)
      
      系统模式是特权模式，不受用户模式的限制。用户模式和系统模式共用一套寄存器，操作系统在该模式下可以方便的访问用户模式的寄存器，而且操作系统的一些特权任务可以使用这个模式访问一些受控的资源。

3. 一般中断模式(IRQ)
      
      一般中断模式也叫普通中断模式，用于处理一般的中断请求，通常在硬件产生中断信号之后自动进入该模式，该模式为特权模式，可以自由访问系统硬件资源。

4. 快速中断模式(FIQ)
     
     快速中断模式是相对一般中断模式而言的，它是用来处理对时间要求比较紧急的中断请求，主要用于高速数据传输及通道处理中。

5. 管理模式（SVC）
     
     管理模式是CPU上电后默认模式，因此，在该模式下主要用来做系统的初始化，软中断处理也在该模式下。当用户模式下的用户程序请求使用硬件资源时，通过软件中断进入该模式。

6. 终止模式(ABT)：
     
     中止模式用于支持虚拟内存或存储器保护，当用户程序访问非法地址，没有权限读取的内存地址时，会进入该模式，linux下编程时经常出现的segment fault通常都是在该模式下抛出返回的。

​除了用户模式外，其它6种模式称为特权模式。所谓特权模式，即具有如下权利：
​a. MRS（把状态寄存器的内容放到通用寄存器)	
​b. MSR（把通用寄存器的内容放到状态寄存器中）
​由于状态寄存器中的内容不能够改变，因此，要先把内容复制到通用寄存器中，然后修改通用寄存器中的内容，再把通用寄存器中的内容复制给状态寄存器中，即可完成“修改状态寄存器”的任务。
​剩下的六种模式中除去系统模式外，统称为异常模式
```



### 3.8 Arm的32位寄存器			

ARM处理器共有37个寄存器。它包含31个通用寄存器和6个状态寄存器

### 3.9 ARM指令集			

2类，分别为Thumb指令集，ARM指令集。

ARM指令长度为32位，Thumb指令长度为16位。

这种特点使得ARM既能执行16位指令，又能执行32位指令，从而增强了ARM内核的功能。

### 3.10 Arm处理器工作状态

```
从编程的角度来看，ARM微处理器的工作状态一般ARM和Thumb有两种，并可在两种状态之间切换

1. ARM状态：此时处理器执行32位的字对齐ARM指令，绝大部分工作在此状态

2. Thumb状态：此时处理器执行16位的半字对齐的Thumb指令

```

### 3.11 ARM系统中，在函数调用时传参方式		

当参数小于等于4的时候是通过R0-R3寄存器来进行传递的，当参数大于4的时候是通过压栈的方式进行传递。

3.12 ARM协处理器指令			

ARM协处理器指令包括以下3类：
   					1. 用于ARM处理器初始化ARM协处理器的数据处理操作。
                        					2. 用于ARM处理器的寄存器和ARM协处理器的寄存器间的数据传送操作。
                  					3. 用于在ARM协处理器的寄存器和内存单元之间传送数据。

### 3.13 PLL（锁相环）

简单来说，输入时钟的存在是作为“参考源”。锁相环不是为了单纯产生同频同相信号，而是一般集成进某种“频率综合电路”，产生一个不同频，但锁相的信号。

## 4 终端与异常

### 4.1 中断与异常区别

中断是指外部硬件产生的一个电信号从CPU的中断引脚进入，打断CPU的运行。

异常是指软件运行过程中发生了一些必须作出处理的事件，CPU自动产生一个陷入来打断CPU的运行。

异常在处理的时候必须考虑与处理器的时钟同步，实际上异常也称为同步中断，在处理器执行到因编译错误而导致的错误指令时，或者在执行期间出现特殊错误，必须靠内核处理的时候，处理器就会产生一个异常。

### 4.2 中断与DMA区别

DMA：是一种无须CPU的参与，就可以让外设与系统内存之间进行双向数据传输的硬件机制，使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而大大提高系统的吞吐率。

中断：是指CPU在执行程序的过程中，出现了某些突发事件时，CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。

所以中断和DMA的区别就是：DMA不需CPU参与，而中断是需要CPU参与的。

### 4.3 中断能不能睡眠，为什么？下半部能不能睡眠？

1. 中断处理的时候,不应该发生进程切换。因为在中断上下文中，唯一能打断当前中断handler的只有更高优先级的中断，它不会被进程打断。如果在中断上下文中休眠，则没有办法唤醒它，因为所有的wake_up_xxx都是针对某个进程而言的，而在中断上下文中，没有进程的概念，没有一个task_struct（这点对于softirq和tasklet一样）。因此真的休眠了，比如调用了会导致阻塞的例程，内核几乎肯定会死。
2. schedule()在切换进程时，保存当前的进程上下文（CPU寄存器的值、进程的状态以及堆栈中的内容），以便以后恢复此进程运行。中断发生后，内核会先保存当前被中断的进程上下文（在调用中断处理程序后恢复）。但在中断处理程序里，CPU寄存器的值肯定已经变化了（最重要的程序计数器PC、堆栈SP等）。如果此时因为睡眠或阻塞操作调用了schedule()，则保存的进程上下文就不是当前的进程上下文了。所以，不可以在中断处理程序中调用schedule()
3. 中断handler会使用被中断的进程内核堆栈，但不会对它有任何影响，因为handler使用完后会完全清除它使用的那部分堆栈，恢复被中断前的原貌。
4.  处于中断上下文时候，内核是不可抢占的。因此，如果休眠，则内核一定挂起

### 4.4 中断的响应执行流程			

中断的响应流程：CPU接受中断->保存中断上下文跳转到中断处理历程->执行中断上半部->执行中断下半部->恢复中断上下文。

### 4.5 当一个异常出现以后，ARM微处理器会执行哪几步操作

```
a. 将下一条指令的地址存入相应连接寄存器LR，以便程序在处理异常返回时能从正确的位置重新开始执行。

b. 将CPSR复制到相应的SPSR中。

c. 根据异常类型，强制设置CPSR的运行模式位。

d. 强制PC从相关的异常向量地址取下一条指令执行，从而跳转到相应的异常处理程序处。
```

### 4.6 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？

```
a. 写一个中断服务程序要注意快进快出，在中断服务程序里面尽量快速采集信息，包括硬件信息，然后退出中断，要做其它事情可以使用工作队列或者tasklet方式。也就是中断上半部和下半部。

b. 中断服务程序中不能有阻塞操作。应为中断期间是完全占用CPU的（即不存在内核调度），中断被阻塞住，其他进程将无法操作。

c. 中断服务程序注意返回值，要用操作系统定义的宏做为返回值，而不是自己定义的。

d. 如果要做的事情较多，应将这些任务放在后半段(tasklet，等待队列等)处理。
```

### 4.7 为什么FIQ比IRQ要快			

```
a. ARM的FIQ模式提供了更多的banked寄存器，R8到R14还有SPSR，而IRQ模式就没有那么多

b. FIQ比IRQ有更高优先级，如果FIQ和IRQ同时产生，那么FIQ先处理。

c. 在symbian系统里，当CPU处于FIQ模式处理FIQ中断的过程中，预取指令异常，未定义指令异常，软件中断全被禁止，所有的中断被屏蔽。所以FIQ就会很快执行，不会被其他异常或者中断打断，所以它又比IRQ快了。而IRQ不一样，当ARM处理IRQ模式处理IRQ中断时，如果来了一个FIQ中断请求，那正在执行的IRQ中断处理程序会被抢断，ARM切换到FIQ模式去执行这个FIQ，所以FIQ比IRQ快多了

d. 另外FIQ的入口地址是0x1c,IRQ的入口地址是0x18。
```

### 4.8 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？

中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。

凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。

如果是一般设备，并且该设备请求CPU的频率比较低，则用中断效率要高一些。主要是看请求频率。

## 5 通信协议

### 5.1 异步传输和同步传输

异步传输：是一种典型的基于字节的输入输出，数据按每次一个字节进行传输，其传输速度低。
同步传输：需要外界的时钟信号进行通信，是把数据字节组合起来一起发送，这种组合称之为帧，其传输速度比异步传输快。

### 5.2 RS232和RS485通讯接口区别

a. 传输方式不同。 RS232采取不平衡传输方式，即所谓单端通讯。 而RS485则采用平衡传输，即差分传输方式。

b. 传输距离不同。RS232适合本地设备之间的通信，传输距离一般不超过20m。而RS485的传输距离为几十米到上千米。

c. 设备数量。RS232 只允许一对一通信，而RS485 接口在总线上是允许连接多达128个收发器。

d. 连接方式。RS232，规定用电平表示数据，因此线路就是单线路的，用两根线才能达到全双工的目的；而RS485， 使用差分电平表示数据，因此，必须用两根线才能达到传输数据的基本要求，要实现全双工，必需用4根线。

总结：从某种意义上，可以说，线路上存在的仅仅是电流，RS232/RS485规定了这些电流在什么样的线路上流动和流动的样式。

### 5.3 SPI协议

```
SPI(Serial Peripheral Interface)协议:串行外围设备接口，是一种高速全双工的通信总线。SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。
SPI总线可直接与各个厂家生产的多种标准外围器件相连，包括FLASH、RAM、网络控制器、LCD显示驱动器、A/D转换器和MCU等。

接口：
1. MOSI (Master Output， Slave Input)
	
主设备输出/从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。

2. MISO(Master Input,， Slave Output)

主设备输入/从设备输出引脚。主机从这条信号线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。
3. SCLK (Serial Clock)

时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如 STM32 的 SPI 时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备

4. SS( Slave Select)

从设备选择信号线，常称为片选信号线，也称为 NSS、 CS，以下用 NSS 表示。 当有多个 SPI 从设备与 SPI 主机相连时，设备的其它信号线 SCK、MOSI 及 MISO 同时并联到相同的 SPI 总线上，即无论有多少个从设备，都共同只使用这 3 条总线；而每个从设备都有独立的这一条 NSS 信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。

I2C 协议中通过设备地址来寻址、选中总线上的某个设备并与其进行通讯；而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。所以SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。
```

协议层

SPI 通讯设备之间的常用连接方式见下图：  

  <img src="C:\Users\mm611\Desktop\1690359387615.png" alt="1690359387615" style="zoom: 80%;" />

SPI 通讯的通讯时序，见下图：  

![1690359547452](C:\Users\mm611\Desktop\1690359547452.png)

1. 通讯的起始和停止信号

   在图中的标号1处，NSS 信号线由高变低，是 SPI 通讯的起始信号。 NSS 是每个从机各自独占的信号线，当从机检在自己的 NSS 线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处， NSS 信号由低变高，是 SPI 通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。

2. 数据有效性

   SPI 使用 MOSI 及 MISO 信号线来传输数据，使用 SCK 信号线进行数据同步。 MOSI及 MISO 数据线在 SCK 的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时， MSB 先行（高位先行）或 LSB（低位先行）先行并没有作硬性规定，但要保证两个 SPI 通讯设备之间使用同样的协定，一般都会采用上图中的 MSB 先行（高位先行）模式。观察图中的2345标号处， MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在 SCK 的下降沿时被采样。即在 SCK 的下降沿时刻， MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效， MOSI 及 MISO为下一次表示数据做准备。SPI 每次数据传输可以 8 位或 16 位为单位，每次传输的单位数不受限制。

3. CPOL（时钟极性）/CPHA（时钟相位）及通讯模式上面讲述的图中的时序只是 SPI 中的其中一种通讯模式， SPI 一共有四种通讯模式，它们的主要区别是：总线空闲时 SCK 的时钟状态以及数据采样时刻。为方便说明，在此引入“时钟极性CPOL”和“时钟相位 CPHA”的概念。时钟极性 CPOL 是指 SPI 通讯设备处于空闲状态时， SCK 信号线的电平信号(即 SPI 通讯开始前、 NSS 线为高电平时 SCK 的状态)。 CPOL=0 时， SCK 在空闲状态时为低电平，CPOL=1时，则相反。时钟相位 CPHA 是指数据的采样的时刻，当 CPHA=0 时， MOSI 或 MISO 数据线上的信号将会在 SCK 时钟线的“奇数边沿” 被采样。当 CPHA=1 时，数据线在 SCK 的“偶数边沿” 采样。

### 5.4 IIC协议

IIC协议是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据,是一个多主机的半双工通信方式每个挂接在总线上的器件都有个唯一的地址。位速在标准模式下可达 100kbit/s,在快速模式下可达400kbit/s，在高速模式下可待3.4Mbit/s。I2C总线系统结构,如下所示:

![image-20230726162456724](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726162456724.png)

### 5.4.1 I2C时序介绍

1.空闲状态

当总线上的SDA和SCL两条信号线同时处于高电平,便是空闲状态,如上面的硬件图所示,当我们不传输数据时, SDA和SCL被上拉电阻拉高,即进入空闲状态

2.起始信号

当SCL为高期间，SDA由高到低的跳变；便是总线的启动信号,只能由主机发起,且在空闲状态下才能启动该信号,如下图所示：

![image-20230726162803423](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726162803423.png)

3.信号当SCL为高期间，SDA由低到高的跳变；便是总线的停止信号,表示数据已传输完成,如下图所示：

![image-20230726163320541](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726163320541.png)

4.数据格式当发了起始信号后,就开始传输数据,传输的数据格式如下图所示：

![image-20230726163404739](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726163404739.png)

当SCL为高电平时,便会获取SDA数据值,其中SDA数据必须是稳定的(若SDA不稳定就会变成起始/停止信号)。

当SCL为低电平时,便是SDA的电平变化状态。

若主从机在传输数据期间,需要完成其它功能(例如一个中断),可以主动拉低SCL,使I2C进入等待状态,直到处理结束再释放SCL,数据传输会继续

5.应答信号ACK

I2C总线上的数据都是以8位数据(字节)进行的，当发送了8个数据后，发送方会在第9个时钟脉冲期间释放SDA数据，当接收方接收该字节成功，便会输出一个ACK应答信号，当SDA为高电平,表示为非应答信号NACK，当SDA为低电平，表示为有效应答信号ACK

PS:当主机为接收方时,收到最后一个字节后,主机可以不发送ACK,直接发送停止信号来结束传输。当从机为接收方时，没有发送ACK，则表示从机可能在忙其它事、或者不匹配地址信号和不支持多主机发送，主机可以发送停止信号，再次发送起始信号启动新的传输。

![image-20230726163528088](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726163528088.png)

6.完整的数据传输

如下图所示, 发送起始信号后,便发送一个8位的设备地址,其中第8位是对设备的读写标志,后面紧跟着的就是数据了,直到发送停止信号终止。PS:当我们第一次是读操作，然后想换成写操作时，可以再次发送一个起始信号，然后发送读的设备地址，不需要停止信号便能实现不同的地址转换。

![image-20230726163542184](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726163542184.png)

### 5.4.2 IIC传输数据的格式

1.写操作

刚开始主芯片要发出一个start信号，然后发出一个(用来确定是往哪一个芯片写数据)，方向(读/写，0表示写，1表示读)。回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。每传输一个数据，接受方都会有一个回应信号，数据发送完之后，主芯片就会发送一个停止信号。

白色背景：主→从。灰色背景：从→主

![image-20230726163801988](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726163801988.png)

2.读操作

刚开始主芯片要发出一个start信号，然后发出一个设备地址(用来确定是从哪一个芯片读取数据)，方向(读/写，0表示写，1表示读)。回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后在传输下一个数据。每传输一个数据，接受方都会有一个回应信号，数据发送完之后，主芯片就会发送一个停止信号。

白色背景：主→从。灰色背景：从→主

![image-20230726163847408](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726163847408.png)

## 6 编程

### 6.1 嵌入式编程中，什么是大端？什么是小端？

大端模式：低位字节存在高地址上，高位字节存在低地址上。

小端模式：高位字节存在高地址上，低位字节存在低地址上。

![image-20230726164109225](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230726164109225.png)

STM32属于小端模式，简单的说，比如u32 temp=0X12345678；假设temp地址在0X2000 0010。那么在内存里面,存放就变成了：

### 6.2 大小端的转换  

```c
int swapInt32(int intValue)
{	int temp = 0;
	temp = ((intValue & 0x000000FF) <<24)|
		   ((intValue & 0x0000FF00) <<8) |
		   ((intValue & 0x00FF0000) >>8) |
		   ((intValue & 0xFF000000) >>24);
	return temp;}
/*short型：*/unsigned short swapShort16(unsigned short shortValue)
{
	return ((shortValue & 0x00FF ) <<8) | ((shortValue & 0xFF00)>>8);
}
/*float型:*/
float swapFloat32(float floatValue)
{
	typedef union SWAP_UNION
	{
		float unionFloat;
		int unionInt;
	}SWAP_UNION;
	SWAP_UNION swapUnion;
	swapUnion.unionFloat = floatValue;
	swapUnion.unionInt = swapInt32( swapUnion.unionInt);
	return swapUnion.unionFloat;
}
/*double型换一种写法，用一下指针，不然移位移死了……*/
void swapDouble64(unsigned char *pIn, unsigned char *pOut)
{
	for( int i=0;i<8;i++)
	pOut[7-i] = pIn[i];
}
int main()
{
	int x = 0x12345678;
	int y = swapInt32(x);
	printf("%x\r\n",y);
	return 0;
}
```



# Linux驱动

## 1 指令

### 1.1 常用的Linux指令

#### 1.1.1 怎么查看当前进程？怎么执行退出？怎么查看当前路径？

查看当前进程： ps

执行退出： exit

查看当前路径： pwd

#### 1.1.2 ls 命令执行什么功能？ 可以带哪些参数？

功能

列出指定目录中的目录，以及文件

参数

-

```shell
-a 显示所有文件及目录 (. 开头的隐藏文件也会列出)

-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出

-r 将文件以相反次序显示(原定依英文字母次序)

-t 将文件依建立时间之先后次序列出

-A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)

-F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/" 

-R 若目录下有文件，则以下之文件亦皆依序列出
```

#### 1.1.3 创建目录用什么命令？

```shell
mkdir runoob

#在工作目录下，建立一个名为 runoob 的子目录

mkdir -p runoob2/test

#在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）
```



#### 1.1.4 创建文件用什么命令？  

vi或vim  

```shell
vi file1.txt #直接创建并打开一个文件file1.txt 
```

 touch  

```shell
touch file2.txt #创建新的空文件file2.txt  
```

echo  

```shell
echo "this is a new file" > file3.txt

#创建文件file3.txt并将this is a newfile写入（说明：使用>指令覆盖文件原内容并重新输入内容，若文件不存在则创建文件。）

echo "add contents" >>file3.txt

#在已存在的文件补充写入新内容add contents（说明：使用>>指令向文件追加内容，原内容将保存。）
```

less 、more 、cat

三者都是将文件内容输出到标准输出，其中less和more可以分页显示，cat是显示全部。

三者可以根据已经存在的文件创建新的文件。假设已经存在文件1.txt

```shell
cat 1.txt > 2.txt 

less 1.txt > 3.txt 

more 1.txt > 4.txt  
```

cd  

```shell
cd > file3.txt#创建新的空文件file3.txt

cd >> file4.txt#创建新的空文件file4.txt
```

cd最主要的作用是切换目录，在cd后面跟>或>>再加上文件名就可以创建一个内容为空的文件。它和echo的区别之处在于echo可写文件内容，而cd并不能。  

#### 1.1.5 复制文件用什么命令？  

```shell
cp –r test/ newtest #将当前目录 test/ 下的所有文件复制到新目录 newtest 下 
```

#### 1.1.6 查看文件内容有哪些命令可以使用？ 

```shell
vi 文件名 #编辑方式查看，可修改

cat 文件名 #显示全部文件内容

more 文件名 #分页显示文件内容

less 文件名 #与 more 相似，更好的是可以往前翻页

tail 文件名 #仅查看尾部，还可以指定行数

head 文件名 #仅查看头部,还可以指定行数

```

#### 1.1.7 怎么向屏幕输出带空格的字符串，比如”hello world”?  

```shell
echo hello world  
```

#### 1.1.8 移动文件用哪个命令？改名用哪个命令？  

```shell
mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名dest_file

mv source_file(文件) dest_directory(目录) #将文件 source_file 移动到目标目录dest_directory 中
```

#### 1.1.9 删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？ 

```shell
rm -rf file/directory #删除当前目录下的所有文件及目录，并且是直接删除，无需逐一确认
rm -rf directory/ #删除目录 directory，不管该目录下是否有子目录或文件
```

#### 1.1.10 查找文件内容用哪个命令?

```shell
grep test *file #在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行
grep -r update /etc/acpi #查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串"update"的文件
grep -v test *test* #查找文件名中包含 test 的文件中不包含test 的行
```

#### 1.1.11 查找文件用哪个命令？  

```shell
find . -name "*.c" #将当前目录及其子目录下所有文件后缀为 .c 的文件列出来
find . -ctime -20 #将当前目录及其子目录下所有最近 20 天内更新过的文件列出
```

#### 1.1.12 cat命令  

```shell
cat -n textfile1 #把 textfile1 的文档内容加上行号后输入到屏幕
cat -n textfile1 > textfile2 #把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里
cat -b textfile1 textfile2 >> textfile3 #把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里
cat /dev/null > /etc/test.txt #清空 /etc/test.txt 文档内容
```

### 1.2 常用的GCC指令  

#### 1.2.1 预处理  

```shell
gcc -E test.c -o test.i #把预处理的结果导出到test.i文件
```

#### 1.2.2 编译为汇编代码  

```shell
gcc -S test.i -o test.s #编译器将test.i翻译成汇编语言，并将结果存储在test.s文件中。
```

#### 1.2.3 汇编  

```shell
 gcc -c test.s -o test.o #将汇编代码编译为目标文件（.o）但不链接
```

#### 1.2.4 链接  

```shell
gcc test.o -o test #将生成的目标文件test.o生成最终的可执行文件test
```

#### 1.2.5 一步到位编译  

```shell
 gcc test.c -o test #将源文件test.c编译链接为可执行文件test
```

#### 1.2.6 多文件编译  

```shell
gcc test1.c test2.c -o test
```

#### 1.2.7 警告处理  

```shell
gcc -w test.c -o test # 忽略编译时的警告
gcc -Wall test.c -o test #编译后显示所有警告
gcc -Werror test.c -o test #在产生警告的地方停止编译
```

### 1.3常用的GDB调试指令  

```shell
gcc -g test.c -o test #编译时生成debug有关的程序信
gdb test #启动调试
help #查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h
run #重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r
start #单步执行，运行程序，停在第一执行语句
list #查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l
set #设置变量的值
next #单步调试（逐过程，函数直接执行）,简写n
step #单步调试（逐语句：跳入自定义函数内部执行）,简写s
backtrace #查看函数的调用的栈帧和层级关系,简写bt
frame #切换函数的栈帧,简写f
info #查看函数内部局部变量的数值,简写i
finish #结束当前函数，返回到函数调用点
continue #继续运行,简写c
print #打印值及地址,简写p
quit #退出gdb,简写q
break+num #在第num行设置断点,简写b
info breakpoints #查看当前设置的所有断点
delete breakpoints num #删除第num个断点,简写d
display #追踪查看具体变量值
undisplay #取消追踪观察变量
watch #被设置观察点的变量发生修改时，打印显示
i watch #显示观察点
enable breakpoints #启用断点
disable breakpoints #禁用断点
x #查看内存x/20xw 显示20个单元，16进制，4字节每单元
run argv[1] argv[2] #调试时命令行传参
set follow-fork-mode child #Makefile项目管理：选择跟踪父子进程(fork())
```

### 1.4 常用的驱动开发指令  

1.4.1 加载/卸载驱动  

```shell
insmod/modprobe #加载驱动
rmmod #卸载驱动
```

1.4.2 Linux驱动如何查看驱动模块中打印信息？  

```shell
dmesg
```

1.4.3 如何查看内核中已有的字符设备的信息？  

```
lsmod 和modprobe，lsmod可以查看模块的依赖关系，modprobe在加载模块时会加载其他依赖的模块。
```

1.4.4 如何查看正在使用的有哪些中断号？  

```shell
cat /proc/interrupt
```

## 2 uboot  

### 2.1 bootloader 

Linux系统要启动就必须需要一个 bootloader程序，也就说芯片上电以后先运行一段bootloader程序。

这段 bootloader程序会先初始化时钟，看门狗，中断，SDRAM等外设，然后将 Linux内核从flash（NAND, NOR FLASH,SD,MMC等）拷贝到SDRAM中，最后启动Linux内核。

当然了， bootloader的实际工作要复杂的多，但是它最主要的工作就是启动 Linux内核。

bootloader和 Linux内核的关系就跟PC上的BIOS和 Windows的关系一样， bootloader就相当于BIOS。

总得来说，Bootloader就是一小段程序，它在系统上电时开始执行，初始化硬件设各、准备好软件环境，最后调用操作系统内核。

### 2.2 uboot启动过程中做了那些事

1. 初始化时钟，关闭看门狗，关中断，启动ICACHE，关闭DCACHE和TLB，关闭MMU，初始化SDRAM，初始化NAND FLASH，重定位。  
2. 初始化一个串口，检测系统内存映射，将内核映象和根文件系统映象从 Flash上读到SDRAM空间中，为内核设置启动参数，调用内核。  
3. MMU----内存管理单元；虚拟地址转化为物理地址     ICACHE-----指令缓存     DCACHE----数据缓存    TCL---缓存虚拟地址和其映射物理地址

### 2.3 uboot和内核参数传递  

直接修改PC寄存器的值为Linux内核所在的地址，这样CPU就会从Linux内核所在的地址去取指令，从而执行内核代码  

在跳转到内核以前，uboot需要做好以下三件事情：

  (1) CPU寄存器的设置
  R0=0。
  R1=机器类型ID；看型号和板子是否适配
  R2=启动参数标记列表在RAM中起始基地址。
  (2) CPU工作模式
  必须禁止中断（IRQs和FIQs）
  CPU必须为SVC模式
  (3) Cache和MMU的设置
  MMU必须关闭
  指令 Cache可以打开也可以关闭
  数据 Cache必须关闭

  其中上面第一步CPU寄存器的设置中，就是通过R0,R1,R2三个参数给内核传递参数的。

### 2.4 为什么要给内核传递参数呢？

在此之前，uboot已经完成了硬件的初始化，可以说已经”适应了“这块开发板。

然而，内核并不是对于所有的开发板都能完美适配的（如果适配了，可想而知这个内核有多庞大，又或者有新技术发明了，可以完美的适配各种开发板），此时，对于开发板的环境一无所知。

所以，要想启动Linux内核，uboot必须要给内核传递一些必要的信息来告诉内核当前所处的环境。

### 2.5 如何给内核传递参数？

uboot把机器ID通过R1传递给内核，Linux内核运行的时候，首先就从R1中读取机器ID来判断是否支持当前机器。

这个机器ID实际上就是开发板CPU的ID，每个厂家生产出一款CPU的时候都会给它指定一个唯一的ID，大家可以到uboot源码的arch\arm\include\asm\mach-type.h文件中去查看

![image-20230727101114667](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727101114667.png)

R2存放的是块内存的基地址，这块内存中存放的是uboot给Linux内核的其他参数。

这些参数有内存的起始地址、内存大小、Linux内核启动后挂载文件系统的方式等信息。

很明显，参数有多个，不同的参数有不同的内容，为了让Linux内核能精确的解析出这些参数，双方在传递参数的时候要求参数在存放的时猴需要按照双方规定的格式存放。

除了约定好参数存放的地址外，还要规定参数的结构。

Linux2.4.x以后的内核都期望以标记列表（tagged_list）的形式来传递启动参数。

标记，就是一种数据结构；标记列表，就是挨着存放的多个标记。

标记列表以标记 ATAG_CORE 开始，以标记 ATAG_NONE 结束。

标记的数据结构为tag，它由一个tag_header结构和一个联合（union）组成。

tag_header结构表示标记的类型及长度，比如是表示内存还是表示命令行参数等。

对于不同类型的标记使用不同的联合（union），比如表示内存时使用tag_ mem32，表示命令行时使用 tag_cmdline。

![image-20230727101432468](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727101432468.png)

从上面可以看出，struct_tag结构体由structtag_header+联合体union构成，结构体struct tag_header用来描述每个tag的头部信息，如tag的类型，tag大小。

联合体union用来描述每个传递给Linux内核的参数信息。  

### 2.6 为什么uboot要关掉caches？

caches是cpu内部的一个2级缓存，它的作用是将常用的数据和指令放在cpu内部。

caches是通过CP15管理的，刚上电的时候，cpu还不能管理caches。

上电的时候指令cache可关闭，也可不关闭，但数据cache一定要关闭，否则可能导致刚开始的代码里面，去取数据的时候，从cache里面取，而这时候RAM中数据还没有caches过来，导致数据预取异常 。

## 3 文件系统

### 3.1 根文件系统

根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，而且还是内核启动时所挂载（mount）的第一个文件系统。

内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些初始化脚本（如rcS,inittab）和服务加载到内存中去运行，里面包含了 Linux系统能够运行所必需的应用程序、库等，比如可以给用户提供操作 Linux的控制界面的shell程序、动态连接的程序运行时需要的glibc库等。

我们要明白文件系统和内核是完全独立的两个部分。在嵌入式中移植的内核下载到开发板上，是没有办法真正的启动Linux操作系统的，会出现无法加载文件系统的错误。

### 3.2 根文件系统重要性

根文件系统之所以在前面加一个”根“，说明它是加载其它文件系统的”根“，那么如果没有这个根，其它的文件系统也就没有办法进行加载的。

根文件系统包含系统启动时所必须的目录和关键性的文件，以及使其他文件系统得以挂载（mount）所必要的文件。

例如：

```
1.init进程的应用程序必须运行在根文件系统上。

2.根文件系统提供了根目录“/”。

3.linux挂载分区时所依赖的信息存放于根文件系统/etc/fstab这个文件中。

4.shell命令程序必须运行在根文件系统上，譬如ls、cd等命令。
```

总之：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、/bin /sbin等目录下的shell命令，还有/lib目录下的库文件等）相配合才能工作。

### 3.3 可执行映像文件构成与特点

可执行映像文件通常由以下几部分构成：

```
1.一个或多个代码段，代码段的属性为只读

2.零个或多个包含初始化数据的数据段，数据段的属性为可读写

3.零个或多个不包含初始化数据的数据段，数据段的属性为可读写
```

## 4 中断

### 4.1 硬中断 / 软中断是什么？有什么区别？

硬中断

1. 硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上（注：硬件驱动通常是内核中的一个子程序，而不是一个独立的进程）
2. 处理中断的驱动是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任务，来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU（也有一种特殊的情况，就是在大型主机上是有硬件通道的，它可以在没有主CPU的支持下，可以同时处理多个中断。）
3.  硬中断可以直接中断CPU。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理的进程，中断代码本身也可以被其他的硬中断中断
4.  对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在是为了让调度代码（或称为调度器）可以调度多任务

软中断

1. 软中断的处理非常像硬中断。然而，它们仅仅是由当前正在运行的进程所产生的
2. 通常，软中断是一些对I/O的请求。这些请求会调用内核中可以调度I/O发生的程序。对于某些设备，I/O请求需要被立即处理，而磁盘I/O请求通常可以排队并且可以稍后处理。根据I/O模型的不同，进程或许会被挂起直到I/O完成，此时内核调度器就会选择另一个进程去运行。I/O可以在进程之间产生。并且调度过程通常和磁盘I/O的方式是相同
3. 软中断仅与内核相联系。而内核主要负责对需要运行的任何其他的进程进行调度。一些内核允许设备驱动的一些部分存在于用户空间，并且当需要的时候内核也会调度这个进程去运行
4. 软中断并不会直接中断CPU。也只有当前正在运行的代码（或进程）才会产生软中断。这种中断是一种需要内核为正在运行的进程去做一些事情（通常为I/O）的请求。有一个特殊的软中断是Yield调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行

区别

1. 软中断是执行中断指令产生的，而硬中断是由外设引发的
2. 硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器
3. 硬中断是可屏蔽的，软中断不可屏蔽
4. 硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部
5. 软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。

### 4.2 中断为什么要区分上半部和下半部？

Linux中断分为硬件中断和内部中断（异常），调用过程：外部中断产生->发送中断信号到中断控制器->通知处理器产生中断的中断号，让其进一步处理。

对于中断上半部和下半部的产生，为了中断处理过程中被新的中断打断，将中断处理一分为二，上半部登记新的中断，快速处理简单的任务，剩余复杂耗时的处理留给下半部处理，下半部处理过程中可以被中断，上半部处理时不可被中断。

### 4.3 中断下半部一般如何实现？

软中断、tasklet、工作队列

### 4.4 linux中断的响应执行流程

中断的响应流程：cpu接受中断->保存中断上下文跳转到中断处理历程->执行中断上半部->执行中断下半部->恢复中断上下文。。

### 4.5 中断的申请及何时执行(何时执行中断处理函数)

中断的申请request_irq的正确位置：应该是在第一次打开 、硬件被告知终端之前



## 5 Linux驱动模型  

### 5.1 字符设备驱动模型  

![image-20230727104123569](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727104123569.png)



#### 驱动初始化  

驱动初始化中涉及到一个设备描述结构的概念。

在任何一种驱动模型中，设备都会用内核中的一种结构来描述，这种结构成为设备描述结构。

字符设备在内核中使用struct cdev这种结构来描述。  

```c
struct cdev
{
struct kobject kobj;
struct module *owner;
const struct file_operations *ops; //设备操作集
struct list_head list;
dev_t dev; //设备号
unsigned int count; //设备数
};
```

count表明该类型设备的数目，如有两个串口，则count的值为2。

dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记相同类型的设备的不同个体。

如串口1和串口2使用同一驱动程序，则其主设备号相同，但次设备号不同。

Linux内核中使用 dev_t 类型来定义设备号， dev_t 这种类型其实质为32位的 unsigned int ，其中高12位为主设备号，低20位为次设备号。

```
1. 知道主设备号与次设备号，可通过 dev_t dev = MKDEV (主设备号，次设备号) 获得设备号；
2. 从设备号分解出主设备号：主设备号 = MAJOR(dev_t dev)
3. 从设备号分解出次设备号：次设备号=MINOR(dev_t dev)
```

主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：

1. 静态申请：开发者自己选择一个数字作为主设备号，然后通过函数register_chrdev_region向内核申请使用。这种方法的缺点是如果申请使用的设备号已经被内核中的其它驱动使用了，则申请失败
2. 动态分配：使用 alloc_chrdev_region 由内核分配一个可用的主设备号。因为内核知道哪些号已经被使用了，所以不会导致分配到已经被使用的号

既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用unregister_chrdev_region函数释放这些设备号。

ops是操作函数集。 file_operations 是一个很重要的结构，该结构的成员基本都是函数指针，并且是一些文件操作的函数的指针。

```c
struct file_operations 
{
struct module *owner;
loff_t(*llseek) (struct file *, loff_t, int);
ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);
ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);
ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);
ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);
int (*readdir) (struct file *, void *, filldir_t);
unsigned int (*poll) (struct file *, struct poll_table_struct *);
int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
int (*mmap) (struct file *, struct vm_area_struct *);
int (*open) (struct inode *, struct file *);
int (*flush) (struct file *);
int (*release) (struct inode *, struct file *);
int (*fsync) (struct file *, struct dentry *, int datasync);
int (*aio_fsync) (struct kiocb *, int datasync);
int (*fasync) (int, struct file *, int);
int (*lock) (struct file *, int, struct file_lock *);
ssize_t(*readv) (struct file *, const struct iovec *, unsigned long,loff_t *);
ssize_t(*writev) (struct file *, const struct iovec *, unsigned long,loff_t *);
ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void__user *);
ssize_t(*sendpage) (struct file *, struct page *, int, size_t, loff_t *,int);
unsigned long (*get_unmapped_area) (struct file *, unsigned long,unsigned long, unsigned long,unsigned long);
};
```

struct file_operations 是一个函数指针的集合，定义能在设备上进行的操作。

结构中的函数指针指向驱动中的函数，这些函数实现一个针对设备的操作, 对于不支持的操作则设置函数指针为 NULL。

例如：  

```c
struct file_operations dev_fops = {
.llseek = NULL,
.read = dev_read,
.write = dev_write,
.ioctl = dev_ioctl,
.open = dev_open,
.release = dev_release,
};
```

该结构体表示应用程序能够对设备文件使用函数 read() , write() ,等，但不能使用函数 llseek() 。

当执行到 read() 函数时，内核根据该结构体转移到驱动程序中的 dev_read 函数去执行。  

驱动初始化有四大步骤：

```
1. 分配
	cdev变量的定义可以采用静态和动态两种办法：
	静态分配： struct cdev mdev；
	动态分配： struct cdev *pdev = cdev_alloc()；
2. 初始化
	struct cdev的初始化使用cdev_init函数来完成。
	原型： cdev_init(struct cdev *cdev, const struct file_operations *fops)
	参数：
	cdev：待初始化的cdev结构
	fops：设备对应的操作函数集
3. 注册
	字符设备的注册使用cdev_add函数来完成。
	原型： cdev_add(struct cdev *p, dev_t dev, unsigned count)
	参数：
	p：待添加到内核的字符设备结构
	dev：设备号count：该类设备的设备个数
4. 硬件初始化
	根据相应硬件的数据手册完成初始化。
```

#### 实现设备操作

由 struct file_operations 可以看出，要实现的操作并不少，这里只介绍一些重要的操作。

```c
int (*open)(struct inode *, struct file *) //打开设备，响应open系统调用
int (*release)(struct inode *, struct file *);//关闭设备，响应close系统调用
loff_t (*llseek)(struct file *, loff_t, int) //重定位读写指针，响应lseek系统调用
ssize_t (*read)(struct file *, char __user *, size_t, loff_t *) //从设备读取数据，响应read系统调用
ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *) //向设备写入数据，响应write系统调用
```

以上几个函数涉及到了 struct inode 和 struct file 这两种结构体。

在Linux系统中，每一个打开的文件，在内核中都会关联一个 struct file 结构体，它由内核在打开文件时创建，在文件关闭后释放。

该结构体的重要成员有：

```c
loff_t f_pos /*文件读写指针*/
struct file_operations *f_op /*该文件所对应的操作*/
```

每一个存在于文件系统里面的文件都会关联一个inode 结构，该结构主要用来记录文件物理上的信息。

因此，它和代表打开文件的file结构是不同的。一个文件没有被打开时不会关联file结构，但是却会关联一个inode 结构。

该结构体重要的成员有：  

```c
dev_t i_rdev /*设备号*/
```

一个设备支持的函数操作又称为设备方法。

open设备方法是驱动程序用来为以后的操作完成初始化准备工作的。在大部分驱动程序中，open完成如下工作： 标明次设备号 ，启动设备。

release设备方法的作用与open相反，这个设备方法有时也称为close，它完成的工作是关闭设备。

read设备方法通常完成两件事情： 从设备中读取数据(属于硬件访问类操作) ，将读取到的数据返回给应用程序。

```c
ssize_t (*read)(struct file *filp,char __user *buff,size_t count,loff_t*offp)111
```

filp：与字符设备文件关联的file结构指针, 由内核创建。

buff ：从设备读取到的数据，需要保存到的位置。由read系统调用提供该参数。

count：请求传输的数据量，由read系统调用提供该参数。

offp：文件的读写位置，由内核从file结构中取出后，传递进来。

要注意的是，buff参数是来源于用户空间的指针，这类指针都不能被内核代码直接引用，必须使用专门的函数：

```c
int copy_to_user(void __user *to, const void *from, int n)
int copy_from_user(void *to, const void __user *from, int n)121212
```

其中 copy_to_user() 用于将内核数据传送给用户空间； copy_from_user() 用于将用户空间的数据传送给内核空间。

write设备方法通常完成两件事情： 从应用程序提供的地址中取出数据 ，将数据写入设备(属于硬件访问类操作)

函数原型： ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *)

#### 驱动注销  

驱动注销：当我们从内核中卸载驱动程序的时候，需要使用 cdev_del 函数来完成字符设备的注销。

一个驱动程序范例：  

```c
#include <linux/module.h>
#include <linux/types.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/cdev.h>
#include <asm/uaccess.h>
#include <linux/slab.h>

int dev1_registers[5];
int dev2_registers[5];
struct cdev cdev;
dev_t devno;
/*文件打开函数*/
int mem_open(struct inode *inode, struct file *filp)
{
/*获取次设备号*/
	int num = MINOR(inode->i_rdev);
	if (num==0)
	filp->private_data = dev1_registers;
	else if(num == 1)
	filp->private_data = dev2_registers;
	else
	return -ENODEV; //无效的次设备号
	return 0;
}
/*文件释放函数*/
int mem_release(struct inode *inode, struct file *filp)
{
	return 0;
}
/*读函数*/
static ssize_t mem_read(struct file *filp, char __user *buf, size_t size,loff_t *ppos)
{
	unsigned long p = *ppos;
	unsigned int count = size;
	int ret = 0;
	int *register_addr = filp->private_data; /*获取设备的寄存器基地址*/
	/*判断读位置是否有效*/
	if (p >= 5*sizeof(int))
	return 0;
	if (count > 5*sizeof(int) - p)
	count = 5*sizeof(int) - p;
	/*读数据到用户空间*/
	if (copy_to_user(buf, register_addr+p, count))
	{
		ret = -EFAULT;
	}
	else
	{
		*ppos += count;
		ret = count;
	}
	return ret;
}
/*写函数*/
static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos)
{
	unsigned long p = *ppos;
	unsigned int count = size;
	int ret = 0;
	int *register_addr = filp->private_data; /*获取设备的寄存器地址*/
/*分析和获取有效的写长度*/
	if (p >= 5*sizeof(int))
	return 0;
	if (count > 5*sizeof(int) - p)
	count = 5*sizeof(int) - p;
/*从用户空间写入数据*/
	if (copy_from_user(register_addr + p, buf, count))
	ret = -EFAULT;
	else
	{
		*ppos += count;
		ret = count;
	}
	return ret;
}
/* seek文件定位函数 */
static loff_t mem_llseek(struct file *filp, loff_t offset, int whence)
{
	loff_t newpos;
	switch(whence) 
    {
		case SEEK_SET:
			newpos = offset;
        	break;
		case SEEK_CUR:
			newpos = filp->f_pos + offset;
			break;
		case SEEK_END:
			newpos = 5*sizeof(int)-1 + offset;
			break;
		default:
			return -EINVAL;
	}
	if ((newpos<0) || (newpos>5*sizeof(int)))
	return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}
/*文件操作结构体*/
static const struct file_operations mem_fops =
{
	.llseek = mem_llseek,
	.read = mem_read,
	.write = mem_write,
	.open = mem_open,
	.release = mem_release,
};
/*设备驱动模块加载函数*/
static int memdev_init(void)
{
	/*初始化cdev结构*/
	cdev_init(&cdev, &mem_fops);
	/* 注册字符设备 */
	alloc_chrdev_region(&devno, 0, 2, "memdev");
	cdev_add(&cdev, devno, 2);
}
/*模块卸载函数*/
static void memdev_exit(void)
{
	cdev_del(&cdev); /*注销设备*/
	unregister_chrdev_region(devno, 2); /*释放设备号*/
}
MODULE_LICENSE("GPL");

module_init(memdev_init);
module_exit(memdev_exit);
```

### 5.2 LCD驱动模型

写个LCD驱动入口函数,需要以下4步:

1. 分配一个fb_info结构体: framebuffer_alloc();

2. 设置 fb_info

3. 设置硬件相关的操作

4. 使能LCD,并注册 fb_info: register_framebuffer()

   

需要用到的函数:

```c
void *dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t
*handle, gfp_t gfp); //分配DMA缓存区给显存
//返回值为:申请到的DMA缓冲区的虚拟地址,若为NULL,表示分配失败,则需要使用dma_free_writecombine()释放内存,避免内存泄漏
//参数如下:
//*dev:指针,这里填0,表示这个申请的缓冲区里没有内容
//size:分配的地址大小(字节单位)
//*handle:申请到的物理起始地址
//gfp:分配出来的内存参数,标志定义在<linux/gfp.h>,常用标志如下:
//GFP_ATOMIC 用来从中断处理和进程上下文之外的其他代码中分配内存. 从不睡眠.
//GFP_KERNEL 内核内存的正常分配. 可能睡眠.
//GFP_USER 用来为用户空间页来分配内存; 它可能睡眠.
```

分配一段DMA缓存区,分配出来的内存会禁止cache缓存(因为DMA传输不需要CPU)。

它和dma_alloc_coherent () 函数相似,不过 dma_alloc_coherent () 函数是分配出来的内存会禁止cache缓存以及禁止写入缓冲区  

```c
dma_free_writecombine(dev,size,cpu_addr,handle); //释放缓存,cpu_addr:虚拟地址,handle:物理地址
```

释放DMA缓冲区, dev和size参数和上面的一样  

```c
struct fb_info *framebuffer_alloc(size_t size, struct device *dev); //申请一个fb_info结构体,size:额外的内存,*dev:指针, 这里填0,表示这个申请的结构体里没有内容
int register_framebuffer(struct fb_info *fb_info); //向内核中注册fb_info结构体,若内存不够,注册失败会返回负数
int unregister_framebuffer(struct fb_info *fb_info) ;//注销内核中fb_info结构体
```

需要用到的结构体:

fb_info 结构体如下:

```c
struct fb_info {
... ...
	struct fb_var_screeninfo var; //可变的参数
	struct fb_fix_screeninfo fix; //固定的参数
... ...
	struct fb_ops *fbops; //操作函数
... ...
	char __iomem *screen_base; //显存虚拟起始地址
	unsigned long screen_size; //显存虚拟地址长度
	void *pseudo_palette;
//假的16色调色板,里面存放了16色的数据,可以通过8bpp数据来找到调色板里面的16色颜色索引值,模拟出16色颜色来,节省内存,不需要的话就指向一个不用的数组即可
... ...
};
```

其中操作函数 fb_info-> fbops 结构体写法如下:  

```c
static struct fb_ops s3c_lcdfb_ops = {
	.owner = THIS_MODULE,
	.fb_setcolreg = my_lcdfb_setcolreg,//设置调色板fb_info->pseudo_palette,自己构造该函数
	.fb_fillrect = cfb_fillrect, //填充矩形,用/drivers/video/cfbfillrect.c里的函数即可
	.fb_copyarea = cfb_copyarea, //复制数据,用/drivers/video/cfbcopyarea.c里的函数即可
	.fb_imageblit = cfb_imageblit, //绘画图形,用/drivers/video/imageblit.c里的函数即可
};
```

固定的参数 fb_info-> fix 结构体如下:  

```c
struct fb_fix_screeninfo {
char id[16]; //id名字
unsigned long smem_start; //framebuffer物理起始地址
__u32 smem_len; //framebuffer长度,字节为单位
__u32 type; //lcd类型,默认值0即可
__u32 type_aux; //附加类型,为0
__u32 visual; //画面设置,常用参数如下
// FB_VISUAL_MONO01 0 单色,0:白色,1:黑色
// FB_VISUAL_MONO10 1 单色,1:白色,0:黑色
// FB_VISUAL_TRUECOLOR 2 真彩(TFT:真彩)
// FB_VISUAL_PSEUDOCOLOR 3 伪彩
// FB_VISUAL_DIRECTCOLOR 4 直彩
__u16 xpanstep; /*如果没有硬件panning就赋值为0 */
__u16 ypanstep; /*如果没有硬件panning就赋值为0 */
__u16 ywrapstep; /*如果没有硬件ywrap就赋值为0 */
__u32 line_length; /*一行的字节数 ,例:(RGB565)240*320,那么这里就等于240*16/8 */
/*以下成员都可以不需要*/
    unsigned long mmio_start; /*内存映射IO的起始地址,用于应用层直接访问
寄存器,可以不需要*/
__u32 mmio_len; /* 内存映射IO的长度,可以不需要*/
__u32 accel;
__u16 reserved[3];
};
```

可变的参数 fb_info-> var 结构体如下:  

```c
structfb_var_screeninfo{
__u32xres; /*可见屏幕一行有多少个像素点*/
__u32 yres; /*可见屏幕一列有多少个像素点*/
__u32 xres_virtual; /*虚拟屏幕一行有多少个像素点 */
__u32 yres_virtual; /*虚拟屏幕一列有多少个像素点*/
__u32 xoffset; /*虚拟到可见屏幕之间的行偏移,若可见和虚拟的分辨率一样,就直接设为0*/
__u32 yoffset; /*虚拟到可见屏幕之间的列偏移*/
__u32 bits_per_pixel; /*每个像素的位数即BPP,比如:RGB565则填入16*/
__u32 grayscale; /*非0时，指的是灰度,真彩直接填0即可*/
struct fb_bitfield red; //fb缓存的R位域, fb_bitfield结构体成员如下:
//__u32 offset; 区域偏移值,比如RGB565中的R,就在第11位
//__u32 length; 区域长度,比如RGB565的R,共有5位
//__u32 msb_right; msb_right ==0,表示数据左边最大, msb_right!=0,表示数据右边最大
struct fb_bitfield green; /*fb缓存的G位域*/
struct fb_bitfield blue; /*fb缓存的B位域*/ /*以下参数都可以不填,默认为0*/
struct fb_bitfield transp; /*透明度,不需要填0即可*/
__u32nonstd; /* != 0表示非标准像素格式*/
__u32 activate; /*设为0即可*/
__u32height; /*外设高度(单位mm),一般不需要填*/
__u32width; /*外设宽度(单位mm),一般不需要填*/
__u32 accel_flags; /*过时的参数,不需要填*/
/* 除了pixclock本身外，其他的都以像素时钟为 单位*/
__u32pixclock; /*像素时钟(皮秒)*/
__u32 left_margin; /*行切换，从同步到绘图之间的延迟*/
__u32right_margin; /*行切换，从绘图到同步之间的延迟*/
__u32upper_margin; /*帧切换，从同步到绘图之间的延迟*/
__u32lower_margin; /*帧切换，从绘图到同步之间的延迟*/
__u32hsync_len; /*水平同步的长度*/
__u32 vsync_len; /*垂直同步的长度*/
__u32 sync;
__u32 vmode;
__u32 rotate;
__u32reserved[5]; /*保留*/
}
```

在驱动init入口函数中:

1. 分配一个 fb_info 结构体

2. 设置 fb_info

   2.1 设置固定的参数 fb_info-> fix 。id,lcd的名字

   2.2 设置可变的参数 fb_info-> var 。可见屏幕一行有多少个像素点，虚拟屏幕一行有多少个像素点，每个像素的位数即BPP,比如:RGB565则填入16

   2.3 设置操作函数 fb_info-> fbops

   2.4 设置 fb_info 其它的成员， my_lcdfb_setcolreg 调色板， cfb_copyarea 复制数据

3. 设置硬件相关的操作

   3.1 配置LCD引脚 GPBcon = ioremap(0x56000010, 8); GPBdat = GPBcon+1;

   3.2 根据LCD手册设置LCD控制器 VSYNC，HSYNC 等参数

   3.3 分配显存(framebuffer),把地址告诉LCD控制器和 fb_info

4. 开启LCD,并注册 fb_info : register_framebuffer()

   4.1 直接在init函数中开启LCD(后面讲到电源管理,再来优化)，控制LCDCON5允许PWREN信号,然后控制LCDCON1输出PWREN信号,输出GPB0高电平来开背光

   4.2 注册 fb_info

在驱动exit出口函数中:

1. 卸载内核中的 fb_info
2. 控制LCDCON1关闭PWREN信号,关背光,iounmap注销地址
3. 释放DMA缓存地址 dma_free_writecombine()
4. 释放注册的 fb_info

LCD驱动完整代码如下所示：  

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/string.h>
#include <linux/mm.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/fb.h>
#include <linux/init.h>
#include <linux/dma-mapping.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>
#include <linux/wait.h>
#include <linux/platform_device.h>
#include <linux/clk.h>
#include <asm/io.h>
#include <asm/uaccess.h>
#include <asm/div64.h>
#include <asm/mach/map.h>
#include <asm/arch/regs-lcd.h>
#include <asm/arch/regs-gpio.h>
#include <asm/arch/fb.h>
/*LCD : 480*272 */
#define LCD_xres 480 //LCD 行分辨率
#define LCD_yres 272 //LCD列分辨率
/* GPIO prot */
static unsigned long *GPBcon;
static unsigned long *GPCcon;
static unsigned long *GPDcon;
static unsigned long *GPGcon; //GPG4:控制LCD信号
static unsigned long *GPBdat; //GPB0: 控制背光
/* LCD control */
struct lcd_reg{
unsigned long lcdcon1;
unsigned long lcdcon2;
unsigned long lcdcon3;
unsigned long lcdcon4;
unsigned long lcdcon5;
unsigned long lcdsaddr1;
unsigned long lcdsaddr2;
unsigned long lcdsaddr3 ;
unsigned long redlut;
unsigned long greenlut;
unsigned long bluelut;
unsigned long reserved[9];
unsigned long dithmode;
unsigned long tpal ;
unsigned long lcdintpnd;
unsigned long lcdsrcpnd;
unsigned long lcdintmsk;
unsigned long tconsel;
};
static struct lcd_reg *lcd_reg;
static struct fb_info *my_lcd; //定义一个全局变量
static u32 pseudo_palette[16]; //调色板数组,被fb_info->pseudo_palette调用
static inline unsigned int chan_to_field(unsigned int chan, structfb_bitfield *bf)
{
/*内核中的单色都是16位,默认从左到右排列,比如G颜色[0x1f],那么chan就等于0XF800*/
	chan &= 0xffff;
	chan >>= 16 - bf->length; //右移,将数据靠到位0上
	return chan << bf->offset; //左移一定偏移值,放入16色数据中对应的位置
}
static int my_lcdfb_setcolreg(unsigned int regno, unsigned int red,unsigned int green, unsigned int blue,unsigned int transp,struct fb_info *info)
//设置调色板函数,供内核调用
{
	unsigned int val;
	if (regno >=16) //调色板数组不能大于15
	return 1;
/* 用red,green,blue三个颜色值构造出16色数据val */
	val = chan_to_field(red, &info->var.red);
	val |= chan_to_field(green, &info->var.green);
	val |= chan_to_field(blue, &info->var.blue);
	((u32 *)(info->pseudo_palette))[regno] = val; //放到调色板数组中
	return 0;
}
static struct fb_ops my_lcdfb_ops = {
	.owner = THIS_MODULE,
	.fb_setcolreg = my_lcdfb_setcolreg,//调用my_lcdfb_setcolreg()函数,来设置调色板fb_info-> pseudo_palette
	.fb_fillrect = cfb_fillrect, //填充矩形
	.fb_copyarea = cfb_copyarea, //复制数据
	.fb_imageblit = cfb_imageblit, //绘画图形,
};
static int lcd_init(void)
{
/*1.申请一个fb_info结构体*/
	my_lcd= framebuffer_alloc(0,0);
/*2.设置fb_info*/
/* 2.1设置固定的参数fb_info-> fix */
/*my_lcd->fix.smem_start 物理地址后面注册MDA缓存区设置*/
	strcpy(my_lcd->fix.id, "mylcd"); //名字
	my_lcd->fix.smem_len =LCD_xres*LCD_yres*2; //地址长
	my_lcd->fix.type =FB_TYPE_PACKED_PIXELS; // TFT STN
	my_lcd->fix.visual =FB_VISUAL_TRUECOLOR; //真彩色
    my_lcd->fix.line_length =LCD_xres*2; //LCD 一行的字节
/* 2.2 设置可变的参数fb_info-> var */
	my_lcd->var.xres =LCD_xres; //可见屏X 分辨率
	my_lcd->var.yres =LCD_yres; //可见屏y 分辨率
	my_lcd->var.xres_virtual =LCD_xres; //虚拟屏x分辨率
	my_lcd->var.yres_virtual =LCD_yres; //虚拟屏y分辨率
	my_lcd->var.xoffset = 0; //虚拟到可见屏幕之间的行偏移
	my_lcd->var.yoffset =0; //虚拟到可见屏幕之间的行偏移
	my_lcd->var.bits_per_pixel=16; //像素为16BPP
	my_lcd->var.grayscale = 0; //灰色比例
	my_lcd->var.red.offset = 11;
	my_lcd->var.red.length = 5;
	my_lcd->var.green.offset = 5;
	my_lcd->var.green.length = 6;
	my_lcd->var.blue.offset = 0;
	my_lcd->var.blue.length = 5;
/* 2.3 设置操作函数fb_info-> fbops */
	my_lcd->fbops = &my_lcdfb_ops;
/* 2.4 设置fb_info 其它的成员 */
/*my_lcd->screen_base 虚拟地址在后面注册MDA缓存区设置*/
	my_lcd->pseudo_palette =pseudo_palette; //保存调色板数组
	my_lcd->screen_size =LCD_xres * LCD_yres *2; //虚拟地址长
/*3 设置硬件相关的操作*/
/*3.1 配置LCD引脚*/
	GPBcon = ioremap(0x56000010, 8);
	GPBdat = GPBcon+1;
	GPCcon = ioremap(0x56000020, 4);
	GPDcon = ioremap(0x56000030, 4);
	GPGcon = ioremap(0x56000060, 4);
	*GPBcon &=~(0x03<<(0*2));
	*GPBcon |= (0x01<<(0*2)); //PGB0背光
	*GPBdat &=~(0X1<<0); //关背光
	*GPCcon =0xaaaaaaaa;
	*GPDcon =0xaaaaaaaa;
	*GPGcon |=(0x03<<(4*2)); //GPG4:LCD信号
/*3.2 根据LCD手册设置LCD控制器,参考之前的裸机驱动*/
	lcd_reg=ioremap(0X4D000000, sizeof( lcd_reg) );
/*HCLK:100Mhz */
	lcd_reg->lcdcon1 = (4<<8) | (0X3<<5) | (0x0C<<1) ;
	lcd_reg->lcdcon2 = ((3)<<24) | (271<<14) | ((1)<<6) |((0)<<0);
	lcd_reg->lcdcon3 = ((16)<<19) | (479<<8) | ((10));
	lcd_reg->lcdcon4 = (4);
	lcd_reg->lcdcon5 = (1<<11) | (1<<9) | (1<<8) |(1<<0);
	lcd_reg->lcdcon1 &=~(1<<0); // 关闭PWREN信号输出
	lcd_reg->lcdcon5 &=~(1<<3); //禁止PWREN信号
/* 3.3 分配显存(framebuffer),把地址告诉LCD控制器和fb_info*/
	my_lcd->screen_base=dma_alloc_writecombine(0,my_lcd->fix.smem_len,&my_lcd->fix.smem_start, GFP_KERNEL);
/*lcd控制器的地址必须是物理地址*/
	lcd_reg->lcdsaddr1 =(my_lcd->fix.smem_start>>1)&0X3FFFFFFF; //保存缓冲起始地址A[30:1]
	lcd_reg->lcdsaddr2 =((my_lcd->fix.smem_start+my_lcd->screen_size)>>1)&0X1FFFFF; //保存存缓冲结束地址A[21:1]
	lcd_reg->lcdsaddr3 =LCD_xres& 0x3ff; //OFFSIZE[21:11]:保存LCD上一行结尾和下一行开头的地址之间的差 
//PAGEWIDTH [10:0]:保存LCD一行占的宽度(半字数为单位)
/*4开启LCD,并注册fb_info: register_framebuffer()*/
/*4.1 直接在init函数中开启LCD(后面讲到电源管理,再来优化)*/
	lcd_reg->lcdcon1 |=1<<0; //输出PWREN信号
	lcd_reg->lcdcon5 |=1<<3; //允许PWREN信号
	*GPBdat |=(0X1<<0); //开背光
/*4.2 注册fb_info*/
	register_framebuffer(my_lcd);
	return 0;
}
static int lcd_exit(void)
{
/* 1卸载内核中的fb_info*/
	unregister_framebuffer(my_lcd);
/*2 控制LCDCON1关闭PWREN信号,关背光,iounmap注销地址*/
	lcd_reg->lcdcon1 &=~(1<<0); // 关闭PWREN信号输出
	lcd_reg->lcdcon5 &=~(1<<3); //禁止PWREN信号
	*GPBdat &=~(0X1<<4); //关背光
	iounmap(GPBcon);
	iounmap(GPCcon);
	iounmap(GPDcon);
	iounmap(GPGcon);
/*3.释放DMA缓存地址dma_free_writecombine()*/
	dma_free_writecombine(0,my_lcd->screen_size,my_lcd->screen_base,my_lcd->fix.smem_start);
/*4.释放注册的fb_info*/
	framebuffer_release(my_lcd);
	return 0;
}
module_init(lcd_init);
module_exit(lcd_exit);
MODULE_LICENSE("GPL");
```

### 5.3 总线设备驱动模型

自内核2.6版本开始，需要关注的是总线、设备和驱动这3个实体，总线将设备和驱动绑定。在Linux内核系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会去寻找一个对应的设备进行匹配。匹配的的工作由总线来完成。

**在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总线的设备开发了一种虚拟总线——platform总线。**

将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备1后也可以使用这个驱动，让驱动程序可以重用。这体现了Linux驱动的软件架构设计的思想。

按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，**比如i2c总线上的eeprom，eeprom作为设备，eeprom的驱动都挂接在i2c驱动上**。但是在嵌入式系统中，**soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）**，所以Linux发明了一种虚拟总线，称为**platform总线，相应的设备称为platform_device（控制器设备），对应的驱动为platform_driver（控制器驱动），用platform总线来承载这些相对特殊的系统。**

注意：**所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段**，例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，**platform 驱动只是在字符设备驱动外套一层platform_driver 的外壳**。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；当然你也可以选择不用，不过就失去了一些platform带来的便利；设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。

![image-20230727112031443](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727112031443.png)

下面分析下总线设备驱动模型的匹配过程

一边的“device”结构体和另一边的“较稳定的 drivice 代码”的联系：“device_add()”除了将“devcie”结构放到 bus 的“dev 链表”之外，还会从另一边的“drv”链表中取表元即某个“driver”结构，用总线里的一个（.match）函数来作比较，看另一边的“driver”是否支持一边的“device”。若是能够支持，则接着调用软件驱动部分的“.probe”函数。

"driver_register()"会将“bus_drv_dev”模型中的较稳定代码“driver”结构体放到虚拟总线的某个链表（drv 链表）中。从另一边的“dev”链表中取出每一个“device”结构用 bus 中的“.match”函数来作比较，若支持则调用“.probe”函数。左右两个注册就建立起来的一种机制。在“.probe”函数中做的事件由自已决定，打印一句话，或注册一个字符设备，再或注册一个“input_dev”结构体等等都是由自已决定。强制的把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的“driver”只是个结构体不要被这个名字迷惑，“device”也只是个结构体，里面放什么内容都是由自已决定的。

### 5.4 输入子系统模型  

每个硬件都有一个input_dev结构体，每个软件都有一个input_handler结构体。

input_dev和input_handler分别通过input_register_device(),input_register_handler()向核心层注册硬件和软件。  

```c
int input_register_device(struct input_dev *dev) //*dev:要注册的驱动设备
{
... ...
list_add_tail(&dev->node, &input_dev_list); //(1)放入链表中
... ...
list_for_each_entry(handler, &input_handler_list, node) //(2)
input_attach_handler(dev, handler);
... ...
}
```

![image-20230727112250007](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727112250007.png)

从input_dev方向分析： input设备在增加到input_dev_list链表上之后，会查找 input_handler_list事件处理链表上的handler进行匹配，这里的匹配 方式与总线设备驱动模型的device和driver匹配过程很相似，所有的input_device都挂在input_dev_list上，所有类型的事件都挂在input_handler_list 上，进行“匹配相亲”。如果匹配上了，就调用input_handler的connect函数进行连接。

设备就是在此时注册的

从input_handler方向分析：将handler挂到链表input_handler_list下，然后遍历input_dev_list链表,查找并匹配输入设备对应的事件处理层，如果匹配上了，就调用connect函数进行连接，并创建input_handle结构。所以，不管新添加input_dev还是input_handler,都会进入input_attach_handler()判断两者id是否有支持, 若两者支持便进行连接。



### 5.5 platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没  ?

总线，设备，驱动。

匹配规则就是当有一个新的设备挂起时，总线被唤醒，match函数被调用，用device名字去跟本总线下的所有驱动名字去比较。

相反就是用驱动的名字去device链表中和所有device的名字比较。如果匹配上，才会调用驱动中的probe函数，否则不调用。

至于先后顺序，鉴于个人理解，不会有影响，不管谁先谁后，bus都会完成匹配工作。

谈谈对Linux设备驱动模型的认识：设备驱动模型的出现主要有三个好处，设备与驱动分离，驱动可移植性增强；设备驱动抽象结构以总线结构表示看起来更加清晰明了，谁是属于哪一条bus的；最后，就是大家最熟悉的热插拔了，设备与驱动分离，很好的奠定了热插拔机制。  



## 6 Linux内核  

### 6.1 内核镜像格式有几种？分别有什么区别？

1. uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是可以直接执行的。但是**这种格式不能用来烧录下载**。我们用来烧录下载的是uboot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的

2.  linux内核经过编译后也会生成一个elf格式的可执行程序，叫**vmlinux或vmlinuz**，这个就是**原始的未经任何处理加工的原版内核elf文件**；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫Image（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是**缩减大小，节省磁盘**）

3.  原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的前端附加了一部分解压缩代码。构成了一个压缩格式的镜像就叫zImage。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）

4.  uboot为了启动linux内核，还发明了一种内核格式叫uImage。uImage是由zImage加工得到的， uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。

   **这个加工过程其实就是在zImage前面加上64字节的uImage的头信息即可**

5.  原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。

   **但是所有的uboot肯定都支持uImage启动**

6.  如果直接在kernel底下去make uImage会提供mkimage command not found。解决方案是去uboot/tools下cp mkimage /usr/local/bin/，复制mkimage工具到系统目录下。再去make uImage即可。

   通过上面的介绍我们了解了内核镜像的各种格式，如果通过uboot启动内核，Linux必须为**uImage格式**  

### 6.2 内核中申请内存有哪几个函数？有什么区别？  

**kmalloc**  

```c
void *kmalloc(size_t size, gfp_t flags)
```

kmalloc是**内核中**最常用的一种内存分配方式，它通过调用kmem_cache_alloc函数来实现。

kmalloc一次最多能申请的内存大小由include/linux/Kmalloc_size.h的内容来决定，

在默认的2.6.18内核版本中， kmalloc一次最多能申请大小为131702B也就是**128KB字节**的连续物理内存。

测试结果表明，如果试图用kmalloc函数分配大于128KB的内存，编译不能通过  

**vmalloc**  

```c
 void *vmalloc(unsigned long size)
```

前面几种内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，

这是就可以分配一段线性连续，物理不连续的地址，带来的好处是一次**可以分配较大块的内存**。

图3-1表示的是vmalloc分配的内存使用的地址范围。vmallocvmalloc对一次能分配的内存大小没有明确限制。

出于性能考虑，应谨慎使用vmalloc函数。在测试过程中，**最大能一次分配1GB的空间**。  

**dma_alloc_coherent**  

```c
void *dma_alloc_coherent(struct device *dev, size_t size,ma_addr_t *dma_handle, gfp_t gfp)
```

DMA是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与，使用DMA机制能大幅提高与设备通信的吞吐量。

DMA操作中，涉及到CPU高速缓存和对应的内存数据一致性的问题，必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题， 

dma_alloc_coherent和get_free_pages函数实现差别不大，前者实际是调用alloc_pages函数来分配内存，因此一次分配内存的大小限制和后者一样。

__get_free_pages分配的内存同样可以用于DMA操作。测试结果证明，dma_alloc_coherent函数一次能分配的最大内存也为4M。  

**ioremap**  

```c
void * ioremap (unsigned long offset, unsigned long size)
```

ioremap是一种更直接的内存“分配”方式，使用时直接指定物理起始地址和需要分配内存的大小，然后将该段物理地址映射到内核地址空间。

ioremap用到的物理地址空间都是事先确定的，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。

ioremap多用于设备驱动，可以让CPU直接访问外部设备的IO空间。

ioremap能映射的内存由原有的物理内存空间决定，所以没有进行测试。  

### 6.3 什么是内核空间，用户空间？  

对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）

也就是说**一个进程的最大地址空间为 4G**

操作系统的核心是**内核(kernel)**，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限

为了保证内核的安全，现在的操作系统一般都**强制用户进程不能直接操作内核**

具体的实现方式基本都是由**操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间**

针对 **Linux 操作系统**而言，**最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用，称为内核空间**

而**较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为用户空间**

每个进程的 4G 地址空间中，最高 **1G** 都是一样的，即**内核空间**。

只有**剩余的 3G 才归进程自己使用**。

换句话说就是， **最高 1G 的内核空间是被所有进程共享的**

下图描述了每个进程 4G 地址空间的分配情况：

![image-20230727113728374](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727113728374.png)

### 6.4 为什么需要区分内核空间与用户空间？  

在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。

如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。

所以，CPU 将指令分为**特权指令**和**非特权指令**，对于**那些危险的指令，只允许操作系统及其相关模块使用**，普通应用程序只能使用那些不会造成灾难的指令。

比如 Intel 的 CPU **将特权等级分为 4 个级别： Ring0~Ring3**。

其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当**进程运行在Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态**。

### 6.5 什么是内核态和用户态？

当**进程运行在内核空间时就处于内核态**，而**进程运行在用户空间时则处于用户态**。

在**内核态**下，进程运行在内核地址空间中，此时 CPU 可以**执行任何指令**。**运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问**。

在**用户态**下，进程运行在用户地址空间中，**被执行的代码要受到 CPU 的诸多检查**，它们只能访问映射其地址空间的页表项中规定的  用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I/O 许可位图(I/O Permission Bitmap)中规定的可访问端口进行直接访问。

对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。

对于 Linux 来说，通过区分内核空间和用户空间的设计，**隔离了操作系统代码**(操作系统的代码要比应用程序的代码健壮很多)与**应用程序代码**。

即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。

所以，区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性。

### 6.6 用户空间与内核通信方式有哪些？

#### 6.6.1. 使用API    

```c
get_user(x，ptr) //在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。
put_user(x，ptr) //在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。
Copy_from_user()/copy_to_user() //主要应用于设备驱动读写函数中，通过系统调用触发。
```

#### 6.6.2 使用proc文件系统

和sysfs文件系统类似，也可以作为内核空间和用户空间交互的手段。

/proc 文件系统是一种虚拟文件系统，通过他可以作为一种linux内核空间和用户空间的。

与普通文件不同，这里的虚拟文件的内容都是动态创建的。使用/proc文件系统的方式很简单。

调用create_proc_entry，返回一个proc_dir_entry指针，然后去填充这个指针指向的结构就好了

#### 6.6.3 使用sysfs文件系统+kobject

每个在内核中注册的kobject都对应着sysfs系统中的一个目录。

可以通过读取根目录下的sys目录中的文件来获得相应的信息。

除了sysfs文件系统和proc文件系统之外，一些其他的虚拟文件系统也能同样达到这个效果

#### 6.6.4 netlink

netlink socket提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。

相比于其他的用户态和内核态IPC机制，netlink有几个好处：

1.使用自定义一种协议完成数据交换，不需要添加一个文件等

2.可以支持多点传送

3.支持内核先发起会话

4.异步通信，支持缓存机制

#### 6.6.5 文件

应该说这是一种比较笨拙的做法，不过确实可以这样用。

当处于内核空间的时候，直接操作文件，将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。

下面是一个简单的测试程序，在内核态中，程序会向“/home/melody/str_from_kernel”文件中写入一条字符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了

#### 6.6.6 使用mmap系统调用

可以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。

一方面可以在driver中修改Struct file_operations结构中的mmap函数指针来重新实现一个文件对应的映射操作。

另一方面，也可以直接打开/dev/mem文件，把物理内存中的某一页映射到进程空间中的地址上。

其实，除了重写Struct file_operations中mmap函数，我们还可以重写其他的方法如ioctl等，来达到驱动内核空间和用户空间通信的方式。

#### 6.6.7 信号

从内核空间向进程发送信号。

这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。

### 6.7 内核链表为什么具有通用性？

内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就想到了使用通用链表来处理，通用链表看似神秘，实际上就是**双向循环链表**，这个链表的每个节点都是只有指针域，没有任何数据域。

![image-20230727114934958](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727114934958.png)    

使用通用链表的好处是：

1. 通用链表中每个节点中**没有数据域**，也就是说无论数据结构有多复杂在链表中**只有前后级指针**
2. 如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要**在结构体中包含节点的字段即可**
3.  双向链表可以从任意一个节点的前后遍历整个链表，遍历非常方便
4. 使用循环链表使得可以不断地循环遍历管理节点，像**进程的调度**：操作系统会把**就绪的进程**放在一个**管理进程的就绪队列的通用链表中管理起来**，循环不断地，为他们分配时间片，获得cpu进行周而复始的进程调度。

### 6.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？  

1. 应用层调用open函数，在VFS层(虚拟机文件系统)中找到**struct inode结构体**，判断是字符设备还是块设备，根据设备号，可以找到对应的驱动程序
2. 在驱动层中，每个字符设备都有一个**struct cdev结构体**，这个结构体通过struct inode结构体中的i_cdev把连接起VFS层和驱动层，struct cdev结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的**操作函数接口**
3.  struct cdev结构体中的**struct file结构体**记录了操作字符设备的一些函数，比如open read write函数等。struct file结构体其实是在VFS层的，通过struct file结构体指针指向驱动层的struct file结构体将驱动层函数和VFS层链接起来
4. 任务完成，VFS层会给应用返回一个**文件描述符（fd）。这个fd是和struct file结构体对应的**。

### 6.9 怎样申请大块内核内存？

**vmalloc**  

## 7 设备驱动  

### 7.1 主设备号和次设备号的用途  

主设备号：主设备号标识设备对应的特定的驱动程序。

虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织。

次设备号：次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备。

依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。

### 7.2 字符型驱动设备怎么创建设备文件？  

1. 手动创建mknod /dev/led c 250 0 ，其中dev/led 为设备节点 ,c 代表字符设备, 250代表主设备号, 0代表次设备号
2. 自动创建UDEV/MDEV是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后，在 /etc/init.d/rcS 脚本文件中会执行 mdev -s 自动创建设备节点。

### 7.3 设备驱动程序中如何注册一个字符设备?  

注册一个字符设备驱动有两种方法：

1. void cdev_init(struct cdev *cdev, struct file_operations *fops)

该注册函数可以将cdev结构嵌入到自己的设备特定的结构中。

cdev是一个指向结构体cdev的指针，而fops是指向一个类似于f file_operations结构（可以是file_operations结构，但不限于该结构）的指针

2. int register_chrdev(unsigned int major, const char *namem , struct fileoperations *fopen);  

该注册函数是早期的注册函数，major是设备的主设备号，name是驱动程序的名称，而fops是默认的file_operations结构（这是只限于file_operations结构）。对于register_chrdev的调用将为给定的主设备号注册0－255作为次设备号，并为每个 设备建 立一个对应的默认cdev结构。  



### 7.4 /dev/下面的设备文件是怎么创建出来的？  

1. devfs机制
2. udev机制
3. 手动创建设备节点  

其实就是现在常用的device_create()、class_create()这一套接口，所谓udev是上层用户空间程序，是基于驱动中创建使用了这两个接口而起作用的，但是udev在日常开发中几乎接触不到，我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给udev去做了，有想深究它具体实现原理的那就自己去研究吧，我觉得会用就行了；



### 7.5 Linux设备中字符设备和块设备有什么主要区别?

Linux中I/O设备分为两类：块设备和字符设备。

两种设备本身没有严格限制，但是，基于不同的功能进行了分类。

字符设备：提供**连续的数据流**，应用程序可以**顺序**读取，通常不支持随机存取。

相反，此类设备**支持按字节/字符来读写数据**。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。

块设备：应用程序**可以随机访问设备数**据，程序**可自行确定读取数据的位置**。

硬盘是典型的块设备，应用程序可以寻址磁盘上的任何位置，并由此读取数据。

此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等。

### 7.6 驱动中操作物理绝对地址为什么要先ioremap？ 

ioremp是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空间上去，便于操作。为什么非要映射呢，因为保护模式下的CPU只认虚拟地址，不认物理地址，给它物理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟CPU对接，从而操作寄存器   

### 7.7 insmod，rmmod一个驱动模块,会执行模块中的哪个函数？在设计上要注意哪些问题？

分别会执行 module_init() 和 module_exit() 指定的init函数和exit函数。要注意的就是，尽量使在init函数中出现的资源申请及使用，都要有对应的释放操作在exit中，即init申请，eixt释放。    

### 7.8 NAND驱动的probe流程  

probe 函数就会与NAND 芯片进行，主要做的事情主要包括这几个方面：读取NAND 芯片的ID ，然后查表得到这片NAND 芯片的如厂商，page size ，erase size 以及chip size 等信息，接着，根据struct nand_chip 中options 的值的不同，或者在NAND 芯片中的特定位置查找bad block table ，或者scan整个NAND 芯片，并在内存中建立bad block table 。说起来复杂，但其实所有的这些动作，都可以在MTD 提供的一个叫做nand_scan 的函数中完成

### 7.9 Linux驱动开发中，常用的调试方法有哪些？

利用printk，查看OOP消息，利用strace，利用内核内置的hacking选项，利用ioctl方法，利用/proc 文件系统，使用kgdb。    

## 8 Linux驱动开发常用函数

### 8.1 ioremap    

```c
void * __ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags)
void *ioremap(unsigned long phys_addr, unsigned long size)
```

入口： phys_addr：要映射的起始的IO地址； 

size：要映射的空间的大小；

flags：要映射的IO空间的和权限有关的标志；

phys_addr：是要映射的物理地址size：是要映射的长度，单位是字节

头文件：io.h

主要功能

将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问。

ioremap是内核提供的用来映射外设寄存器到主存的函数，我们要映射的地址已经从pci_dev中读了出来（上一步），这样就水到渠成的成功映射了而不会和其他地址有冲突。映射完了有什么效果呢？我举个例子，比如某个网卡有100 个寄存器，他们都是连在一块的，位置是固定的，假如每个寄存器占4个字节那么一共400个字节的空间被映射到内存成功后，ioaddr就是这段地址的开头（注意ioaddr是虚拟地址，而mmio_start是物理地址，它是BIOS得到的，肯定是物理地址，而保护模式下CPU不认物理地址，只认虚拟地址），ioaddr+0就是第一个寄存器的地址，ioaddr+4就是第二个寄存器地址（每个寄存器占4个字节），以此类推，我们就能够在内存中访问到所有的寄存器进而操控他们了  

### 8.2 open  

```c
int open( const char * pathname, int flags);
int open( const char * pathname,int flags, mode_t mode);
```

参数说明

pathname ：文件的名称，可以包含（绝对和相对）路径

flags：文件打开模式

mode: 用来规定对该文件的所有者，文件的用户组及系统中其他用户的访问权限，则文件权限为： mode&(~umask)

### 8.3 read  

```c
ssize_t read(int fd, void * buf, size_t count);
```

函数说明

read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。

返回值

返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据。若参数count 为0, 则read()不会有作用并返回0。

注意

read时fd中的数据如果小于要读取的数据，就会引起阻塞。read的用法比write较为简单，此处不叙述过多。

### 8.4 write

```c
ssize_t write (int fd, const void * buf, size_t count);
```

函数说明

write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内。

返回值

如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。

说明

1. write()函数返回值一般无0，只有当如下情况发生时才会返回0： write(fp, p1+len, (strlen(p1)-len)中第三参数为0，此时write()什么也不做，只返回0。
2. write()函数从buf写数据到fd中时，若buf中数据无法一次性读完，那么第二次读buf中数据时，其读位置指针（也就是第二个参数buf）不会自动移动，需要程序员编程控制。而不是简单的将buf首地址填入第二参数即可。如可按如下格式实现读位置移动：write(fp, p1+len, (strlen(p1)-len)。 这样write第二次循环时变会从p1+len处写数据到fp, 之后的也由此类推，直至(strlen(p1)-len变为0。  
3. 在write一次可以写的最大数据范围内（貌似是BUFSIZ ,8192），第三参数count大小最好为buf中数据的大小，以免出现错误。(经过笔者再次试验，write一次能够写入的并不只有8192这么多，作者尝试一次写入81920000，结果也是可以，看来其一次最大写入数据并不是8192，但内核中确实有BUFSIZ这个参数，具体指什么还有待研究)  

### 8.5 copy_to_user

```c
unsigned long copy_to_user(void *to, const void *from, unsigned long n)
```

  参数说明

to：目标地址（用户空间） 

from：源地址（内核空间） 

n：将要拷贝数据的字节数函数说明从内核空间中读取数据到用户空间。

返回值成功返回0，失败返回没有拷贝成功的数据字节数。

### 8.6 copy_from_user  

```c
unsigned long copy_from_user(void *to, const void *from, unsigned long n);
```

参数说明

to：目标地址（内核空间） 

from：源地址（用户空间） 

n：将要拷贝数据的字节数函数说明从用户空间中读取数据到内核空间。

返回值：成功返回0，失败返回没有拷贝成功的数据字节数。



# 操作系统

## 1 进程和线程

### 1.1 什么是进程？什么是线程？

进程是资源分配的基本单位，它是程序执行时的一个实例，在程序运行时创建。

线程是程序执行的最小单位，是进程的一个执行流，一个线程由多个线程组成的。

### 1.2 进程和线程有什么区别？ 

1. 进程是资源分配的最小单位

2. 线程是程序执行的最小单位，也是处理器调度的基本单位，但进程不是，两者均可并发执行

3. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。

   线程是共享进程中的数据，使用相同的地址空间，因此，CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程小很多

4. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。

   不过如何处理好同步与互斥是编写多线程程序的难点。但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也跟着死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间

5. 进程切换时，消耗的资源大，效率低。所以涉及到频繁的切换时，使用线程要好于进程。

   同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

6. 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。

   但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

7. 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行

   进程执行开销大，但是能够很好的进行资源管理和保护，可以跨机器迁移

### 1.3 何时使用多进程，何时使用多线程？  

对资源的管理和保护要求高，不限制开销和效率时，使用多进程

要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程

### 1.4 进程有几种状态？画一下进程状态转换图？ 

进程可以分为五个状态，分别是：

1. 创建状态:  一个应用程序从系统上启动，首先就是进入创建状态，需要获取系统资源创建进程管理块（PCB： Process Control Block）完成资源分配。  

2. 就绪状态:  在创建状态完成之后，进程已经准备好，但是还未获得处理器资源，无法运行。  

3. 运行状态:  获取处理器资源，被系统调度，开始进入运行状态。如果进程的时间片用完了就进入就绪状态  

4. 阻塞状态:  在运行状态期间，如果进行了阻塞的操作，如耗时的I/O操作，此时进程暂时无法操作就进入到了阻塞状态，在这些操作完成后就进入就绪状态  

5. 终止状态:  进程结束或者被系统终止，进入终止状态  

   进程的状态转换图  

   ![image-20230727132911521](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727132911521.png)

### 1.5 创建进程有哪几种方式?  

4种形式创建新的进程：  

1. 系统初始化（查看进程 linux中用ps命令， windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）
2. 一个进程在运行过程中开启了子进程（如 nginx开启多进程，os. fork, subprocess Popen等）
3. 用户的交互式请求，而创建一个新进程（如用户用鼠标双击任意款软件图片：q微信暴风影音等）
4. —个批处理作业的初始化（只在大型机的批处理系统中应用）无论哪-种，新进程的创建都是由—个已经存在的进程执行了—个用于创建进程的系统调用而创建的。

### 1.6 进程间通信方式有哪些？有什么优缺点？

#### 1.6.1 管道(pipe)

管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。

进程的亲缘关系通常是指父子进程关系。

流管道s_pipe: 去除了第一种限制,可以双向传输（全双工）。

管道可用于具有亲缘关系进程间的通信。

命名管道：name_pipe克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信（命名管道也交FIFO）。

#### 1.6.2 信号量(semophore)

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。

它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。

因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

#### 1.6.3 消息队列(message queue)

消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。

消息队列是消息的链接表，包括Posix消息队列system V消息队列。

有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。

消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

#### 1.6.4 信号(singnal)

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

主要作为进程间以及同一进程不同线程之间的同步手段。

#### 1.6.5 共享内存(shared memory)

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。

它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

#### 1.6.6 套接字(socket)

套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

各通信方式的比较和优缺点：

管道速度慢，容量有限，只有父子进程能通讯。

FIFO任何进程间都能通讯，但速度慢。

消息队列容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题，消息队列可以不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便，但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合。此种方法不太常用。

信号量不能用来传递复杂消息，只能用来同步。

利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。共享内存块提供了在任意数量的进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。

进程间通信方式的选择PIPE和FIFO(有名管道)用来实现进程间相互发送非常短小的、频率很高的消息，这两种方式通常适用于两个进程间的通信。

共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据；这种方法适用于多进程间的通信。

其他考虑用socket。主要应用在分布式开发中。

### 1.7  线程间同步方法有哪些？  

现在流行的进程线程同步互斥的控制机制，其实是由最原始、最基本的4种方法（临界区、互斥量、信号量和事件）实现的。

1. 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程访问共享资源，如果有多个线程试图访问共享资源，那么当有一个线程进入后，其他试图访问共享资源的线程将会被挂起，并一直等到进入临界区的线程离开，临界在被释放后，其他线程才可以抢占
2.  互斥量：为协调对一个共享资源的单独访问而设计，只有拥有互斥量的线程，才有权限去访问系统的公共资源，因为互斥量只有一个，所以能够保证资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享
3. 信号量：为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一个时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目
4. 事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。

### 1.8 什么是内核线程和用户线程？  

1. 用户线程指**不需要内核支持而在用户程序中实现的线程**，其**不依赖于操作系统核心**，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。

   不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。

   由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。

2. 内核线程：**由操作系统内核创建和撤销**。

   内核维护进程及线程的上下文信息以及线程切换。

   一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。

### 1.9 内核线程和用户线程的区别？  

1. 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的
2.  用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的
3.  用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断
4. 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度
5. 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。

### 1.10 内核线程和用户线程有什么优缺点？  

内核线程

优点：

1. 当有多个处理机时，一个进程的多个线程可以同时执行。

缺点：

​	由内核进行调度。

用户线程

优点：

1. 线程的调度不需要内核直接参与，控制简单
2. 可以在不支持线程的操作系统中实现
3. 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多
4.  允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别
5. 线程能够利用的表空间和堆栈空间比内核级线程多
6. 同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。

缺点：

 资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用

### 1.11 僵尸进程，孤儿进程，守护进程 

僵尸进程是 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

孤儿进程是因为父进程异常结束了，然后被1号进程init收养。

守护进程是创建守护进程时有意把父进程结束，然后被1号进程init收养

区分： 一个正常运行的子进程，如果此刻子进程退出，父进程没有及时调用wait或waitpid收回子进程的系统资源，该进程就是僵尸进程，如果系统收回了，就是正常退出，如果一个正常运行的子进程，父进程退出了但是子进程还在，该进程此刻是孤儿进程，被init收养，如果父进程是故意被杀掉，子进程做相应处理后就是守护进程 

### 1.12 僵尸进程有什么危害？  

在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息(包括进程号 PID，退出状态 the termination status of the process，运行时间 the amount of CPU time taken by the process 等)。直到父进程通过 wait / waitpid 来取时才释放。

如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程

### 1.13 如何清理僵尸进程？

僵尸进程的产生是因为父进程没有 wait() 子进程。所以如果我们自己写程序的话一定要在父进程中通过wait() 来避免僵尸进程的产生。

当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。但是我们可以杀死它的父进程，让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。  

### 1.14 如何唤醒被阻塞的socket线程？

同步阻塞

等待锁的释放

等待阻塞

1. 使用Thread.sleep造成的阻塞:时间结束后自动进入RUNNABLE状态

2. 使用Thread.wait造成的阻塞:使用Thread.notify或者Thread.notifyAll唤醒

3. 使用Thread.join造成的阻塞:等待上一个线程执行完后自动进入RUNNABLE状态

4. 使用Thread.suspend造成的阻塞:使用Thread.resum唤醒

5. 使用LockSupport.park造成的阻塞:使用LockSupport.unpark唤醒

6. 使用LockSupport.parkNanos造成的阻塞:指定时间结束后，自动唤醒

7. 使用LockSupport.parkUntil造成的阻塞:到达指定的时间，自动唤醒  

   

### 1.15 如何确定当前线程是繁忙还是阻塞？

使用ps命令查看

### 1.16 空闲的进程和阻塞的进程状态会不会在唤醒的时候误判？

不会。每个进程有个进程控制块PCB，两种状态的进程分别处于两种队列。唤醒应该是找阻塞队列的进程。

### 1.17 请问就绪状态的进程在等待什么？

被调度使用CPU的运行权    

### 1.18 如何实现线程池？

1. 设置一个生产者消费者队列，作为临界资源
2. 初始化n个线程，并让其运行起来，加锁去队列取任务运行
3. 当任务队列为空的时候，所有线程阻塞4. 当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程

### 1.19 请你回答一下fork和 vfork 的区别？ 

fork的基础知识： 

fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：  

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

 ![image-20230727144414444](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727144414444.png)

vfork的基础知识：

在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。

BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用  

```c
#include <sys/types.h>
#include <unistd.h>
pid_t vfork(void);
```

![image-20230727144508589](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727144508589.png)

fork和vfork的区别：

1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段
2. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行
3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁
4. 当需要改变共享数据段中变量的值，则拷贝父进程。

### 1.20 server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？  

最普通的Server模型，则处于阻塞状态；如果使用IO复用中epoll、select等，则处于运行状态  

## 2 堆和栈  

### 2.1 什么是代码段，数据段，bss段，堆，栈？

代码段 ：

代码段通常用来存放程序执行代码的一块区域。这部分区域的大小在程序运行前就已经确定了，通常这块内存区域属于**只读**，有些架构也允许可写，在代码段中也有可能包含以下**只读的常数变量**，例如**字符串常量**等。

程序段为程序代码在内存中映射一个程序可以在内存中有多个副本。

数据段 ：

数据段通常用来**存放程序中已初始化的全局变量和已初始化为非0的静态变量**的一块内存区域，属于静态内存分配。

直观理解就是C语言程序中的全局变量（注意：全局变量才算是程序的数据，局部变量不算程序的数据，只能算是函数的数据）

BSS段 ：

bss段通常是指用来存放程序中**未初始化的全局变量和未初始化的静态变量或者初始化为0的静态变量**一块区域。

bss英文Block started by symbol，bss属于静态内存分配。

bss段的特点就是**被初始化为0**，bss段**本质上也是属于数据段**，bss段就是被初始化为0的数据段  

![image-20230727144940827](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727144940827.png)

堆：

堆是用来存放进程中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。

当进程调用malloc等函数分配内存时，新分配的内存就被动态分配到堆上，当利用free等函数释放内存时，被释放的内存从堆中被剔除。

栈：

栈又称堆栈，是用户存放程序临时创建的变量，也就是我们函数{}中定义的变量，但不包括static声明的变量，static意味着在数据段中存放变量。

除此之外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中，由于栈的先进后出特点，所以栈特别方便用来保存、恢复调用现场。

从这个意义上讲，我们可以把堆栈看成一个寄存，交换临时数据的内存区

```c
#include <stdio.h>
int a = 0; // 数据段
char *p1; // BSS段
int main()
{
	int b; // 栈
	char s[] = "abc";// 栈
	char *p2;// 栈
	char *p3 = "123456"; // 123456\0在常量区，p3在栈上。
	static int c =0； // BSS段
	Class c1 = new Class();//new出的对象就在堆区
	strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
	return 0;
}
```

### 2.2 为什么堆的空间是不连续的？

堆包含一个**链表来维护已用和空闲的内存块**。

在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块。

所以可能让人觉得只要有很多不连续的零散的小区域，只要总数达到申请的内存块，就可以分配。

但事实上是不行的，这又让人觉得是不是零散的内存块不能连接成一个大的空间，而必须要一整块连续的内存空间才能申请成功呢。

申请和释放许多小的块可能会产生如下状态：在已用块之间存在很多小的空闲块。

进而申请大块内存失败，虽然空闲块的总和足够，但是空闲的小块是零散的，不连续的，不能满足申请的大小，这叫做“堆碎片”。

当旁边有空闲块的已用块被释放时，新的空闲块会与相连的空闲块合并成一个大的空闲块，这样就可以有效的减少"堆碎片"的产生。

堆分配的空间在**逻辑地址（虚拟地址）上是连续的**，但在**物理地址上是不连续的（因为采用了页式内存管理,windows下有段机制、分页机制）**，如果逻辑地址空间上已经没有一段连续且足够大的空间，则分配内存失败。

### 2.3 什么是用户栈和内核栈？

内核栈

内存中属于操作系统空间的一块区域。

作用

1. 保存中断现场，对于嵌套中断，被中断程序的现场信息一次压入系统栈，中断返回时逆序弹出
2. 保存操作系统程序相互调用的参数，返回值，以及函数的局部变量。

用户栈

用户进程空间的一块区域，用于保存用户空间子程序间调用的参数，返回值以及局部变量。

### 2.4 用户栈和内核栈，为什么不能共用一个栈？

1. 如果只用系统栈，系统栈一般大小有限，用户程序调用次数可能很多。如果中断有16个优先级，那么系统栈一般大小为15（只需保存15个低优先级中断，另一个高优先级中断在运行）用户程序调用次数很多，那样15次子程序调用以后的子程序的参数，返回值，局部变量就不能保存，用户程序也就不能正常运行。
2.  如果只用用户栈，系统程序需要在某种保护下运行，而用户栈在用户空间不能提供相应的保护措施。

### 2.5 线程是否具有相同的堆栈?  

真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。

每个线程有自己的堆栈。  

## 3 并发和互斥  

### 3.1 驱动里面为什么要有并发、互斥的控制？如何实现？

并发，指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全局变量、静态变量等）的访问则很容易导致竞态。

解决竞态问题的途径是保证对共享资源的互斥访问，所谓互斥访问就是指一个执行单元在访问共享资源的时候，其他的执行单元都被禁止访问。

访问共享资源的代码区域被称为临界区，临界区需要以某种互斥机制加以保护。

中断屏蔽，原子操作，自旋锁，和信号量都是linux设备驱动中可采用的互斥途径。

### 3.2 自旋锁是什么？信号量是什么？二者有何异同？  

**自旋锁**

自旋锁，顾名思义，我们可以把他理解成厕所门上的一把锁。这个厕所门只有一把钥匙，当我们进去时，把钥匙取下来，进去后反锁。那么当第二个人想进来，必须等我们出去后才可以。当第二个人在外面等待时，可能会一直等待在门口转圈。

我们的自旋锁也是这样，自旋锁只有锁定和解锁两个状态。当我们进入拿上钥匙进入厕所，这就相当于自旋锁锁定的状态，期间谁也不可以进来。当第二个人想要进来，这相当于线程B想要访问这个共享资源，但是目前不能访问，所以线程B就一直在原地等待，一直查询是否可以访问这个共享资源。当我们从厕所出来后，这个时候就“解锁”了，只有再这个时候线程B才能访问。

假如，在厕所的人待的时间太长怎么办？外面的人一直等待吗？如果换做是我们，肯定不会这样，简直浪费时间，可能我们会寻找其他方法解决问题。自旋锁也是这样的，如果线程A持有自旋锁时间过长，显然会浪费处理器的时间，降低了系统性能。我们知道CPU最伟大的发明就在于多线程操作，这个时候让线程B在这里傻傻的不知道还要等待多久，显然是不合理的。因此，如果自旋锁只适合短期持有，如果遇到需要长时间持有的情况，我们就要换一种方式了（互斥体）。

**信号量**

信号量和自旋锁有些相似，不同的是信号量会发出一个信号告诉你还需要等多久。因此，不会出现傻傻等待的情况。比如，有100个停车位的停车场，门口电子显示屏上实时更新的停车数量就是一个信号量。这个停车的数量就是一个信号量，他告诉我们是否可以停车进去。当有车开进去，信号量加一，当有车开出来，信号量减一。比如，厕所一次只能让一个人进去，当A在里面的时候，B想进去，如果是自旋锁，那么B就会一直在门口傻傻等待。如果是信号量，A就会给B一个信号，你先回去吧，我出来了叫你。这就是一个信号量的例子，B听到A发出的信号后，可以先回去睡觉，等待A出来。因此，信号量显然可以提高系统的执行效率，避免了许多无用功。

**区别**

1. 由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况

2. 相反，锁被短时间持有时，使用信号量就不太适宜了，因为睡眠引起的耗时可能比锁被占用的全部时间还要长

3. 由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中（使用自旋锁）是不能进行调度的

4. 你可以在持有信号量时去睡眠（当然你也可能并不需要睡眠），因为当其它进程试图获得同一信号量时不会因此而死锁，（因为该进程也只是去睡眠而已，而你最终会继续执行的

5. 在你占用信号量的同时不能占用自旋锁，因为在你等待信号量时可能会睡眠，而在持有自旋锁时是不允许睡眠的

6. 信号量锁保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含这样代码的临界区，因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一进程企图获取本自旋锁，死锁就会发生

7. 信号量不同于自旋锁，它不会禁止内核抢占（自旋锁被持有时，内核不能被抢占），所以持有信号量的代码可以被抢占，这意味着信号量不会对调度的等待时间带来负面影响

   

### 3.3 自旋锁和信号量可以睡眠吗？为什么？

自旋锁不能睡眠，信号量可以。

**原因**

自旋锁自旋锁禁止处理器抢占；而信号量不禁止处理器抢占。基于这个原因，如果自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其他系统进程将都不能获得CPU而运行，因此不能唤醒睡眠的自旋锁，因此系统将不响应任何操作（除了中断或多核的情况，下面会讨论）。而信号量在临界区睡眠后，其他进程可以用抢占的方式继续运行，从而可以实现内存拷贝等功能而使得睡眠的信号量程序由于获得了等待的资源而被唤醒，从而恢复了正常的代码运行。

当然，自旋锁的睡眠的情况包含考虑多核CPU和中断的因素。自旋锁睡眠时，只是当前CPU的睡眠以及当前CPU的禁止处理器抢占，所以，如果存在多个CPU，那么其他活动的CPU可以继续运行使操作系统功能正常，并有可能完成相应工作而唤醒睡眠了的自旋锁，从而没有造成系统死机；自旋锁睡眠时，如果允许中断处理，那么中断的代码是可以正常运行的，但是中断通常不会唤醒睡眠的自旋锁，因此系统仍然运行不正常。

### 3.4 自旋锁和信号量可以用于中断中吗？

信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。

自旋锁可以用于中断。在获取锁之前一定要先禁止本地中断（也就是本CPU中断，对于多核SOC来说会有多个CPU核），否则可能导致锁死现象的发生。  

### 3.5 读写锁是什么？

当临界区的一个文件可以被同时读取，但是并不能被同时读和写。

如果一个线程在读，另一个线程在写，那么很可能会读取到错误的不完整的数据。

读写自旋锁是可以允许对临界区的共享资源进行并发读操作的。但是并不允许多个线程并发读写操作。

### 3.6 产生死锁的原因是什么？

多个并发进程因争夺系统资源而产生相互等待的现象。

即：一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。

产生死锁的本质原因为：

1. 系统资源有限
2. 进程推进顺序不合理

### 3.7 死锁的4个必要条件是什么？

1. 互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束
2. 占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源
3. 不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来
4. 循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。

当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无法释放

这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的

### 3.8 死锁的处理方式有哪些？

死锁的处理方式主要从**预防死锁**、**避免死锁**、**检测**与**解除死锁**这四个方面来进行处理。

**预防死锁**

1. 资源一次性分配：（破坏请求和保持条件）
2.  可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）
3. 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

**避免死锁**

预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。

由于在避免死锁的策略中，允许进程动态地申请资源。

因而，系统在进行资源分配之前预先计算资源分配的安全性。

若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。

**检测死锁**

首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表

**解除死锁**

当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：

1. 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态
2. 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等  

### 3.9 如何避免死锁？ 

在有些情况下死锁是可以避免的。

三种用于**避免死锁**的技术：

**加锁顺序**（线程按照一定的顺序加锁）

**加锁时限**（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）

**死锁检测**

**加锁顺序**：

当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。

如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。

看下面这个例子：

```c
Thread 1:
lock A
lock B
Thread 2:
wait for A
lock C (when A locked)
Thread 3:
wait for A
wait for B
wait for C
```

 如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。

它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。

例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条件)。

因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。

然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。按照顺序加锁是一种有效的死锁预防机制。

但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。

**加锁时限**

另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。

若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。

这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。

以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：

```c
Thread 1 locks A
Thread 2 locks B
Thread 1 attempts to lock B but is blocked
Thread 2 attempts to lock A but is blocked
Thread 1's lock attempt on B times out
Thread 1 backs up and releases A as well
Thread 1 waits randomly (e.g. 257 millis) before retrying.
Thread 2's lock attempt on A times out
Thread 2 backs up and releases B as well
Thread 2 waits randomly (e.g. 43 millis) before retrying.
```

在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。

这时，线程1尝试获取锁A并且处于等待状态。

当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。

需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。

也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。

**死锁检测**

死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。

每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。

除此之外，每当有线程请求锁，也需要记录在这个数据结构中。当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。

例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。

如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。

当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。

线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。

线程A为了检测死锁，它需要递进地检测所有被B请求的锁。

从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。

这是它就知道发生了死锁。

下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。

![image-20230727151728574](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727151728574.png)

那么当检测出死锁时，这些线程该做些什么呢？

一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。

这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。

虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁

一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。

如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。

为避免这个问题，可以在死锁发生的时候设置随机的优先级  

### 3.10 请问单核机器上写多线程程序，是否需要考虑加锁? 

在单核机器上写多线程程序，仍然需要线程锁。

因为线程锁通常用来实现线程的同步和通信。

在单核机器上的多线程程序，仍然存在线程同步的问题。

因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。

如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突  

## 4 内存

### 4.1 在1 G内存的计算机中能否malloc(1.2 G)？为什么？

malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。

程序运行时，堆空间只是程序向操作系统申请划出来的一大块虚拟地址空间。应用程序通过malloc申请空间，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。

本题要申请空间的大小为 1.2 G= × 1.2 Byte ，1.2 G=(1024 * 1024*1024) * 1.2 Byte转换为十六进制约为 4CCC CCCC ，这个数值已经超过了 int 类型的表示范围，但还在 unsigned 的表示范围。幸运的是malloc 函数要求的参数为 unsigned 。见下面的示例代码。

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
	char*p;
	constunsigned k= 1024*1024*1024*1.2;
	printf("%x\n",k);
	p= (char *)malloc( k );
	if( p!=NULL )
		printf("OK");
	else
		printf("error");
	return0;
}
```

### 4.2 内存管理有哪几种方式？  

  常见的内存管理方式有**块式管理**、**页式管理**、段式管理和**段页式管理**。

最常用的是**段页式管理**。

**块式管理**

把主存分为一大块一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断载入主存，就算所需的程序片段只有几个字节，也只能把这一块分配给它。

这样会造成很大的浪费，平均浪费了50%的内存空间，但是易于管理。

**页式管理**

用户程序的地址空间被划分成若干个固定大小的区域，这个区域被称为页”，相应地，内存空间也被划分为若干个物理块，页和块的大小相等。

可将用户程序的任一页放在内存的任一块中，从而实现了离散分配。

这种方式的优点是页的大小是固定的，因此便于管理；缺点是页长与程序的逻辑大小没有任何关系。

这就导致在某个时刻一个程序可能只有一部分在主存中，而另一部分则在辅存中。

这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。

**段式管理**

段是按照程序的自然分界划分的并且长度可以动态改变的区域。

使用这种方式，程序员可以把子程序、操作数和不同类型的数据和函数划分到不同的段中。

这种方式将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。

存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。

**段页式管理**

段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。

1. **用分段方法来分配和管理虚拟存储器**。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页
2. **用分页方法来分配和管理内存**，即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护

### 4.3 什么是虚拟内存？  

虚拟内存简称虚存，是计算机系统内存管理的一种技术。

它是相对于物理内存而言的，可以理解为“假的”内存。

它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），允许程序员编写并运行比实际系统拥有的内存大得多的程序，这使得许多大型软件项目能够在具有有限内存资源的系统上实现。而

实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

相比实存，虚存有以下好处：

1. 扩大了地址空间。无论是段式虚存，还是页式虚存，或是段页式虚存，寻址空间都比实存大

2. 内存保护。每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。另外，虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改

3. 公平分配内存。采用了虚存之后，每个进程都相当于有同样大小的虚存空间

4. 当进程需要通信时，可采用虚存共享的方式实现不过，使用虚存也是有代价的，主要表现在以下几个方面

   （1）虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存

   （2）虚拟地址到物理地址的转换，增加了指令的执行时间

   （3）页面的换入换出需要磁盘IO，这是很耗时间的

   （4）如果一页中只有一部分数据，会浪费内存

### 4.4 解释下内存碎片，内碎片，外碎片？  

内存碎片是由于多次进行内存分配造成的，当进行内存分配时，内存格式一般为：（用户使用段）（空白段）（用户使用段），当空白段很小的时候，可能不能提供给用户足够多的空间，如夹在中间的空白段的大小为5，而用户需要的内存大小为6，这样会产生很多的间隙，造成使用效率下降，这些很小的空隙叫碎片。内碎片：分配给程序的存储空间没有用完，有一部分是程序不使用，但其他程序也没法用的空间。

内碎片是处于区域内部或页面内部的存储块，占有这些区域或页面的进程并不使用这个存储块，而在进程占有这块存储块时，系统无法利用它，直到进程释放它，或进程结束时，系统才有可能利用这个存储块。

外碎片：空间太小，小到无法给任何程序分配（不属于任何进程）的存储空间。外部碎片是出于任何已分配区域或页面外部的空闲存储块，这些存储块的总和可以满足当前申请的长度要求，但是它们的地址不连续或其他原因，使得系统无法满足当前申请。

### 4.5 解释下虚拟地址、逻辑地址、线性地址、物理地址？  

虚拟地址

是指由程序产生的由**段选择符**和**段内偏移地址**组成的地址。这两部分组成的地址**并没有直接访问物理内存**，而是通过分段地址的变换处理后才会对应到相应的物理内存地址。

逻辑地址指由程序产生的段内偏移地址。

有时直接把逻辑地址当成虚拟地址，两者并没有明确的界限。

线性地址

是指**虚拟地址到物理地址变换之间的中间层**，是处理器可寻址的内存空间（称为线性地址空间）中的地址。

程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段基址就生成了一个线性地址。

如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。

若没有采用分页机制，那么线性地址就是物理地址。

物理地址

是**指现在CPU外部地址总线上的寻址物理内存的地址信号**，是地址变换的最终结果。

虚拟地址到物理地址的转化方法是与体系结构相关的，一般有分段与分页两种方式。

以x86 CPU为例，分段、分页都是支持的。

内存管理单元负责从虚拟地址到物理地址的转化。

**逻辑地址是段标识+段内偏移量的形式，MMU通过査询段表，可以把逻辑地址转化为线性地址**。

如果CPU没有开启分页功能，那么线性地址就是物理地址；如果CPU开启了分页功能MMU还需要查询页表来将线性地址转化为物理地址：逻辑地址（段表）→线性地址（页表）→物理地址。

映射是一种多对一的关系，即不同的逻辑地址可以映射到同一个线性地址上；不同的线性地址也可以映射到同一个物理地址上。

而且，同一个线性地址在发生换页以后，也可能被重新装载到另外一个物理地址上，所以这种多对一的映射关系也会随时间发生变化。

### 4.6 虚拟内存置换方式是怎么样的？  

四种页面置换算法：

最佳（OPT，Optional）

最近最少使用（LRU，Least Recently Used）

先进先出（FIFO，First In First Out）

时钟（Clock）

**最佳置换算法**

* OPT 策略选择置换下次访问距当前时间最长的那些页，可以看出该算法能导致最少的缺页中断，但是由于它要求操作系统必须知道将来的事件，显然这是不可能实现的。

* 但它仍然能作为一种标准来衡量其他算法的性能  

  

**最近最少使用算法**  

LRU 策略置换内存中上次使用距当前最远的页。

根据局部性原理，这也是最不可能访问的页。

实际上， LRU 策略的性能接近于 OPT 策略。

该方法的问题在于比较难以实现。

一种实现方法是给每一页添加一个最后访问的时间戳，并且必须每次访问内存时，都更新这个时间戳。

即使有这种方案的硬件，开销仍然是非常大的。

另外一种可选的方法是维护一个关于访问页的栈，但开销同样很大  

**先进先出算法**  

FIFO 策略把分配给进程的页框视为一个循环缓冲区，按循环方式移动页。

它所需的只是一个指针，这个指针在该进程的页框中循环。

因此这是一种最简单的页面置换策略。

除了它的简单性，这种选择方法所隐含的逻辑是置换驻留在内存中最长时间的页：一个很久以前取入内存的页，到现在可能已经不会再用了。

这个推断是错误的，因为经常出现一部分程序或数据在整个程序的生命周期中使用频率很高的情况，如果使用 FIFO 算法，则这些页会被反复的换入换出，增加了系统开销  

**时钟**  

时钟是 LRU 的近似实现。

最简单的时钟策略需要给每一页框管理一个附加位，称为使用位。

当某一页首次装入内存时，则将该页框的使用位置为 1；当该页随后被访问到时（在访问产生缺页中断后），他的使用位也会被置为 1。

对于页面置换算法用于置换的候选页框集合被视为一个循环缓冲区，并且有一个指针与之相关联。

当一页被置换时，该指针被设置成指向缓冲区中的下一个页框。

当需要置换一页时，操作系统扫描缓冲区，以查找使用位被置为 0 的一个页框。

每当遇到一个使用位为 1 的页框时，操作系统就将该为重新置为 0 ；如果在这个过程开始时，缓冲区所有页框的使用位均为 0，则选择遇到的第一个页框置换；如

果所有页框的使用位均为 1，则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，置换该页框中的页  

### 4.7 给你一个类，里面有static，virtual之类的，来说一说这个类的内存分布？

**1. static修饰符**

static修饰成员变量对于非静态数据成员，每个类对象都有自己的拷贝。

而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。

所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。

因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。

static修饰成员函数与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。

从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。

static修饰的成员函数，在代码区分配内存

**2. C++继承和虚函数**

C++多态分为静态多态和动态多态。

静态多态是通过重载和模板技术实现，在编译的时候确定。

动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。

动态多态实现有几个条件：

（1）虚函数；

（2）一个基类的指针或引用指向派生类的对象；

基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。

虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。

每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。

虚函数表中为什么就能准确查找相应的函数指针呢？

因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。

3. **virtual修饰符**

如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。

如果该类是 virutal 继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。

虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。

如果类中成员是virtual属性，会隐藏父类对应的属性。

### 4.8 假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？

给临界区资源加互斥锁，可以保证临界区资源释放时，只有一个线程获得临界区资源。

### 4.9 操作系统中的缺页中断是什么？

malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。

当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。

缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：

1. 保护CPU现场
2. 分析中断原因
3. 转入缺页中断处理程序进行处理
4. 恢复CPU现场，继续执行

但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：

1. 在指令执行期间产生和处理缺页中断信号
2. 一条指令在执行期间，可能产生多次缺页中断
3. 缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。

### 4.10 OS缺页置换算法如何实现的？

当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。

当前操作系统最常采用的缺页置换算法如下：先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。

按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。

最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。

根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。当前最常采用的就是LRU算法

### 4.11 系统调用是什么，你用过哪些系统调用，和库函数有什么区别？  

**系统调用**

系统调用是通向操作系统本身的接口，是面向底层硬件的。

通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。

下面为适用于访问设备驱动程序的系统调用：

```shell
open: 打开文件或设备
read: 从打开的文件或设备中读取数据
write: 向打开的文件或设备中写入数据
close: 关闭文件或设备
ioctl: 把控制信息传递给设备驱动文件
```

库函数

库函数（Library function）是把函数放到库里，供别人使用的一种方式。

方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。一般放在.lib文件中。

库函数调用则是面向应用开发的，库函数可分为两类，一类是C语言标准规定的库函数，一类是编译器特定的库函数。

系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。

库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性好。

由于库函数是基于c库的，因此不能用于内核对于底层驱动设备的操作。

区别

1. 库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分
2. 库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间，库函数开销较小，系统调用开销较大
3. 库函数是有缓冲的，系统调用是无缓冲的
4. 系统调用依赖于平台，库函数并不依赖

![image-20230727154711521](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727154711521.png)

### 4.12 为什么要有page cache，操作系统怎么设计的page cache？  

加快从磁盘读取文件的速率。

page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。

在Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache项，一个是radix tree，另一个是双向链表。

Radix tree 是一种搜索树，Linux内核利用这个数据结构来通过文件内偏移快速定位Cache 项

## 5 上下文

### 5.1 上下文有哪些？怎么理解？

上下文简单说来就是一个环境。

用户空间的应用程序，通过系统调用，进入内核空间。

这个时候用户空间的进程要传递 很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。

所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。

相对于进程而言，就是进程执行时的环境。

具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。

一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。

1. 用户级上下文: 正文、数据、用户堆栈以及共享存储区
2.  寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)
3. 系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。

而系统调用进行的模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换。

硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。

这个过程中，硬件的 一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。

所谓的“ 中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。

中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。

### 5.2 为什么会有上下文这种概念？

内核空间和用户空间是现代操作系统的两种工作模式，内核模块运行在内核空间，而用户态应用程序运行在用户空间。

它们代表不同的级别，而对系统资源具有不同的访问权限。

内核模块运行在最高级别（内核态），这个级下所有的操作都受系统信任，而应用程序运行在较低级别（用户态）。

在这个级别，处理器控制着对硬件的直接访问以及对内存的非授权访问。

内核态和用户态有自己的内存映射，即自己的地址空间。

其中，处理器总处于以下状态中的一种：内核态，运行于进程上下文，内核代表进程运行于内核空间；内核态，运行于中断上下文，内核代表硬件运行于内核空间；用户态，运行于用户空间。

系统的两种不同运行状态，才有了上下文的概念。用户空间的应用程序，如果想请求系统服务，比如操作某个物理设备，映射设备的地址到用户空间，必须通过系统调用来实现。（系统调用是操作系统提供给用户空间的接口函数）。

通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及到上下文的切换，用户空间和内核空间具有不同的 地址映射，通用或专用的寄存器组，而用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执行

### 5.3 什么情况下进行用户态到内核态的切换？

1. 进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态等
2. 中断上下文是由于硬件发生中断时会触发中断信号请求，请求系统处理中断，执行中断服务子程序。

5.4 中断上下文代码中有哪些注意事项？

运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。

所以中断处理程序代码要受到一些限制，在中断代码中不能出现实现下面功能的代码：

1. 睡眠或者放弃CPU

   因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉。牢记：中断服务子程序一定不能睡眠（或者阻塞）

2. 尝试获得信号量

   如果获得不到信号量，代码就会睡眠，导致（1）中的结果

3. 执行耗时的任务

   中断处理应该尽可能快，因为如果一个处理程序是IRQF_DISABLED类型，他执行的时候会禁止所有本地中断线，而内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。中断处理程序的任务尽可能放在中断下半部执行

4. 访问用户空间的虚拟地址

   因为中断运行在内核空间。

### 5.5 请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的？

线程在切换的过程中需要保存当前线程id、线程状态、堆栈、寄存器状态等信息。

其中寄存器主要包括SP、PC、EAX等寄存器，其主要功能如下：

1. SP:堆栈指针，指向当前栈的栈顶地址
2. PC:程序计数器，存储下一条将要执行的指令
3. EAX:累加寄存器，用于加法乘法的缺省寄存器

## 6 总结

#### 1、进程、线程和协程的区别和联系

|          | 进程                                                         | 线程                                               | 协程                                                         |
| -------- | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| 定义     | 资源分配和拥有的基本单位                                     | 程序执行的基本单位                                 | 用户态的轻量级线程，线程内部调度的基本单位                   |
| 切换情况 | 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 | 保存和设置程序计数器、少量寄存器和栈的内容         | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复         |
| 切换者   | 操作系统                                                     | 操作系统                                           | 用户                                                         |
| 切换过程 | 用户态->内核态->用户态                                       | 用户态->内核态->用户态                             | 用户态(没有陷入内核)                                         |
| 调用栈   | 内核栈                                                       | 内核栈                                             | 用户栈                                                       |
| 拥有资源 | CPU资源、内存资源、文件资源和句柄等                          | 程序计数器、寄存器、栈和状态字                     | 拥有自己的寄存器上下文和栈                                   |
| 并发性   | 不同进程之间切换实现并发，各自占有CPU实现并行                | 一个进程内部的多个线程并发执行                     | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 |
| 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 | 切换时只需保存和设置少量寄存器内容，因此开销很小   | 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 |
| 通信方面 | 进程间通信需要借助操作系统                                   | 线程间可以直接读写进程数据段(如全局变量)来进行通信 | 共享内存、消息队列                                           |

1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序

2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位



#### 2、线程与进程的比较

1、线程启动速度快，轻量级

2、线程的系统开销小

3、线程使用有一定难度，需要处理数据一致性问题

4、同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈



#### 3、一个进程可以创建多少线程，和什么有关？

理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。

因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过2K以上的线程，减小你线程栈的大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。



#### 4、外中断和异常有什么区别？

外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。



#### 5、进程线程模型你知道多少？

对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。

##### 多线程

我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。

我们必须知道，**做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，**而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。

但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。

比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。

对于线程，我认为弄清以下两点非常重要：

- 线程之间有无先后访问顺序（线程依赖关系）
- 多个线程共享访问同一变量（同步互斥问题）

另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。

而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。

线程相关接口不少，主要需要了解各个参数意义和返回值意义。

1. 线程创建和结束

   - 背景知识：

     在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。

   - 相关接口：

     - 创建线程：int pthread_create(pthread_t *pthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *agr);

       创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。

       - pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。
       - attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。
       - start_routine：线程执行函数的首地址，传入函数指针。
       - arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。

     - 获得线程ID：pthread_t pthread_self();

       调用时，会打印线程ID。

     - 等待线程结束：int pthread_join(pthread_t tid, void** retval);

       主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。

       - tid：创建线程时通过指针得到tid值。
       - retval：指向返回值的指针。

     - 结束线程：pthread_exit(void *retval);

       子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。

       - retval：同上。

     - 分离线程：int pthread_detach(pthread_t tid);

       主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。

       - tid：同上。

2. 线程属性值修改

   - 背景知识：

     线程属性对象类型为pthread_attr_t，结构体定义如下：

     ```
     typedef struct{
         int etachstate;    // 线程分离的状态
         int schedpolicy;    // 线程调度策略
         struct sched_param schedparam;    // 线程的调度参数
         int inheritsched;    // 线程的继承性
         int scope;    // 线程的作用域
         // 以下为线程栈的设置
         size_t guardsize;    // 线程栈末尾警戒缓冲大小
         int stackaddr_set;    // 线程的栈设置
         void *    stackaddr;    // 线程栈的位置
         size_t stacksize;    // 线程栈大小
     }pthread_arrt_t;
     ```

     

- 相关接口：

  对上述结构体中各参数大多有：pthread_attr_get()和pthread_attr_set()系统调用函数来设置和获取。这里不一一罗列。

##### 多进程

每一个进程是资源分配的基本单位。

进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。

实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。

父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。

如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。

我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。

1. 进程创建与结束

   - 背景知识：

     进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -> 1号内核进程 -> 1号用户进程(init进程) -> getty进程 -> shell进程 -> 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。

   - 相关接口：

     - 创建进程：pid_t fork(void);

       返回值：出错返回-1；父进程中返回pid > 0；子进程中pid == 0

     - 结束进程：void exit(int status);

       - status是退出状态，保存在全局变量中S?，通常0表示正常退出。

     - 获得PID：pid_t getpid(void);

       返回调用者pid。

     - 获得父进程PID：pid_t getppid(void);

       返回父进程pid。

   - 其他补充：

     - 正常退出方式：exit()、_exit()、return（在main中）。

       exit()和_exit()区别：exit()是对__exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。

       return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。

     - 异常退出方式：abort()、终止信号。

2. Linux进程控制

- 进程地址空间（地址空间）

  虚拟存储器为每个进程提供了独占系统地址空间的假象。

  尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。

  有一些"敏感"的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。

  也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。

- 进程控制块（处理机）

  进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。

- 上下文切换

  内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。

  进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。

  一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。



#### 6、进程调度算法你了解多少？

1、 **先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

2、 **短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

3、**最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。

如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

4、**时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。

当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

[![img](https://camo.githubusercontent.com/a03e660dd898949932194470e5cecf242f5cd2f2089ed232a866766499eb6faf/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363232343732382e706e67)](https://camo.githubusercontent.com/a03e660dd898949932194470e5cecf242f5cd2f2089ed232a866766499eb6faf/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363232343732382e706e67)

5、**优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

6、**多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

[![img](https://camo.githubusercontent.com/f336b46258b2225c5392d04268663edcb035655bacd4c36281df432a1738c628/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d362d312e706e67)](https://camo.githubusercontent.com/f336b46258b2225c5392d04268663edcb035655bacd4c36281df432a1738c628/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d362d312e706e67)



#### 7、Linux下进程间通信方式？

- 管道：
  - 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。
  - 有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。
- 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。
- 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。
- 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。
- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。



#### 8、Linux下同步机制？

- POSIX信号量：可用于进程同步，也可用于线程同步。
- POSIX互斥锁 + 条件变量：只能用于线程同步。

1. 线程和进程的区别？
   - 调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。
   - 并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。
   - 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。
   - 系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。



#### 9、如果系统中具有快表后，那么地址的转换过程变成什么样了？

> ①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。
>
> ②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
>
> ③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)

由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。

例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问- -次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少? (1+100) * 0.9 + (1+100+100) * 0.1 = 111 us 有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1+100) * 0.9+ (100+100) *0.1=110.9 us 若未采用快表机制，则访问一个逻辑地址需要100+100 = 200us 显然，引入快表机制后，访问一个逻辑地址的速度快多了。



#### 10、内存交换和覆盖有什么区别？

交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中。



#### 11、动态分区分配算法有哪几种？可以分别说说吗？

##### 1、首次适应算法

算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。

如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。

[![img](https://camo.githubusercontent.com/2b3d14f84d8b4d73aa9af029c1fc520d5308f5bfe47b41dd651e73b7265dca3a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31312d312e706e67)](https://camo.githubusercontent.com/2b3d14f84d8b4d73aa9af029c1fc520d5308f5bfe47b41dd651e73b7265dca3a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31312d312e706e67)

##### 2、最佳适应算法

算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。

如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 [![img](https://camo.githubusercontent.com/4c044e239bf557fc46e8dd3ca4237f344e3eb96600a3956b826f0c46e7cd03c1/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31312d322e706e67)](https://camo.githubusercontent.com/4c044e239bf557fc46e8dd3ca4237f344e3eb96600a3956b826f0c46e7cd03c1/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31312d322e706e67)

##### 3、最坏适应算法

又称最大适应算法(Largest Fit)

算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 [![img](https://camo.githubusercontent.com/4997045bc8e2d452a43a21281f6a5324bc50b8c0bc0ff88a7304c6dc533e3cf2/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31312d332e706e67)](https://camo.githubusercontent.com/4997045bc8e2d452a43a21281f6a5324bc50b8c0bc0ff88a7304c6dc533e3cf2/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31312d332e706e67)

##### 4、邻近适应算法

算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 [![img](https://camo.githubusercontent.com/40201e1bcc2985dad1d7b1e3423a6bc3d7be18b70824bddd38ec07c03609a665/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31312d342e706e67)](https://camo.githubusercontent.com/40201e1bcc2985dad1d7b1e3423a6bc3d7be18b70824bddd38ec07c03609a665/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31312d342e706e67)

##### 5、总结

首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。

最佳导致大量碎片，最坏导致没有大的空间。

进过实验，首次适应比最佳适应要好，他们都比最坏好。

| 算法     | 算法思想                                           | 分区排列顺序                                 | 优点                                                         | 缺点                                                         |
| -------- | -------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | 从头到尾找适合的分区                               | 空闲分区以地址递增次序排列                   | 综合看性能最好。**算法开销小**，回收分区后一.般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区               | 空闲分区以容量递增次序排列                   | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的、难以利用的碎片;**算法开销大**，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片   | 空闲分区以容量递减次序排列                   | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程;**算法开销大**(原因同上)      |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列(可排列成循环链表) | 不用每次都从低地址的小分区开始检索。**算法开销小**(原因同首次适应算法) | 会使高地址的大分区也被用完                                   |



#### 12、虚拟技术你了解吗？

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。



#### 13、进程状态的切换你知道多少？

[![img](https://camo.githubusercontent.com/cca9a367ee275bfbaf792ae575768970d3bfe8b95995fbafd74ee47301f18485/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240342e352f3230323130352f2545362539332538442545342542442539432545372542332542422545372542422539462d31332d312d2545362539422542342545362539342542392545372538392538382e706e67)](https://camo.githubusercontent.com/cca9a367ee275bfbaf792ae575768970d3bfe8b95995fbafd74ee47301f18485/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240342e352f3230323130352f2545362539332538442545342542442539432545372542332542422545372542422539462d31332d312d2545362539422542342545362539342542392545372538392538382e706e67)

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

> 感谢微信好友“Beautiful”指出配图文字笔误，已改正，感谢！-2021.05.31



#### 14、一个程序从开始运行到结束的完整过程，你能说出来多少？

四个过程：

**（1）预编译** 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下

1、删除所有的#define，展开所有的宏定义。

2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。

3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。

4、删除所有的注释，“//”和“/**/”。

5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。

6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。

**（2）编译** 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。

2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。

3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。

4、优化：源代码级别的一个优化过程。

5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。

6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

**（3）汇编**

将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。

经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。

**（4）链接**

将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：

**1、静态链接：** 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

**2、动态链接：** 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；

更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。



#### 15、通过例子讲解逻辑地址转换为物理地址的基本过程

可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

注意:页面大小是2的整数幂 设页面大小为L，逻辑地址A到物理地址E的变换过程如下:

[![img](https://camo.githubusercontent.com/25048b5305e8ad279e780d2d9f2afcaf5795595d5c1fec6bc374d681c409318b/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31352d312e706e67)](https://camo.githubusercontent.com/25048b5305e8ad279e780d2d9f2afcaf5795595d5c1fec6bc374d681c409318b/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31352d312e706e67)

[![img](https://camo.githubusercontent.com/07b788212723847c1f88d54d02ae4b3219a396517213a5e4ded3be672bc4a136/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363231313532392e706e67)](https://camo.githubusercontent.com/07b788212723847c1f88d54d02ae4b3219a396517213a5e4ded3be672bc4a136/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363231313532392e706e67) 例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。 等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。

> ①计算页号、页内偏移量 页号P=A/L = 2500/1024 = 2; 页内偏移量W= A%L = 2500%1024 = 452
>
> ②根据题中条件可知，页号2没有越界，其存放的内存块号b=8
>
> ③物理地址E=b*L+W=8 * 1024+ 425 = 8644
>
> 在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是-维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。



#### 16、进程同步的四种方法？

##### 1. 临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```
// entry section
// critical section;
// exit section
```



##### 2. 同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

##### 3. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

```
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```



**使用信号量实现生产者-消费者问题**

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。

其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

**注意**，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。

消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

```
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```



##### 4. 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```
monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
```



管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

**使用管程实现生产者-消费者问题**

```
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```





#### 17、操作系统在对内存进行管理的时候需要做些什么?

- 操作系统负责内存空间的分配与回收。
- 操作系统需要提供某种技术从逻辑上对内存空间进行扩充。
- 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。
- 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰



#### 18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）

**进程通信方法**

[![img](https://camo.githubusercontent.com/aeab07822b07701f6816e881323eb114b3ecd0078c0e4a300d772c5ddc1fadcc/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31382d312e706e67)](https://camo.githubusercontent.com/aeab07822b07701f6816e881323eb114b3ecd0078c0e4a300d772c5ddc1fadcc/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31382d312e706e67)

| 名称及方式                                                   |
| ------------------------------------------------------------ |
| 管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信 |
| 命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建 |
| 消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点； |
| 信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段； |
| 共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，**是最快的可用IPC形式。**这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥 |
| 信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身 |
| 内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它 |
| Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信 |

**线程通信方法**

[![img](https://camo.githubusercontent.com/5ca3b980c399ef56bbf35a7f89029270a7fbb68468662a6f31eccb798b67d690/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31382d322e706e67)](https://camo.githubusercontent.com/5ca3b980c399ef56bbf35a7f89029270a7fbb68468662a6f31eccb798b67d690/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d31382d322e706e67)

| 名称及含义                                                   |
| ------------------------------------------------------------ |
| **Linux：**                                                  |
| 信号：类似进程间的信号处理                                   |
| 锁机制：互斥锁、读写锁和自旋锁                               |
| 条件变量：使用通知的方式解锁，与互斥锁配合使用               |
| 信号量：包括无名线程信号量和命名线程信号量                   |
| **Windows：**                                                |
| 全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 |
| Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。 |
| CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。 |



#### 19、进程间通信有哪几种方式？把你知道的都说出来

Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。

##### 管道

- 无名管道
  - 无名管道特点：
    - 无名管道是一种特殊的文件，这种文件只存在于内存中。
    - 无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。
    - 无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。
  - 相关接口：
    - int pipe(int fd[2]);
      - fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。
- 有名管道：
  - 有名管道特点：
    - 有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。
    - 有名管道可以在不具有亲缘关系的进程间进行通信。
  - 相关接口：
    - int mkfifo(const char *pathname, mode_t mode);
      - pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。
      - mode：和open()中的参数相同。

##### 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

##### 共享内存

进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。

- 相关接口

  - 创建共享内存：int shmget(key_t key, int size, int flag);

    成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。

    - key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。
    - size：共享内存容量。
    - flag：权限标志位，和open的mode参数一样。

  - 连接到共享内存地址空间：void *shmat(int shmid, void *addr, int flag);

    返回值即共享内存实际地址。

    - shmid：shmget()返回的标识。
    - addr：决定以什么方式连接地址。
    - flag：访问模式。

  - 从共享内存分离：int shmdt(const void *shmaddr);

    调用成功返回0，失败返回-1。

    - shmaddr：是shmat()返回的地址指针。

- 其他补充

  共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。

  但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。

##### 信号量

在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM V信号量。

- 相关接口

  - 创建信号量：int semget(key_t key, int nsems, int semflag);

    创建成功返回信号量标识符，失败返回-1。

    - key：进程pid。
    - nsems：创建信号量的个数。
    - semflag：指定信号量读写权限。

  - 改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);

    我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。

    struct sembuf结构体定义如下：

    ```
    struct sembuf{
        short sem_num;
        short sem_op;
        short sem_flg;
    };
    ```

    

    成功返回信号量标识符，失败返回-1。

    - semid：信号量集标识符，由semget()函数返回。
    - sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。
    - nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。

  - 直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);

    - semid：信号量集标识符。
    - semnum：信号量集数组上的下标，表示某一个信号量。
    - arg：union semun类型。

##### 辅助命令

ipcs命令用于报告共享内存、信号量和消息队列信息。

- ipcs -a：列出共享内存、信号量和消息队列信息。
- ipcs -l：列出系统限额。
- ipcs -u：列出当前使用情况。

##### 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。



#### 20、虚拟内存的目的是什么？

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。

这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。

例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

[![img](https://camo.githubusercontent.com/186c73343a24e1fd09994d5144d24c1789e4d9dc15bb0461acde06083a4fd6d5/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363233353434312e706e67)](https://camo.githubusercontent.com/186c73343a24e1fd09994d5144d24c1789e4d9dc15bb0461acde06083a4fd6d5/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363233353434312e706e67)



#### 21、说一下你理解中的内存？他有什么作用呢？

[![img](https://camo.githubusercontent.com/d03c52ae0e60821d1c57a31383100a1029fbb4dc7295b27fe5807f259769e688/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d32312d312e706e67)](https://camo.githubusercontent.com/d03c52ae0e60821d1c57a31383100a1029fbb4dc7295b27fe5807f259769e688/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d32312d312e706e67)



#### 22、操作系统经典问题之哲学家进餐问题

[![img](https://camo.githubusercontent.com/a103c0cc289f1705e31d7d139acc06dc13c97e225b6379e0a4f973381815c1e3/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363233303631392e706e67)](https://camo.githubusercontent.com/a103c0cc289f1705e31d7d139acc06dc13c97e225b6379e0a4f973381815c1e3/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363233303631392e706e67)

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。

```
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```



为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

```
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}

void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    check(i);
    up(&mutex);
    down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&mutex);
}

void eat(int i) {
    down(&mutex);
    state[i] = EATING;
    up(&mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```





#### 23、操作系统经典问题之读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);//最后一个读者要对数据进行解锁，防止写进程无法访问
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```





#### 24、介绍一下几种典型的锁？

##### 读写锁

- 多个读者可以同时进行读
- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

##### 互斥锁

一次只能一个线程拥有互斥锁，其他线程只有等待

互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁

##### 条件变量

互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说**互斥锁是线程间互斥的机制，条件变量则是同步机制。**

##### 自旋锁

如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。



#### 24.1、你知道哪几种线程锁（POSIX）？

- **互斥锁（mutex）**
- 互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。
- **条件变量(cond)**
- **自旋锁(spin)**
- 自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。
- 虽然它的效率比互斥锁高，但是它也有些不足之处：
  - 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。
  - 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。
- 自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。



#### 25、逻辑地址VS物理地址

Eg:编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 相对地址又称逻辑地址，绝对地址又称物理地址。



#### 26、怎么回收线程？有哪几种方法？

- **等待线程结束：**int pthread_join(pthread_t tid, void** retval);

  主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。

  - tid：创建线程时通过指针得到tid值。
  - retval：指向返回值的指针。

- **结束线程：**pthread_exit(void *retval);

  子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。

  - retval：同上。

- **分离线程：**int pthread_detach(pthread_t tid);

  主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。

  - tid：同上。



#### 27、内存的覆盖是什么？有什么特点？

由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。

覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。



#### 28、内存交换是什么？有什么特点？

**交换(对换)技术的设计思想**：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)

换入：把准备好竞争CPU运行的程序从辅存移到内存。 换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。



#### 29、什么时候会进行内存的交换？

内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。



#### 30、终端退出，终端运行的进程会怎样

终端在退出时会发送SIGHUP给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出



#### 31、如何让进程后台运行

（1）命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了

（2）ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程

（3）nohup + &，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号

（4）运行指令前面 + setsid，使其父进程编程init进程，不受HUP信号的影响

（5）将 命令+ &放在()括号中，也可以是进程不受HUP信号的影响



#### 32、什么是快表，你知道多少关于快表的知识？

快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

[![img](https://camo.githubusercontent.com/c03ddf3c61a2838a770ff06233e236e5efe9fdc2275d761c33ee00f1b8c4fffe/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d33322d312e706e67)](https://camo.githubusercontent.com/c03ddf3c61a2838a770ff06233e236e5efe9fdc2275d761c33ee00f1b8c4fffe/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d33322d312e706e67)



#### 33、地址变换中，有快表和没快表，有什么区别？

|                        | 地址变换过程                                                 | 访问一个逻辑地址的访存次数                      |
| ---------------------- | ------------------------------------------------------------ | ----------------------------------------------- |
| 基本地址变换机构       | ①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元 | 两次访存                                        |
| 具有快表的地址变换机构 | ①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元 | 快表命中，只需一次访存 快表未命中，需要两次访存 |



#### 34、在执行malloc申请内存的时候，操作系统是怎么做的？

从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap

- brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小
- mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。

通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。

进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。



#### 35、 守护进程、僵尸进程和孤儿进程

##### 守护进程

指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等

创建守护进程要点：

（1）让程序在后台执行。方法是调用fork（）产生一个子进程，然后使父进程退出。

（2）调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。

（3）禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。

（4）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。

（5）将当前目录更改为根目录。

（6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。

（7）处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。

##### 孤儿进程

如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

##### 僵尸进程

如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。

设置**僵尸进程的目**的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。



#### 36、如何避免僵尸进程？

- 通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。
- 父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。
- 如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出。
- 通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。

第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。



#### 37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？

主要分为**时间局部性和空间局部性**。

时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) 空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)

[![img](https://camo.githubusercontent.com/e294f93e4171ff75acc0884886dd4988cefbc874202a71102a3c5068fbb00783/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d33372d312e706e67)](https://camo.githubusercontent.com/e294f93e4171ff75acc0884886dd4988cefbc874202a71102a3c5068fbb00783/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d33372d312e706e67)



#### 38、父进程、子进程、进程组、作业和会话

##### 父进程

已创建一个或多个子进程的进程

##### 子进程

由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。

fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。

子进程从父进程继承的有：

1.进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))

2.环境(environment)

3.堆栈

4.内存

5.进程组号

独有：

1.进程号；

2.不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由getppid函数得到)；

3.资源使用(resource utilizations)设定为0

##### 进程组

进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。

##### 作业

shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。

一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制

**为什么只能运行一个前台作业？** 答：当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。

作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。 一旦作业运行结束，shell就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组

##### 会话

会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。



#### 39、进程终止的几种方式

1、main函数的自然返回，`return` 2、调用`exit`函数，属于c的函数库 3、调用`_exit`函数，属于系统调用 4、调用`abort`函数，异常程序终止，同时发送SIGABRT信号给调用进程。 5、接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)

**exit和_exit的区别**

[![img](https://camo.githubusercontent.com/2f008ad817442128d3f95256619b379838860e26fa559c9603bf73759a0b3cb1/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d33392d312e706e67)](https://camo.githubusercontent.com/2f008ad817442128d3f95256619b379838860e26fa559c9603bf73759a0b3cb1/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d33392d312e706e67)



#### 40、Linux中异常和中断的区别

**中断**

大家都知道，当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。下面这张图显示了中断处理的流程：

[![img](https://camo.githubusercontent.com/80c380c01fc6bd318d1219c3fcadb1460d296e7a12600ac78d0396376d0532f6/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d34302d312e706e67)](https://camo.githubusercontent.com/80c380c01fc6bd318d1219c3fcadb1460d296e7a12600ac78d0396376d0532f6/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d34302d312e706e67)

**异常**

我们在学习《计算机组成原理》的时候会知道两个概念，CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。所以，大家也需要记住的是，**异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常**，下面这张图显示了异常处理的流程：

[![img](https://camo.githubusercontent.com/e36fcf366d91c42be5fb4728c9f8397a2c3d7d2a34304f429f35c9a653d963d8/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d34302d322e706e67)](https://camo.githubusercontent.com/e36fcf366d91c42be5fb4728c9f8397a2c3d7d2a34304f429f35c9a653d963d8/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d34302d322e706e67)

**相同点**

- 最后都是由CPU发送给内核，由内核去处理
- 处理程序的流程设计上是相似的

**不同点**

- 产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的
- 内核需要根据是异常还是中断调用不同的处理程序
- 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的
- 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中



#### 41、Windows和Linux环境下内存分布情况

[![img](https://camo.githubusercontent.com/d3d4d9ce3ffaeefbaa272f2f1d608e03e35c5aaed2f27413208871fdc2f42588/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d34312d312e706e67)](https://camo.githubusercontent.com/d3d4d9ce3ffaeefbaa272f2f1d608e03e35c5aaed2f27413208871fdc2f42588/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d34312d312e706e67)

通过这张图你可以看到，用户空间内存，从**低到高**分别是 7 种不同的内存段：

- 程序文件段，包括二进制可执行代码；
- 已初始化数据段，包括静态常量；
- 未初始化数据段，包括未初始化的静态变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 `8 MB`。当然系统也提供了参数，以便我们自定义大小；



#### 42、一个由C/C++编译的程序占用的内存分为哪几个部分？

1、栈区（stack）— 地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的队列，先进后出。

2、堆区（heap）— 地址向上增长，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。

3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放

4、文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放

5、程序代码区(text)—存放函数体的二进制代码。



#### 43、一般情况下在Linux/windows平台下栈空间的大小

Linux环境下有操作系统决定，一般是8KB，8192kbytes，通过ulimit命令查看以及修改

Windows环境下由编译器决定，VC++6.0一般是1M

**Linux**

linux下非编译器决定栈大小，而是由操作系统环境决定，默认是8192KB（8M）；而在Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。

在Linux下通过如下命令可查看和设置栈的大小：

```
$ ulimit -a            # 显示当前栈的大小 （ulimit为系统命令，非编译器命令）       
$ ulimit -s 32768      # 设置当前栈的大小为32M
```



**Windows**

下程序栈空间的大小，VC++ 6.0 默认的栈空间是1M。

VC6.0中修改堆栈大小的方法：

- 选择 "Project->Setting"
- 选择 "Link"
- 选择 "Category"中的 "Output"
- 在 "Stack allocations"中的"Reserve:"中输栈的大小



#### 44、程序从堆中动态分配内存时，虚拟内存上怎么操作的

页表：是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系

在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系。



#### 45、常见的几种磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

##### 1. 先来先服务

按照磁盘请求的顺序进行调度。

优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

##### 2. 最短寻道时间优先

优先调度与当前磁头所在磁道距离最近的磁道。

虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

[![img](https://camo.githubusercontent.com/c9484ee20efe7a8928d6a7ca2cb30b7cb8970e4f97ab5297f1e5ed486c52286d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363233353633312e706e67)](https://camo.githubusercontent.com/c9484ee20efe7a8928d6a7ca2cb30b7cb8970e4f97ab5297f1e5ed486c52286d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363233353633312e706e67)

##### 3. 电梯扫描算法

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

[![img](https://camo.githubusercontent.com/81bd9b926e8412fbba4c7d78fc2464b52809e94031aedaf0c95f1116287e05f9/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363233353730372e706e67)](https://camo.githubusercontent.com/81bd9b926e8412fbba4c7d78fc2464b52809e94031aedaf0c95f1116287e05f9/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232363233353730372e706e67)



#### 46、交换空间与虚拟内存的关系

**交换空间** Linux 中的交换空间（Swap space）在**物理内存**（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。交换空间位于硬盘驱动器上，它比进入物理内存要慢。 交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。 交换空间的总大小应该相当于你的计算机内存的两倍和 32 MB这两个值中较大的一个，但是它不能超过 2048MB（2 GB）。 **虚拟内存** 虚拟内存是文件数据交叉链接的活动文件。是WINDOWS目录下的一个"WIN386.SWP"文件，这个文件会不断地扩大和自动缩小。 就速度方面而言,CPU的L1和L2缓存速度最快，内存次之，硬盘再次之。但是**虚拟内存使用的是硬盘的空间**，为什么我们要使用速度最慢的硬盘来做 为虚拟内存呢？因为电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致我们只有可怜的256M/512M内存消耗殆尽。而硬盘空间动辄几十G上百G，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。



#### 47、抖动你知道是什么吗？它也叫颠簸现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)

为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率 为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集” 的概念



#### 48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）

从两方面来考虑：

- 分配和释放，堆在分配和释放时都要调用函数（malloc,free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。
- 访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。



#### 49、常见内存分配方式有哪些？

**内存分配方式**

（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。



#### 50、常见内存分配内存错误

（1）内存分配未成功，却使用了它。

编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。

（2）内存分配虽然成功，但是尚未初始化就引用它。

犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。

（3）内存分配成功并且已经初始化，但操作越过了内存的边界。

例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。

（4）忘记了释放内存，造成内存泄露。

含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。

（5）释放了内存却继续使用它。常见于以下有三种情况：

- 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。
- 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。
- 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。



#### 51、内存交换中，被换出的进程保存在哪里？

保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。



#### 52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？

可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间… (注意: PCB 会常驻内存，不会被换出外存)



#### 53、ASCII、Unicode和UTF-8编码的区别？

**ASCII**

ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII 编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。

**Unicode**

由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

**UTF-8**

为了解决上述问题，又出现了把Unicode编码转化为“**可变长编码**”UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。

**三者之间的联系**

搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：

(1) 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码

(2)用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图（截取他人图片）

[![img](https://camo.githubusercontent.com/e583fb29d9ffc0b074001116e6fcf045dfecb99166e3624e820433fb81e63716/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35332d312e706e67)](https://camo.githubusercontent.com/e583fb29d9ffc0b074001116e6fcf045dfecb99166e3624e820433fb81e63716/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35332d312e706e67)

浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：

[![img](https://camo.githubusercontent.com/5675ebd3f2ace00eb70ce05836c934bb465fd099b178523bf5e3e0a3614a4430/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35332d322e706e67)](https://camo.githubusercontent.com/5675ebd3f2ace00eb70ce05836c934bb465fd099b178523bf5e3e0a3614a4430/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35332d322e706e67)



#### 54、原子操作的是如何实现的

**处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。**首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

（1）使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2，如图下图所示。

```
CPU1    CPU2
 i=1     i=1
 i+1     i+1
 i=2     i=2
```



原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。

处理器使用总线锁就是来解决这个问题的。**所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。**

（2）使用缓存锁保证原子性 第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但**总线锁定把CPU和内存之间的通信锁住了**，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。

所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为**缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如上图所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能使用同时缓存i的缓存行。**

但是有两种情况下处理器不会使用缓存锁定。 第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。 第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。



#### 55、内存交换你知道有哪些需要注意的关键点吗？

1. 交换需要备份存储，通常是快速磁盘，它必须足够大，并且提供对这些内存映像的直接访问。
2. 为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间，转移时间与所交换的空间内存成正比。
3. 如果换出进程，比如确保该进程的内存空间成正比。
4. 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。
5. 交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。
6. 普通交换使用不多，但交换的策略的某些变种在许多系统中（如UNIX系统）仍然发挥作用。



#### 56、系统并发和并行，分得清吗？

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。



#### 57、可能是最全的页面置换算法总结了

##### 1、最佳置换法(OPT)

最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。 [![img](https://camo.githubusercontent.com/67f2777ce3d3d6841e681461f78620e390e4ca7af767d7958aa1b09d10eeaab7/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d312e706e67)](https://camo.githubusercontent.com/67f2777ce3d3d6841e681461f78620e390e4ca7af767d7958aa1b09d10eeaab7/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d312e706e67) 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的

##### 2、先进先出置换算法(FIFO)

先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。 [![img](https://camo.githubusercontent.com/dafc1497ca5247830374cf1d41bb8572cf11b8d62e6ba573dcff6cd23ae96f66/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d322e706e67)](https://camo.githubusercontent.com/dafc1497ca5247830374cf1d41bb8572cf11b8d62e6ba573dcff6cd23ae96f66/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d322e706e67)

[![img](https://camo.githubusercontent.com/7642888e0c1b7527d344af780dd597db00baa692c41f89155e9b032da1202488/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d332e706e67)](https://camo.githubusercontent.com/7642888e0c1b7527d344af780dd597db00baa692c41f89155e9b032da1202488/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d332e706e67)Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差

FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。

##### 3、最近最久未使用置换算法(LRU)

最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。

[![img](https://camo.githubusercontent.com/e1ca098a60a3f557c3b01c932c5fa6f544fac3dd98831d922a68f33c718b0697/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d342e706e67)](https://camo.githubusercontent.com/e1ca098a60a3f557c3b01c932c5fa6f544fac3dd98831d922a68f33c718b0697/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d342e706e67) 在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。

##### 4、时钟置换算法(CLOCK)

最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。

所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。

时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)

简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)

[![img](https://camo.githubusercontent.com/282a00bf343b84ebba3280d83e884bdd1488ec023096a56dfe223c2c4d67f92e/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d352e706e67)](https://camo.githubusercontent.com/282a00bf343b84ebba3280d83e884bdd1488ec023096a56dfe223c2c4d67f92e/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d352e706e67)

##### 5、改进型的时钟置换算法

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。

因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。

为方便讨论，用(访问位，修改位)的形式表示各页面状态。如(1, 1)表示一个页面近期被访问过，且被修改过。

改进型的Clock算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。访问位A和修改位M可以组成一下四种类型的页面。

算法规则:将所有可能被置换的页面排成–个循环队列

> 第一轮:从当前位置开始扫描到第一个(A =0, M = 0)的帧用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页 第二轮:若第一轮扫描失败，则重新扫描，查找第一个(A =1, M = 0)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(A =0, M = 1)的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。 第四轮:若第三轮扫描失败，则重新扫描，查找第一个A =1, M = 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。

由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择- -个淘汰页面最多会进行四轮扫描

[![img](https://camo.githubusercontent.com/198998b684a5378a92cd7381204d3d38e6b9f88e937d5a21057a35c6860f045f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d362e706e67)](https://camo.githubusercontent.com/198998b684a5378a92cd7381204d3d38e6b9f88e937d5a21057a35c6860f045f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653240322e382f3230323130342f2545362539332538442545342542442539432545372542332542422545372542422539462d35372d362e706e67) 算法规则：将所有可能被置换的页面排成一个循环队列 第一轮:从当前位置开始扫描到第-一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位。(第一优先级:最近没访问，且没修改的页面) 第二轮:若第一轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。本轮将所有扫描过的帧访问位设为0 (第二优先级: 最近没访问，但修改过的页面) 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位(第三优先级:最近访问过，但没修改的页面) 第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。(第四优先级:最近访问过，且修改过的页面) 由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描

##### 6、总结

|                         | 算法规则                                                     | 优缺点                                          |
| ----------------------- | ------------------------------------------------------------ | ----------------------------------------------- |
| OPT                     | 优先淘汰最长时间内不会被访问的页面                           | 缺页率最小，性能最好;但无法实现                 |
| FIFO                    | 优先淘汰最先进入内存的页面                                   | 实现简单;但性能很差，可能出现Belady异常         |
| LRU                     | 优先淘汰最近最久没访问的页面                                 | 性能很好;但需要硬件支持，算法开销大             |
| CLOCK (NRU)             | 循环扫描各页面 第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。 | 实现简单，算法开销小;但未考虑页面是否被修改过。 |
| 改进型CLOCK (改进型NRU) | 若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1) | 算法开销较小，性能也不错                        |



#### 58、共享是什么？

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。



#### 59、死锁相关问题大总结，超全！

**死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。**

##### 1、死锁产生原因

举个例子：两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生。

理论上认为死锁产生有以下四个必要条件，缺一不可：

1. **互斥条件**：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。
2. **不剥夺条件**：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。
3. **请求和保持条件**：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。
4. **循环等待条件**：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

##### 2、死锁演示

通过代码的形式进行演示，需要两个线程和两个互斥量。

```
#include <iostream>
#include <vector>
#include <list>
#include <thread>
#include <mutex>  //引入互斥量头文件
using namespace std;

class A {
public:
	//插入消息，模拟消息不断产生
	void insertMsg() {
		for (int i = 0; i < 100; i++) {
			cout << "插入一条消息:" << i << endl;
			my_mutex1.lock(); //语句1
			my_mutex2.lock(); //语句2
			Msg.push_back(i);
			my_mutex2.unlock();
			my_mutex1.unlock();
		}
	}
	//读取消息
	void readMsg() {
		int MsgCom;
		for (int i = 0; i < 100; i++) {
			MsgCom = MsgLULProc(i);
			if (MsgLULProc(MsgCom)) {
				//读出消息了
				cout << "消息已读出" << MsgCom << endl;
			}
			else {
				//消息暂时为空
				cout << "消息为空" << endl;
			}
		}
	}
	//加解锁代码
	bool MsgLULProc(int &command) {
		int curMsg;
		my_mutex2.lock();   //语句3
		my_mutex1.lock();   //语句4
		if (!Msg.empty()) {
			//读取消息，读完删除
			command = Msg.front();
			Msg.pop_front();
			
			my_mutex1.unlock();
			my_mutex2.unlock();
			return true;
		}
		my_mutex1.unlock();
		my_mutex2.unlock();
		return false;
	}
private:
	std::list<int> Msg;  //消息变量
	std::mutex my_mutex1; //互斥量对象1
	std::mutex my_mutex2; //互斥量对象2
};

int main() {
	A a;
	//创建一个插入消息线程
	std::thread insertTd(&A::insertMsg, &a); //这里要传入引用保证是同一个对象
	//创建一个读取消息线程
	std::thread readTd(&A::readMsg, &a); //这里要传入引用保证是同一个对象
	insertTd.join();
	readTd.join();
	return 0;
}
```



语句1和语句2表示线程A先锁资源1，再锁资源2，语句3和语句4表示线程B先锁资源2再锁资源1，具备死锁产生的条件。

##### 3、死锁的解决方案

 保证上锁的顺序一致。

##### 4、死锁必要条件

- 互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。
- 不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放
- 请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。
- 循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

##### 5、处理方法

主要有以下四种方法：

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

**鸵鸟策略**

把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

**死锁检测与死锁恢复**

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

1、每种类型一个资源的死锁检测

[![img](https://camo.githubusercontent.com/985c9cc3e92cbc3f89f990fbc0f37570c2df7d5a3ce36ee17b58c6cc888aee5c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313635392e706e67)](https://camo.githubusercontent.com/985c9cc3e92cbc3f89f990fbc0f37570c2df7d5a3ce36ee17b58c6cc888aee5c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313635392e706e67)

上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

2、每种类型多个资源的死锁检测

[![img](https://camo.githubusercontent.com/ffe10fa6752bb7959197281d6a7653c1f817021f19f4908a7d2f7f02b268ab43/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313735382e706e67)](https://camo.githubusercontent.com/ffe10fa6752bb7959197281d6a7653c1f817021f19f4908a7d2f7f02b268ab43/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313735382e706e67)

上图中，有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

##### 6、死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

##### 7、死锁预防

在程序运行之前预防发生死锁。

1. 破坏互斥条件

 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

1. 破坏请求和保持条件

 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

1. 破坏不剥夺条件

 允许抢占资源

1. 破坏循环请求等待

 给资源统一编号，进程只能按编号顺序来请求资源。

##### 8、死锁避免

在程序运行时避免发生死锁。

1. **安全状态**

[![img](https://camo.githubusercontent.com/cd904f53e89be9fc253ae2229f10675019cf649cee73f639d648a1a972d8d107/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313834302e706e67)](https://camo.githubusercontent.com/cd904f53e89be9fc253ae2229f10675019cf649cee73f639d648a1a972d8d107/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313834302e706e67)

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。

定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。

1. **单个资源的银行家算法**

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

[![img](https://camo.githubusercontent.com/c13f19c1634aafb1068205eff725a538f942a4f1eff913dab0a387a7f28f4796/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313931312e706e67)](https://camo.githubusercontent.com/c13f19c1634aafb1068205eff725a538f942a4f1eff913dab0a387a7f28f4796/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313931312e706e67)

上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

1. **多个资源的银行家算法**

[![img](https://camo.githubusercontent.com/66bb9370037f8eea0f3f9a0bf469aa00945bd36258257aaaf8c8a8d70e2374f8/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313933392e706e67)](https://camo.githubusercontent.com/66bb9370037f8eea0f3f9a0bf469aa00945bd36258257aaaf8c8a8d70e2374f8/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666f7274686573706164612f6d65646961496d6167653140312e362e342e322f3230323130322f515125453625383825414125453525394225424532303231303232373030313933392e706e67)

上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

4、**检查一个状态是否安全的算法如下**：

- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

如果一个状态不是安全的，需要拒绝进入这个状态。



#### 60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？

分段式分配是按需分配，而固定式分配是固定分配的方式



#### 61、内部碎片与外部碎片

内碎片：分配给某些进程的内存区域中有些部分没用上，常见于固定分配方式

内存总量相同，100M

固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片；

分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片。

外碎片：内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中

分段式分配：内存总量相同，100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M+5M的外部碎片



#### 62、如何消除碎片文件

对于外部碎片，通过**紧凑技术**消除，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器地支持，且相对费时。紧凑地过程实际上类似于Windows系统中地磁盘整理程序，只不过后者是对外存空间地紧凑

解决外部内存碎片的问题就是**内存交换**。

可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。

回收内存时要尽可能地将相邻的空闲空间合并。



#### 63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）

- 存储器：内存
- 控制器：南桥北桥
- 运算器：CPU
- 输入设备：键盘
- 输出设备：显示器、网卡



#### 64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？

- 频繁修改：需要频繁创建和销毁的优先使用**多线程**
- 计算量：需要大量计算的优先使用**多线程** 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点
- 相关性：任务间相关性比较强的用**多线程**，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。
- 多分布：可能要扩展到多机分布的用**多进程**，多核分布的用**多线程**。

但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。



#### 65、服务器高并发的解决方案你知道多少？

- 应用数据与静态资源分离 将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。
- 客户端缓存 因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。
- 集群和分布式 （集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）
  （分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）
  可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。
- 反向代理 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。

# 计算机网络

## 1 边缘部分端系统间的通信						

实际上时端系统上两个进程间的通信；主要通信方式有C/S和P2P

## 2 通信子网和资源子网							

通信子网：实现数据通信；涵盖七层模型中下三层：物理层、数据链路层、网络层；

网络层实现数据通信主要设备：路由器；

数据链路层主要通信设备：交换机、网桥；

物理层主要通信设备：集线器、中继器

资源子网：实现资源共享/数据处理；涵盖上三层：应用层、表示层、会话层

## 3 网络分类								

按分布范围分：广域网WAN；城域网MAN；局域网LAN；个人区域网PAN

广域网使用交换技术；局域网使用广播技术

按交换技术分：电路交换；报文交换；分组交换

## 4 计算机网络性能指标

​								速率(比特率): 连接在计算机网络上的主机在数字信道上传送数据位数的速率 单位(b/s,kb/s,Mb/s,Gb/s)
​								带宽: 网络的通信线路传送数据的能力（单位时间内从网络中的某一个点到另外一个点所能通过的最高数据率,带宽的单位为b/s,kb/s,Mb/s,Gb/s) 。
​								一条通信链路，带宽越宽，所能传输的最高数据率也越高。
​								吞吐量:单位时间内通过某个网络（通信线路、接口）的实际的数据量
​								时延: 指数据（一个报文或分组，甚至比特）从网络(或链路)的一端传送到另一端所需的时间
​								发送时延	主机或路由器发送数据帧所需要的时间
​								传播时延	电磁波在信道中传播一定的距离需要花费的时间
​								处理时延	主机或者路由器接受到分组时要花费一定的时间去处理
​								排队时延	分组在网络传输时，进入路由器后要在输入队列中排队等待处理，路由器确定转发接口后，还要在输出队列中排队等待转发

## 5 分层结构、协议、接口、服务						

​								实体：每一层中的活动元素成为这层的实体，同一层建立的实体称为对等实体
​								协议：为进行网络中的对等实体数据交换而建立的规则
​								接口：上层使用下层服务的入口
​								服务：下层为相邻上层提供的功能调用[垂直关系上下]
​								SDU服务数据单元：每层中为完成用户所需要功能而传输的数据
​								PCI协议控制信息： 控制协议操作的信息
​								PDU协议数据单元：对等层次之间传输的数据单位
​								每层的PCI+SDU=每层的PDU；每层的PDU作为下一层的SDU

## 6 OSI七层模型：

应用层	所有能和用户交互产生网络流量的程序

常见协议：FTP、SMTP、HTTP

表示层	处理在两个通信系统中交换信息的表示方式(语法、语义)；数据格式变化、加密解密、压缩恢复

常见协议：JPEG、ASCII

会话层	向表示层/用户进程提供建立连接并在连接上有序的传输数据；也是建立同步(SYN)

常见协议：ADSP、ASP

传输层	负责主机中两个进程的通信，即端到端通信；传输单位：报文段/用户数据报；定义传输数据的协议端口号，以及流控和差错校验

常见协议：TCP、UDP
						
网络层	把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务；传输单位：数据报

功能：路由选择、流量控制、差错控制、拥塞控制；常见协议：IP、IPX、ICMP

数据链路层  把网络层传下来的数据报组装成帧；传输单位：帧

功能：	成帧、差错控制、流量控制、控制对信道的访问；常见协议：SDLC、HDLC、PPP

物理层	在物理媒体上实现比特流的透明传输；传输单位：比特；透明传输：不管所传数据是什么样的比特组合，都能在链路上传输
功能：	定义接口特性、传输模式(半双工、全双工)、传输速率、比特同步、比特编码；常见协议：Rj45、802.3

主机A-------------------------------------------------------------------------------------路由器-------------------------------------------------------------------------------------主机B
应用层	DATA+H7																																												 DATA+H7	应用层	
表示层	7-PDU+H6(DATA+H7=7-PDU)									  																	  7-PDU+H6(DATA+H7=7-PDU)	表示层
会话层	6-PDU+H5																																											  6-PDU+H5	会话层
传输层	5-PDU+H5																																											  5-PDU+H5	传输层
网络层	4-PDU+H5																				  网络层						                                                        4-PDU+H5	网络层
数据链路层  尾部+3-PDU+H5						                                        数据链路层				                                         尾部+3-PDU+H5	数据链路层 														
物理层	010101010000101010101010					                             物理层				                             010101010000101010101010	物理层
    ————————————————————————————————————————————————————>>>>>>>>>>>>>

表面上端系统到端系统之间是通过中间设备相连接，例如路由器；但是划分到具体七层来看，路由器只存在到网络层，所以上四层其实是端对端通信，而下三层是点对点通信

## 7 TCP/IP四层模型							

​           TCP/IP四层模型                                       TCP/IP协议栈							
​          应用层												HTTP  FTP  DNS(域名服务器)
​          传输层													TCP   UDP
​          网际层															IP
​          网络接口层									Ethernet ATM Frame Relay

与OSI参考模型对比:
          		         OSI											TCP/IP
网络层		无连接+面向连接					       无连接
传输层		   面向连接						     无连接+面向连接

	面向连接	
	a.建立连接；发出连接请求				
	b.请求成功；建立连接；传输数据
	c.数据传输完毕；释放连接
	面向无连接
	a.直接数据传输		

五层模型(融合OSI和TCP/IP)					

应用层
传输层
网络层
数据链路层
物理层

## 8 计算机网络为什么要分层？

### 8.1 什么是网络

计算机网络(可简称网络)把许多计算机连在一起，而互联网则是把许多网络连接在一起，是网络的网络。

以小写i开始的internet（互联网）是通用词泛指由许多个计算机网络互联而成的网络。在这些网络之间的通信协议是可以任意的。

以大写字母I开始的Internet(互联网)是专用名词，他指当前全球最大的，开放的由众多网络相互连接而成的特定互联网，并采用TCP/IP协议族作为通信规则，且前身是美国的ARPANET。Internet的推荐翻译是“因特网”。

### 8.2 网络作用范围分类

1. WAN
     WAN（wide area network）广域网，作用范围通常是几十到几千公里。广域网是互联网的核心部分，其任务是通过长距离运输主机所发送数据。常见于光	猫或路由器的外网接口。
2. MAN
     MAN（metropolitan area network）城域网，因器作用范围较小，通常并入局域网范围。
3. LAN
     LAN（local area network）局域网，通常公司，或家庭内主机相连组成的网络叫局域网。范围小于1KM，常见于路由器的LAN口。

### 8.3 网络的体系结构

  计算机网络是个非常复杂的系统，两台计算机通信除了有一条数据通道之外，还有更多的工作需要完成。

​	相互通信的两个计算机系统必须高度协调工作才行，而这种协调是相当复杂。

​	为了设计设计这样复杂的计算机网络，最初ARPANET提出分层的想法。

​	分层可以将庞大而复杂的问题，转化为若干个局部问题。

​	全球那么多网络当然也产生了很多的体系结构，全球经济的发展迫使不同网络体系结构的用户迫切的能够互相交换信息。

​	为了不同体系结构的计算机网络都能互联，国际标准化组织定义了著名的开放系统互联基本参考模型OSI/RM,简称OSI。

​	OSI的七层协议体系结构虽然概念清楚，理论也较完善，但他既复杂又不实用。后来就简化出了TCP/IP体系结构，并得到了广泛的应用。体系结构是抽象的，而实现这是具体的，是真正运行的计算机硬件和软件。

![image-20230727172513918](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727172513918.png)

  其中运输层也通常称为传输层。

​	在学习计算机网络原理是往往采取这种的办法，将OSI和TCP/IP优点综合，采取一种只有五层协议的体系结构。

1. **物理层**

   物理层，是参考模型的最低层，也是OSI模型的第一层。

   它实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质

   “透明传送比特流”的意思是经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

2. **链路层**
   单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是"链接层"的功能，它在"物理层"的上方，确定了0和1的分组方式。

   早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做"以太网"（Ethernet）的协议，占据了主导地位。

   以太网规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。

   ![image-20230727172531461](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727172531461.png)

   "标头"包含数据包的一些说明项，比如发送者、接收者、数据类型等等；"数据"则是数据包的具体内容。

   "标头"的长度，固定为18字节。“数据"的长度，最短为46字节，最长为1500字节。

   因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。

   上面提到，以太网数据包的"标头”，包含了发送者和接受者的信息。那么，发送者和接收者是如何标识呢?

   以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。

   网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。

   ![image-20230727172607966](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727172607966.png)

   每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。

   前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。

   ```
   定义地址只是第一步，后面还有更多的步骤。
   
   首先，一块网卡怎么会知道另一块网卡的MAC地址？
   
   回答是有一种ARP协议，可以解决这个问题。以太网数据包必须知道接收方的MAC地址，然后才能发送。
   ```

   

   3. **网络层**

​		以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，北京的网卡就可以找到纽约的网卡了，技术上是可以实现的。

​		但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一"包"，不仅效率低，而且局限在发送者所在的子网络。

​		也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是不合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难

​		互联网是无数子网络共同组成的一个巨型网络，想象上海和洛杉矶的电脑会在同一个子网络吗，这几乎是不可能的。

​		因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式

​		遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。

​		这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址”，简称"网址"。

​		

```
于是，"网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。

​两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。

​网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。
```

​		因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。

  规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。结合上篇写过的IP协议，本文就不在赘述。
  根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。

```
把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。
```

  具体来说，IP数据包也分为"标头"和"数据"两个部分。

![image-20230727172839049](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727172839049.png)

"标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。

```
IP数据包的"标头"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。

因此，理论上，一个IP数据包的"数据"部分，最长为65,515字节。

前面说过，以太网数据包的"数据"部分，最长只有1500字节。

因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了
```

**ARP协议**

​	因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。

​	通常情况下，只有知道对方ip才会去通信，但是我们不知道它的MAC地址。所以，我们需要一种机制，能够从IP地址得到MAC地址。

​	这里又可以分成两种情况。

​	第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。

​	第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。

​	ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。

​	它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。

​	总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。

4. **传输层**
     有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。

   ​	接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。

   ​	当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？

   ​	也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。

   ​	这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。

   ​	每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

   ​	"端口"是0到65535之间的一个整数，正好16个二进制位。

   ​	0到1023的端口被系统占用，用户只能选用大于1023的端口。

   ​	不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。

   ​	"传输层"的功能，就是建立"端口到端口"的通信。

   ​	相比之下，“网络层"的功能是建立"主机到主机"的通信。

   ​	只要确定主机和端口，我们就能实现程序之间的交流。

   ​	因此，Unix系统就把主机+端口，叫做"套接字”（socket进程间通信方式之一）。有了它，就可以进行网络应用程序开发了。

   ​	相关的传输层协议UDP，TCP等以后在详细总结。

5. **应用层**
      应用程序收到"传输层"的数据，接下来就要进行解读。

   ​	由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。

   ​	“应用层"的作用，就是规定应用程序的数据格式。

   ​	应用层协议众多，DNS、ntp、http，https，ftp，ssh，tftp，snmp，pop，imap、smtp、Telnet等等

   ​	举例来说，UDP或TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。

   ​	那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层”。

   ​	这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。

   ​	详细的数据包内容可以通过wireshark等工具抓取数据包，可以直观的看到数据包的没层包头组成和相关内容。

### 8.4 通信过程

![image-20230727171720917](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727171720917.png)

## 9 物理层

### 9.1 作用

解决如何在连接各种计算机的传输媒体上传输数据比特流

### 9.2 主要任务

确定与传输媒体接口相关的特性---定义标准



### 9.3 数据通信基础知识	

#### 9.3.1 术语	

1.码元								
								一个固定时长的信号波形(数字脉冲)，代表不同离散数值的基本波

​								当码元的离散状态由M个时，称为M进制码元 

​								二进制码元只需要一个比特就能表示两种离散状态；四进制码元需要2个比特表示4种离散状态；十六进制码元需要4个比特

2.带宽					

​								模拟系统中：当输入信号频率高/低到一定程度，系统的输出功率为输入功率的一半时，最高频率和最低频率的插值

​								数字设备中：单位时间内从网络中一点到另一点所能通过的最高数据率，用来表示网络的通信线路所能传输数据的能力；单位是比特每秒(bps)

​								信道带宽：信道能通过的最高频率和最低频率之差	

3.码间串扰								

​								码元传输速度太快，导致接收端收到的信号波形失去了码元间的清晰界限(分辨不出0和1)

​								奈式准则：在理想低通(无噪声，带宽受限 )条件下，极限码元的传输速率为2 W Baud；W是信道带宽，单位Hz	

4.基带信号和宽带信号							

​								将数字信号1和0直接用两种不同的电压表示，再送到数字信道上传输

​								基带信号就是发出的直接表达了要传输信息的信号，例如说话的声波

​								宽带信号将基带信号进行调制后形成的频分复用模拟信号，再送到模拟信道上传输

​								近距离传输时，计算机网络采用基带传输

​								远距离传输时，计算机网络采用宽带传输			

#### 9.3.2 三种通信方式							

单工通信：只有一个方向的通信，仅需一条信道

半双工：	通信双方都可以发送、接收消息，但任一方都不能同时接收和发送，需要两条信道(例子：对讲机)

全双工：	通信双方可以同时发送接收消息，需要两条信道(例子：打电话)

#### 9.3.3 两种数据传输方式

串行传输：将一个字符的8位按由地位到高位的顺序一次发送(一条信道)

并行传输：将一个字符的8位同时由8条信道发送

串行传输又分为同步传输与异步传输:							

同步传输：数据的传输以一个数据区块，在传出数据之前，先传出1个或多个同步字符(SYN),再传数据；传输单位为：数据帧

异步传输：将比特分车给小组传输，小组可以是一个字符或更长，传输数据时，需要加上一个起始位和终止位

#### 9.3.4.编码与调制							

编码：把数据转化为数字信号

调制：把数据转化为模拟信号

数字数据----数字发送器----数字信号(编码)					模拟数据------PCM编码器-----数字信号(编码)

数字数据----调制器--------模拟信号(调制)					   模拟数据------放大器调制器---模拟信号(调制)

把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段方便在信号中传输

### 9.4 数据交换方式

![image-20230727163118865](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727163118865.png)

### 9.5 传输介质

![image-20230727163204503](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727163204503.png)

### 9.6 物理层设备							

存在原因：由于存在损耗，在线路上传输的信号功率衰减，衰减到一定程度造成信号失真	


中继器(再生数字信号)：对信号进行再生和还原，对衰减的信号进行放大，保持与元数据相同，以增加信号传输的距离，延长网络的长度

集线器(再生，放大信号)：对信号进行再生放大，对衰减的信号进行放大，转发到其他所有处于工作状态的端口上，以增加信号传输距离

集线器不具备定向传送能力，是一个共享式设备

## 10 数据链路层

### 10.1 功能概述								

1. 在物理层提供服务的基础上为网络层提供服务，提供的最基本的服务是将网络层的数据可靠传输到相邻节点的目标机网络层
2. 同时加强物理层传输原始比特流的功能，将物理层提供可能出错的物理连接改造成逻辑上无差错的数据链路，对网络层表示为一条无差错的链路

功能1：								为网络层提供服务。无确认无连接服务、有确认无连接服务、有确认面向连接服务
功能2：								链路管理，即连接的建立、维持、释放(用于面向连接的服务)
功能3：								组帧
功能4：								流量控制：限制发送方再发数据
功能5：								差错控制(帧错/位错)

### 10.2 组装成帧与透明传输 								

**组装成帧**

在网络层传下的IP数据报前后添加首部和尾部形成帧；

首部和尾部包含许多控制信息，其中通过帧定界符来确认帧的开始和结束

帧同步：接收方能从收到的二进制比特流中区分出帧的开始和结束

组帧的四种方法：字符计数；字符填充；零比特填充；违规编码

帧的数据部分<=最大传送单元MTU

**零比特填充法:**							

在发送端，扫描整个信息子段，只要有连续5个1就填入1个0; 在接收端，先确认边界，再用硬件对比特流进行扫描，发现连续5个1就把后面0删除

**透明传输**

透明传输是指不管所传输的数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。

当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使接收方不会将这样的数据误认为是某种控制信息，这样才能保证数据链路层的传输是透明的。

### 10.3 差错控制

差错控制主要强调比特错，主要分为两种

1. 检错编码（奇偶校验码、循环冗余码CRC）
2. 纠错编码（海明码）

**检错编码 —— 奇偶校验码**

奇偶校验码由n-1位信息元和1位校验元，奇偶校验码分为奇校验码和偶校验码。

奇校验码：n-1位信息元和1位校验元组成n位比特，n位比特中1的个数为奇数。

偶校验码：n-1位信息元和1位校验元组成n位比特，n位比特中1的个数为偶数。

**检错编码 —— CRC循环冗余码**

CRC校验								

在发送帧后附加一个冗余码，生成一个新帧给接收端；

首先判断生成多项式的阶数r，在要发送的数据后加r个0，加0后的数和生成多项式进行模2除法

得到的余数就是冗余码(CRC检验码的比特序列)；此时最终发送的数据就是：要发的数据+计算出的冗余码

接收端收到的帧除以这个除数(生成多项式)，查看余数；余数为0，帧无错，接收；余数不为0，帧出错，丢弃
计算案例
要发送的数据是1101 0110 11，采用CRC校验，生成多项式是10011，最终发送数据？

计算冗余码（FCS）：1.加0： 10011——>1 x 4+0 *x 3+0* x 2+1 *x 1+1* x 0 阶数为4 ；加4个0——————>1101 0110 11 0000
	   2.模2除法：1101 0110 11 0000  ➗ 10011 = 1100 001......1110;余数就是冗余码1110

最终要发的数据就是1101 0110 11  1110

FCS的生成以及接收端CRC校验都是由硬件实现的，处理很迅速，因此不会厌恶数据的传输

### 10.4 流量控制								

较高的发送速度和较低的接受能力的不匹配，会造成传输出错

数据链路层的流量控制是点对点；控制手段：接收方收不下就不回复确认

传输层的流量控制是端到端的；控制手段：接收端给发送端一个窗口公告

**流量控制的方法**							

1. 停止等待协议
2. 滑动窗口协议：
   1. 后退N帧协议(GBN)
   2. 选择重传协议(SR)

**停止等待协议**(为了实现流量控制)
1.有差错情况 							

a.数据帧丢失或检测到帧出错
								超时计时器：每发送一个帧就启动一个计时器；计时器设置的重传时间应该比平均往返传播时延RTT长一些；超时后自动重传一帧
								发完一帧，必须保留帧的副本；数据帧和确认帧必须编号
b.确认帧ACK丢失
								计时器超时后重新传一帧，接收方丢弃ACK丢失的前一帧，重传确认新传的帧给发送方
2.无差错情况

停止等待协议简单，但信道利用率较低

停止等待协议也算一种滑动窗口协议，只不过发送和接收窗口都为1

**后退N帧协议**							

发送窗口为n个，最大值是2n次方 -1 ；接收窗口为1个

​								发送窗口：发送发维护的一组连续的允许发送帧的序号

​								接收窗口：接收方维护的一组连续的允许接收帧的序号

总结						

1. 累计确认(按顺收到好几个正确的帧，就会返回一次确认而不是每次都返回)
2. 接收方只能按顺序接收帧，不按序就直接丢弃
3. 确认序列号最大的、按序到达的帧
4. 在重传时必须把原来以及正确传送的数据帧重传，传送效率较低

**SR选择重传协议**							

发送窗口为n个 ；接收窗口为n个；最大窗口值为2(n-1)次方

接收方不论帧是否按序，都留下，没有按序的帧会被放入换曾，并返回确认该帧的确认帧，直到接收串口内所有帧被接收，再将这一批帧交付上层，然后向前滑动窗口

### 10.5 介质访问控制							

目的: 采取措施，使得两队节点之间的通信不会发生互相干扰

a. 静态划分信道----信道划分介质访问控制：

1. FDM: 频分多路复用技术
2. TDM: 时分多路复用技术
3. WDM: 波分多路复用技术
4. CDM: 码分多路复用技术

b. 动态分配信道----

1. 轮询访问介质访问控制：令牌传递协议
2. 随机访问介质访问控制（所有用户都可随机发送信息，发信息时占全部带宽）：ALOHA、CSMA、CSMA/CD、CSMA/CA协议

CSMA/CD：载波接听多点接入/碰撞检测：					

CS:在每一个站点发送数据之前以及发送数据时都要检测以下总线上是否有其他计算机在发送数据

MA：多点接入，表示许多计算机以多点接入的方式连接在一个总线上

CD：碰撞检测，边伐数据边检测其他站是否也在发数据

CA:   避免碰撞

### 10.6 局域网(广播信道)

**拓补结构**

![image-20230727170209535](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727170209535.png)

**介质访问控制方法**

![image-20230727170355336](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727170355336.png)

**链路层的两个控制子层**

![image-20230727170519062](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727170519062.png)





### 10.7 以太网

![image-20230727170724596](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727170724596.png)

**提供服务**

无连接:					发送方和接收方之间无"握手过程"

不可靠					 不对发送方的数据帧编号, 接收方不向发送方发送确认,差错帧直接丢弃,差错纠正由高层负责

以太网只实现无差错接收,不实现可靠传输



**适配器与MAC地址**

![image-20230727173525292](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230727173525292.png)

### 10.8 链路层设备

![image-20230728101116217](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728101116217.png)

## 11 网络层

### 11.1 功能概述

![image-20230728101219725](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728101219725.png)

### 11.2 路由算法与路由协议

![image-20230728101339965](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728101339965.png)

![image-20230728101434492](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728101434492.png)

### 11.3 IP数据报格式

#### 11.3.1 报文格式

前几篇总结过较多网络层的知识，ARP，IP地址、子网掩码等等。这次总结一下IP数据报的报文格式

IP数据报的格式能够说明IP协议都具有什么功能。在TCP/IP的标准中，各种数据格式常常以32位（4字节）为单位来描述的。

![image-20230728110301908](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728110301908.png)

wireshark中IP数据报文呈现：

![image-20230728110337027](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728110337027.png)

一个IP数据报文由**首部**和**数据**两部分组成。首部的前一部分是固定长度，共20字节。是所有IP数据报文必须具有的。在首部的固定部分的后面是一些**可选字段**，其长度可变。

#### 11.3.2 首部个字段意义

  1. 版本占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4（即IPv4）。版本号为6（即IPv6）

  2. 首部长度占4位，可表示的最大十进制数值是15。首部长度字段所表示的单位是32位（4字节，与TCP首部中长度字端单位一致）。因为IP首部的固定长度是20字节，因此首部长度字段的最小值为5（0101）。当首部长度为15（1111）时，表示的长度为60字节当IP分组的首部长度不是4的整数倍时，必须利用最后的填充字段加以填充达到4的整数倍。

  3. 区分服务占1字节，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。只有在区分服务时，这个字段才起作用。在一般情况下都不使用这个字段。

  4. 总长度占2字节，指首部和数据之和的长度，单位为字节。能表示的最大长度为65535字节。在IP层下面的链路层协议规定了一个数据帧的数据字段的最大长度，这称为最大传输单元MTU（maximum transfer unit）。当一个IP数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的链路层所规定的的MTU值。

     ```
     以太网规定MTU为1500字节。MTU是数据链路层所规定的，用于限制链路层数据部分的长度。
     按照分层组包思路MTU是作用于网络层（网络层此时是链路层的数据部分）。
     若所传送的数据报长度超过链路层的MTU值，就必须把过长的数据进行分片处理（后面会详细讲述）。
     ```

5. 标识（identification）占2字节。网络层软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不同于TCP首部中的序号，因为IP是无连接的服务，数据报不存在按序接收的问题。当数据报长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有被分片报文片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装层原来的数据。

6. 标志占3位，目前只有两位有意义。

   ```
   标志字段中间的一位记为DF（dongt fragment），意思是“不能分片”。当DF=0时才允许分片。
   标志字段最低位MF（more fragment）。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。
   ```

7. 片偏移占13位。片偏移指出：较长的IP报文在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。每片的长度一定是8字节的整数倍。

   ```
   例如：
   一数据报的总长度为3820字节，数据部分为3800字节（IP首部为固定20字节），需要分片传输。
   假设每片IP报文长度不超过1420字节。去掉固定首部长度20字节，每片报文数据部分长度不超过1400。
   于是分成3个数据报片，其数据部分长度分别为1400、1400、100字节。原始数据报首部被复制为各数据报片的首部，只需要改变有关字段的值。
   
   ```

   **数据分片举例**：

   ![image-20230728110942576](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728110942576.png)

**报文首部中与分片有关的字段中数值，标识部分是任意给定的值**：

![image-20230728111046857](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728111046857.png)

 8. 生存时间占8位，英文缩写TTL（Time To Live），表明数据报在网络中的寿命。

    由发出数据报的源点设置这个字段。目的是防止无法交付的数据无限制地在互联网中兜圈子。路由器在每次转发数据报之前就把TTL值减1。若TTL值减小到零，就丢弃此报文，不在转发。
    
9. 协议占8位，协议字段指出此数据报携带的数据是使用何种协议（上面数据包中协议字段为6表示使用TCP协议），以便使用的目的主机的IP层知道应将数据部分上交给哪个协议进行处理。
   常见的协议号：

   ![image-20230728111218029](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728111218029.png)

10. 首部检验和占16位，也常成为校验和。这个字段只检验数据报的首部，但不包括数据部分（与UDP、TCP中的检验和不同）。IP数据报每经过一个路由器，路由器都需要重新计算一下首部检验和（IP首部中的TTL、标志、片偏移等都可能发生变化）。检验和的计算方式这里就不总结了。
11. 源地址占32位
12. 目的地址占32位
    

### 11.4 IP地址与子网掩码

#### 11.4.1 IP地址

  IP地址是一种Internet上的主机编址方式，也称为网际协议地址
  IP地址是任意一台主机在网络中的唯一标识。我们使用的计算机，手机，及能接入网络的嵌入式设备都具有自己的IP地址。

#### 11.4.2 IP地址的分类

```
ipv4：占32位，通常使用点分十进制表示，例如：192.168.1.123
ipv6：占128位 通常是冒分16进制表示 可以缺省表示 例如 68af:bf:bb:69cc:11aa:ee:2f:cf
```

目前大部分计算机仍在使用IPv4，手机已经普遍使用IPv6.

#### 11.4.3 IPv4地址分类

```C
			二进制表示			点分十进制表示
A类   00000000 - 01111111   0.x.x.x - 127.x.x.x
B类   10000000 - 10111111   128.x.x.x - 191.x.x.x
C类   11000000 - 11011111   192.x.x.x - 223.x.x.x
D类   11100000 - 11101111   224.x.x.x - 239.x.x.x
E类   11110000 - 11111111   240.x.x.x - 255.x.x.x
```

**IP地址=网络地址+主机地址**

```c
网络地址:
如果是192的C段地址，那么，网络地址就是：192.168.1.0，地址掩码是：255.255.255.0。
如果地址掩码是：255.255.0.0，那么网络地址就是：192.168.0.0。
网络地址很大一部分是由地址掩码决定的。

主机地址：
如IP地址是202.112.14.137，掩码是255.255.255.224 ，
网络地址是202.112.14.128，子网号是128。
主机地址是202.112.14.137 。
```

![image-20230728113206376](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728113206376.png)

A，B，C类中的私有地址 只能通过NAT接入互联网

D类IP地址是组播地址

E类IP地址是保留测试用的

#### 11.4.4 子网掩码

掩码的作用就是区分这些IP是在哪些局域网内，更确切来说是区分在哪个网段内的

子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分

```
ip地址：192.168.1.1   子网掩码：255.255.255.0
ip地址：192.168.1.2   子网掩码：255.255.255.0
```

我们可以直接的判断，他们是同属于一个网段的IP地址

```c
ip地址：192.168.1.1   子网掩码：255.255.255.0
ip地址：192.168.1.2   子网掩码：255.255.0.0

将ip地址192.168.1.1转换为二进制
11000000 10101000 00000001 00000001
将子网掩码255.255.255.0转换成二进制
11111111.11111111.11111111.00000000
然后将两者相“与（and）"运算：
11000000 10101000 00000001 00000001
11111111.11111111.11111111.00000000
然后得到：
11000000 10101000 00000001 00000000
转换成网络号就是：192.168.1.0

```

这个可以从子网掩码来判断，192.168.1.1 255.255.255.0是属于192.168.1.0网段的；而192.168.1.2 255.255.0.0是属于192.168.0.0网段

要想判断两个IP地址是不是在同一个网段，只需将IP地址与子网掩码做与运算，如果得出的结果一样，则这两个IP地址是同一个子网当中。

**IP地址的斜线法**

```C
ip段一：192.168.0.1/22
ip段二：192.168.1.1/22
ip段三：192.168.2.1/22
```

这种192.168.1.x/22形式的IP地址相信大家平时都见过，就是已经告诉了子网掩码了。也就是说他们共同的子网掩码二进制前面22个都是1。

```C
子网掩码二进制表示
11111111 11111111 11111100 00000000
```

转换成十进制，那就是255.255.252.0，所以他们共同的子网掩码就是255.255.252.0

**IP地址和子网掩码计算网络地址和主机地址：**

例如，对于IP地址192.168.1.10，子网掩码为255.255.255.0，计算步骤如下：

1. 子网掩码为255.255.255.0，将其转换为二进制为11111111.11111111.11111111.00000000。
2. 将IP地址和子网掩码进行按位与运算，得到的结果是192.168.1.0，即网络地址。
3. 将子网掩码取反得到的结果为0.0.0.255，将IP地址和反码进行按位与运算，得到的结果为10，即主机地址。

因此，IP地址192.168.1.10的主机地址为10，网络地址为192.168.1.0。

#### 11.4.5 子网划分

1. 五类IP地址
IP地址分为A类、B类、C类、D类、E类，规定如下：

A类：网络位8位，主机位24位，网络前导位为0，即：

0*******...********即1.0.0.0—127.255.255.255

网络位00000000不可用，网络位01111111(127)表示回送地址，指本地机。

B类：网络位16位，主机位16位，网络前导位为10，即：

10******...********即128.0.0.0—191.255.255.255

C类：网络位24位，主机位8位，前导位为110，即：

110*****...********即192.0.0.0—223.255.255.255

D类：组播地址，前导位为1110，即：

1110****...****即224.0.0.0—239.255.255.255

E类：保留地址，前导位为11110，即：

11110***...********即240.0.0.0—247.255.255.255

其中A类、B类、C类IP地址可供普通用户使用。
![image-20230728125728782](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728125728782.png)

3. IP地址的相关规定
1. 网络地址、主机地址、广播地址

IP地址由“网络位+主机位”组成

​		网络地址：主机位全0

​		主机地址：网络位全0

​		直接广播地址：主机位全1

​	举例：IP地址201.161.20.18的网络地址是201.161.20.0，主机地址是0.0.0.18，直接广播地址为201.161.20.255。

2. 可用的IP地址
   主机位不可全0或全1（全0是网络地址，全1是广播地址）

   在一个网段内，最小的可用IP地址是“网络地址+1”，最大的可用IP地址是“广播地址-1”。

   举例：192.168.1.0～192.168.1.255网段中，可用的IP地址是：192.168.1.1～192.168.1.254

3. 受限广播地址(或称为“有限广播地址”)
   32位全1的IP地址(255.255.255.255)表示受限广播地址。

   受限广播地址和直接广播地址的区别，举例：255.255.255.255和192.168.5.255。

   交换机转发广播，路由器不转发广播。
   
4. 子网掩码
子网掩码用来区别网络位和主机位，用1表示网络位，用0表示主机位。比如：

A类IP地址的掩码：11111111.00000000.00000000.00000000 写成十进制255.0.0.0

也可以用/8来表示，表示前8位是网络位，比如：10.3.3.3/8

B类IP地址的掩码：11111111.11111111.00000000.00000000写成十进制 255.255.0.0

也可以用/16来表示，表示前16位是网络位，比如：172.16.7.6/16

C类IP地址的掩码：11111111.11111111.11111111.00000000写成十进制 255.255.255.0

也可以用/24来表示，表示前24位是网络位，比如：192.168.5.8/24

子网掩码为255.255.255.255表示本网段只有1个IP地址，举例：电信运营商动态分配给用户的IP地址110.80.191.243和子网掩码255.255.255.255。
5. 划分子网的三级网络结构
将一个大的网络划分成几个较小的子网，变成“网络位+子网位+主机位”的三级结构。

（一）子网掩码的计算(★记住)

10000000→128(借1位)

11000000→128＋64＝192(借2位)

11100000→128＋64＋32＝224(借3位)

11110000→128＋64＋32＋16＝240(借4位)

11111000→128＋64＋32＋16＋8＝248(借5位)

11111100→128＋64＋32＋16＋8＋4＝252(借6位)

11111110→128＋64＋32＋16＋8＋4＋2＝254(借7位)

11111111→128＋64＋32＋16＋8＋4＋2＋1＝255(借8位)

（二）子网划分计算

向主机位借1位可以划分成2个子网，借2位划分成4个子网，借3位划分成8个子网，如下：

28＝256，27＝128，26＝64，25＝32，24＝16，23＝8，22＝4，21＝2

地址类别是：A类

网络地址是：126.144.0.0 (主机位全0)

直接广播地址是：126.159.255.255 (主机位全1)

受限广播地址是：255.255.255.255

主机地址是：0.6.28.57 (网络位全0)

子网内的第一个可用IP地址是：126.144.0.1 (网络地址+1)

子网内的最后一个可用IP地址是：126.159.255.254 (广播地址-1)

网段

IP默认分配的子网掩码每段只有255或0

A类的默认子网掩码　255.0.0.0　一个子网最多可以容纳1677万多台电脑

B类的默认子网掩码　255.255.0.0　一个子网最多可以容纳6万台电脑

C类的默认子网掩码　255.255.255.0　一个子网最多可以容纳254台电脑

把子网掩码切换至二进制，我们会发现，所有的子网掩码是由一串连续的1和一串连续的0组成的（一共4段，每段8位，一共32位数）。

255.0.0.0　11111111.00000000.00000000.00000000

255.255.0.0　11111111.11111111.00000000.00000000

255.255.255.0　11111111.11111111.11111111.00000000

这是A/B/C三类默认子网掩码的二进制形式，其实，还有好多种子网掩码，只要是一串连续的1和一串连续的0就可以了（每段都是8位）。如11111111.11111111.11111000.00000000，这也是一段合法的子网掩码。子网掩码决定的是一个子网的计算机数目，计算机公式是2的m次方，其中，我们可以把m看作后面0的个数。如255.255.255.0转换成二进制，那就是11111111.11111111.11111111.00000000，后面有8颗0，那m就是8，255.255.255.0这个子网掩码可以容纳2的8次方（台）电脑，也就是256台，但是有两个IP是不能用的，那就是最后一段不能为0和255，减去这两台，就是254台。

计算方法

00　把将其转换为二进制的四段数字（每段要是8位，如果是0，可以写成8个0，也就是00000000）

11111111.1111111.11111000.00000000

然后，数数后面有几颗0，一共是有11颗，那就是2的11次方，等于2048，这个子网掩码最多可以容纳（2048-2）=2046台电脑。

我们再来看看这个改为默认子网掩码的B类IP

如IP： 188.188.0.111，188.188.5.222，子网掩码都设为255.255.254.0，在同一网段吗？

先将这些转换成二进制

IP(A) 188.188.0.111　10111100.10111100.00000000.01101111

IP(B) 188.188.5.222　10111100.10111100.00000101.11011010

Mask 255.255.254.0　11111111.11111111.11111110.00000000

255.255.254.0 是由23个1组成，也就是23位掩码。简单的说，由左往右数1，把十进制的IP换算成二制后，前23位1相同的情况下就属于同一个网段内的IP，24位后的1随意变化，属于同一网段。例中IP(A) 188.188.0.111，通过这个23位限制，可以看出的范围就是属于 188.188.0.0188.188.1.255范围，只有在这个范围内，才属于同一个网段内IP。IP(B)同网段的IP范围是188.188.4.0188.188.5.255的范围，显然不在IP(A)的范围内，所以IP(A)与IP(B)不是同一网段内IP。

分别and运算，得

10111100.10111100.00000000.00000000

10111100.10111100.00000100.00000000

网络标识不一样，即不在同一网段

IP网段与子网掩码

现在的企业规模越来越大，从原来的十几台，到几十台，现在是几百台。那么所需的IP地址数量也越来越多。我们都知道一个网段的IP地址数为0-255,除去0和255,只能有254台电脑，如果超过254台电脑，就需要增加IP地址，如何增加IP地址呢，为此就需要子网掩码。

现在的IP暂时由四段数字组成（以后将扩充更改），常分为三类IP:

A类：0.0.0.0到126.255.255.255

B类：128.0.0.0到191.255.255.255

C类：192.0.0.0到223.255.255.255

子网掩码：

在同一网段，要求网络标识相同，网络标识就是用IP的二进制与子网掩码的二进制数据作’与’运算（可用WINDOWS计算器算二进制），所以结果相同，表示在同一网段，而不是IP地址前几段相同就表示在同一网段。算网络标识的时候，A类IP只算第一段，B类只算第一，二段，C类IP算第一，二，三段。

例：192.168.0.1 255.255.255.0的网络标识为：192.168.0.0

192.168.0.1： 11000000.10101000.00000000.00000001

255 .255 .255 .0：11111111.11111111.11111111.00000000

作与运算：

11000000.10101000.00000000.00000000

结果：192.168.0.0

子网掩码决定了一个子网的计算机数目，简单的算法就是2的M次方。M表示二进制的子网掩码后面0的数目。

例：255.255.255.0

二进制：11111111.11111111.11111111.00000000

后面有8个0,那M就是8,这个子网掩码可以容纳2的8次方（台）电脑，也就是256台，去掉0和255就是254台电脑。

实例：一个公司有530台电脑，组成一个对等网，子网掩码如何设？IP如何设？

子网掩码：

2的M次方=530,求得M=10

那么子网掩码最后为10个0,如此便是：11111111.11111111.11111100.00000000

换成十进制便是：255.255.252.0

再看IP，我们选一个B类IP，例如：188.188.×.×

前两段按B类要随便设就可以，关键是第三段，只要网络标识相同就可以在同一网段就可以，我们先看网络标识：

255 .255 .252 .0：11111111.11111111.11111100.00000000

188.188.×.×： 10111100.10111100.？？？？？？××.××××××××

网络标识： 10111100.10111100.？？？？？？00.00000000

上边×号无论填0和1结果都是0

？处填0和1都一样，我们就全填0,结果便是IP便是：

10111100.10111100.000000××.××××××××，这个IP共有530台电脑，IP最后一段分给254台，一共要分530/254=2.086段，进一法则要分成3段，所以IP地址000000××处分成三个不同的数据即可，例：00000001，00000010，00000011，分别是1，2，3，这样IP地址就确定了188.188.1.×，188.188.2.×，188.188.3.×。

（三）举例

举例1： 172 .17.0.3/19子网掩码是多少 (借3位)

子网掩码11111111.11111111.11100000.00000000即255.255.224.0

举例2： 192 .168.6.7/26子网掩码是多少 (借2位)

子网掩码11111111.11111111.11111111.11000000即255.255.255.192

举例3： IP地址172.16.37.95，子网掩码为255.255.224.0，写出网络地址、主机地址和广播地址。

解答：224表示借3位，172.16.37.95→172.16.00100101.95；

网络地址：172.16.00100000.0→172.16.32.0 (主机位全0)

主机地址：0.0.00000101.95→0.0.5.95 (网络位全0)

广播地址：172.16.00111111.255→172.16.63.255 (主机位全1)

练习：写出以下IP地址的网络地址、主机地址和广播地址

172.16.99.8/255.255.240.0 (提示：172.16.01100011.8)

192.168.3.72/255.255.255.192 (提示：192.168.3.01001000)

10.33.4.5/255.248.0.0 (提示：10.00100001.4.5)

请多做课堂练习……。

四、考题(记住方法)

IP地址为126.150.28.57，子网掩码为255.240.0.0，那么地址类别是（），网络地址是（），直接广播地址是（），受限广播地址是（），主机地址是（），子网内的第一个可用IP地址是（），子网内的最后一个可用IP地址是（）

解答：

126.150.28.57/255.240.0.0→126.10010110.28.57

### 11.5 网络地址转换NAT

#### 11.5.1 局域网内主机如何与互联网上主机通信

  假设局域网内主机分配到本地IP地址，但想和互联网上的主机通信。那么应当采取什么措施呢？

​	最简单的办法就是设法申请一些全球IP地址。但这几乎无法做到，因为IPv4地址资源很早就被列强瓜分完毕

（IPv4地址满打满算只有42.9亿，去掉保留地址，组播地址，能用的只有36亿分。据说我们全国的全球IPv4不及美国一所大学的IPv4 地址数量）。目前使用得最多的方法是采用网络地址转换

​	网络地址转换NAT（Network Address Translation）方法是在1994年提出。

​	这种方法需要在局域网连接到互联网的路由器上安装NAT软件（目前大部分路由器都有此功能）。

​	装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。

​	这样，所有使用本地地址的主机在和外界通信时，都在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。
![image-20230728113530108](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728113530108.png)

```c
如上图，局域网内主机 A 的 IP 地址为 192.168.0.3，NAT 路由器有一个全球 IP 地址 172.38.1.5。
NAT路由器收到从局域网内主机 A 发往互联网上主机 B 的数据报：源 IP 地址是 192.168.0.3，目的 IP 地址是 213.18.2.4。
NAT 路由器把IP数据报的源IP地址192.168.0.3，转换为新的源IP地址 172.38.1.5（即NAT路由器的全球IP地址），然后转发出去。
因此 B 收到这个IP数据报时，以为 A 的IP地址是 172.38.1.5 。当 B 给 A 发送应答时，IP 数据报的 目的 IP 地址就是NAT路由器的IP 地址。

```

*NAT地址转换表举例*

| 方向 | 字段       | 旧的IP地址  | 新的IP地址  |
| ---- | ---------- | ----------- | ----------- |
| 出   | 源IP地址   | 192.168.0.3 | 172.38.1.5  |
| 入   | 目的IP地址 | 172.38.1.5  | 192.168.0.3 |

#### 11.5.2 网络地址转换与端口号转换

  上述的案例只是一个内网IP对应一个公网IP的转换方法，当一个子网内有很多主机需要连入互联网，就需要加入端口号才能对新旧IP形成映射关系。
NAPT地址转换举例

| 方向 | 字段                | 旧的IP地址和端口号   | 新的IP地址和端口号   |
| ---- | ------------------- | -------------------- | -------------------- |
| 出   | 源IP地址:源端口     | 192.168.0.3:3000     | 172 .38 .1 .5: 4001  |
| 出   | 源IP地址:源端口     | 192 .168 .0. 4: 3000 | 172. 38 .1.5: 4002   |
| 入   | 目的IP地址:目的端口 | 172.3 8 .1.5 :4001   | 192.168.0.3:3000     |
| 入   | 目的IP地址:目的端口 | 172 .38 .1. 5: 4002  | 192. 168. 0. 4: 3000 |

  从表中可以看出192.168.0.3主机向互联网发送IP数据报，其传输层端口号选择为3000

​	NAT路由器把源IP和端口号都进行转换（TCP，UDP原理一样，此处不分是哪种端口号）

​	另一台主机192.168.0.4也选择了通用的传输层端口3000。与另一台主机使用的端口号相同，纯属巧合（端口仅在本主机有意义）。

​	NAT路由器把内网中不同的源IP地址都转换为相同的全球IP地址。

​	但对源主机所采用的端口号（不管相同或者不同），则转换为不同的新的端口号。

​	当收到应答报文时，就可以从IP数据报的数据部分找出传输层端口号，然后根据不同的端口号从转换表中找到真正的目的主机。

### 11.6 ARP协议

#### 11.6.1 ARP简介

ARP全称是“Address Resolution Protocol”(地址解析协议)，ARP作用于以太网的环境之中，以太网环境之中数据的传输依赖的是MAC地址并不是我们所熟悉的IP地址，每个电脑都有一个IP地址记以及一个MAC地址（全球唯一），二者缺一不可，将我们所知道熟悉的IP地址转换为MAC地址就是ARP协议的工作

#### 11.6.2 ARP的工作原理

![image-20230728131217266](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728131217266.png)

1. Host 1发送数据前设备会先查找自己的ARP缓存表，如果有直接封装到帧里进行发送,如ARP缓存表没有对应IP地址的MAC信息，则会通过ARP进行获取
2. Host 1会发送ARP Request报文来请求获取Host 2的MAC地址（因为帧内没有目的MAC地址是不可以进行传输的，所以ARP报文内的目的MAC地址为全F）
3. 因为ARP Request目的MAC地址为 FF-FF-FF-FF-FF-FF（广播数据帧），所以交换机收到后会直接对该帧进行泛洪（广播）操作，并且学习该IP的MAC地址以及端口号到交换机自己的MAC缓存表
4. 所有主机都接受到该ARP Request报文后，都会检查该帧的目的IP地址与自身的IP地址是否匹配，不匹配就直接丢弃，Host发现与自己IP地址匹配，就会先把发送端的IP与MAC地址信息记录到自己的ARP缓存表之中，然后Host2就会发送ARP Reply报文（因为刚才进行了学习所以知道Host1的MAC地址，所以ARP Reply是单播数据帧）来进行响应
5. 交换机收到单播数据帧以后，会对该帧进行转发操作，并且学习Host2的MAC地址和端口号到自己的MAC缓存表
6. Host 1收到Host 2的ARP Reply报文后会检查目的IP与自己IP地址字段是否相同，如果匹配就将回应报文的源IP地址与MAC地址学习到自己的ARP缓存表之中，然后就可以传输信息进行通信

总结

-----Host 1查找自身缓存表

-----发送广播ARP Request报文

-----交换机对该广播帧直接执行泛洪操作并且进行学习

-----Host 2查询到是在问询自己，先进行学习再进行回复

-----交换机进行转发该单播数据帧，并且学习MAC地址信息和端口号

-----Host 1收到回复后进行学习到ARP缓存表中

#### 11.6.3 ARP协议在同网段工作原理

![image-20230728131347212](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728131347212.png)


 在同网段也就是在同一个局域网之中同一个广播域之中，以下统称为局域网，在局域网中，网络传输的实际是“帧”，帧里面有很重要的两个构成是源MAC地址与目的MAC地址，所以两台PC间想要通信就必须获取目的PC的MAC地址，但是我们一般都只是知道目的PC的IP地址（简单好记嘛），如何通过IP地址找到对应的MAC地址呢，这时候就是发挥ARP(地址解析协议)作用的时候，ARP协议可以通过目标设备的IP地址查询目标设备的MAC地址，然后对数据进行转发，以保证通信的顺利进行

-----Host 1查找自身缓存表，如没有发送广播ARP Request报文

-----交换机对该广播帧直接执行泛洪操作并且进行学习

-----Host 2查询到是在问询自己，先进行学习再进行回复

-----交换机进行转发该单播数据帧，并且学习MAC地址信息和端口号

-----Host 1收到回复后进行学习到ARP缓存表中

-----Host 1将Host 2的MAC地址封装到目的MAC地址，然后进行传输信息

-----交换机收到该单播信息帧后，将该帧解封装到第二层数据链路层（交换机是二层设备）获取目的MAC地址，在查询自身MAC缓存表进行转发操作

-----Host 2收到该帧后进行解封装获取信息内容

![image-20230728131440251](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728131440251.png)



#### 11.6.4 ARP协议在不同网段工作原理

![image-20230728131504350](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728131504350.png)


目标：pc1（192.168.1.1）向pc3（192.168.2.1）跨网段通信，以下统称pc1为主机1  pc2为主机3

-----1. 主机1数据封装IP后继续向下封装，但是发现没有主机2的MAC地址，于是查询ARP,ARP缓存表里没有该IP的MAC地址信息,但是发现主机2IP不是本网段IP需要跨网段传输（跨网段传输借助IP），跨网段相当于要出本局域网的这个大门，所以需要找网关，查询ARP表，发现没有网关MAC地址信息

-----2.主机1先把要发送的信息放入缓存中，然后在本局域网内发送ARP Request报文请求网关的MAC地址

-----3. LSW1对该帧源mac和接口信息进行学习，然后对该广播报文进行泛洪操作

-----4. AR1收到广播数据包后，先将主机1的MAC信息学习到自己的MAC地址表中，然后对比该报文的目的IP是否为自己，AR1发现请求的正是自己的MAC地址，于是AR1回复一个ARP Reply报文(封装自己的IP地址为源IP地址，自己的MAC地址为源MAC地址)，内容大概是“我是网关，我的MAC地址是xxxxxxxxxxxxxxxxxx”

-----5. LSW1进行学习网关MAC与端口信息，并进行转发

-----6.主机1收到AR1的回复报文后，将缓存的数据拿出，目的IP为主机3IP目的MAC为本网段网关的MAC地址（跨网段通信，目的MAC地址统一写本网段内网关的MAC地址，意思是帧交给网关就完事了，由网关进行下一步转发，就没主机的事了，目的MAC写网关即可），重新封装好后进行重新发送

-----7.在同网段内靠MAC地址进行传输，所以AR会收到这个数据包，但是AR发现这个数据包的目的IP地址并不是自己，所以就需要进行路由（查询一条前往的道路），从路由表查找通向192.168.2.0网段192.168.2.1的地址，AR准备从对应的网关（接口）进行发送，然hou查询MAC地址表，如果有就进行转发，没有的话就发送ARP Request报文进行问询主机3的地址

-----8. LSW2学习MAC地址和端口信息并泛洪该广播报文

-----9.主机3学习核对并回复一个ARP Reply报文

-----10. LSW2学习并转发该单播回复报文

-----11. AR1收到回复后i，目的IP以及目的MAC地址信息封装为主机3的相关信息，加上FCS，封装好后进行发送（源IP为pc1但是源mac地址为AR1的出口mac地址）  --感谢各位指正，谢谢

-----12. LSW2查询并转发

-----13，主机3收到数据包进行解封装，看到数据载荷，发送过程完成

-----14，主机3收到信息后进行回复，不在同网段就回复给本网段网关，通过LSW2转发给AR1(不需要学习,MAC地址表有一定有效时间)

-----15，网关（AR)收到回复后将数据包里的目的MAC换成主机1的MAC，再通过LSW1转发到主机1的手中

注：有发送有回复，才是一个完整的传输过程，二者缺一不可

注意：

1. 同网段通过MAC地址进行通信，跨网段（上网）通过IP地址进行通信

2. 跨网段的转发过程是局域网传输（MAC）---路由（IP地址）---局域网传输（MAC）

3. 跨网段传输目的MAC地址写网关的MAC地址，网关接收后将数据包中自己的MAC换成数据包里真正对应的MAC地址

4. ARP请求以广播发送，ARP Reply报文是单播回复的方式

5. 路由器隔绝广播域，交换机隔绝冲突域

6. 源IP地址和目的IP地址是始终不变的（个人觉得应该是因为需要路由）
   

11.7 网络层设备

![image-20230728131823326](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728131823326.png)

## 12 传输层

### 12.1 功能概述

![image-20230728131937082](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728131937082.png)

### 12.2 传输层两个协议

![image-20230728132020481](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728132020481.png)

#### 12.2.1 传输层的寻址与端口

![image-20230728132200692](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728132200692.png)





![image-20230728132256968](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728132256968.png)

#### 12.2.2 用户数据报协议UDP

1. 传输层特点

  传输层是整个网络体系结构中关键层次之一

> 1、传输层为相互通信的应用进程提供逻辑通信。
> 2、相关协议UDP、TCP。
> 3、网络层和传输层的区别：网络层为主机之间提供逻辑通信，而传输层为进程之间提供端到端的逻辑通信。
>
> ![image-20230728132510950](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728132510950.png)

2. 端口号
     端口号是传输层重要的标识，就象网络层的IP标识一样。

        TCP/IP的传输层用一个16位端口号来标志一个端口，端口只具有本地意义（A主机与B主机中的端口无关联）。

   ​	16位的端口号可允许65535个不同端口号。

   ​	在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口是不同的。

   ​	硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。

   ​	服务器端使用的端口号又分为两类，重要的一类叫做熟知端口号，范围一般在0~1023。

   ​	常见的熟知端口号和其对应的应用程序。

```
FTP：21；TELNET：23；SMTP：25；DNS：53；TFTP：69；HTTP：80；SNMP：161；HTTPS：443；
```

3. UDP
     

用户数据报协议UDP（User Datagram Protocol）只是在ip的数据服务之上增加了一点功能，复用和分用的功能以及差错检测功能。

UDP的主要特点是：

1、UDP是无连接的，减少了开销和发送数据之前的时延。
2、UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3、UDP是面向报文的。发送方的UDP对应程序交下来的报文，在添加首部之后就向下交付IP层。对应用层交下来的报文，既不合并，也不拆分。
4、在接收方的UDP，对IP层交上来的UDP数据报，在去除首部之后就原封不动地交付上层应用程序。
5、UDP支持一对一，一对多、多对一和多对多的交互通信。
6、UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

wireshark抓包：

![image-20230728132752157](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728132752157.png)



注意：
  虽然UDP之间的通信要用到端口号，但由于UDP的通信时无连接的，因此不需要使用套接字（TCP之间的通信必须要在两个套接字之间建立连接。）
  伪头部：UDP数据报首部中检验和的计算方法有些特殊，在计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓“伪首部”是因为它并不是UDP用户数据报的真正首部。只是在计算校验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP数据报。伪首部记不向下传递，也不向上递交，仅仅为了计算校验和。
伪首部内容：
![image-20230728132835791](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728132835791.png)

#### 12.2.3 传输控制协议TCP

**TCP概述**

TCP（Transfer Control Protocol）传输控制协议，是TCP/IP体系中非常复杂的一个协议。

其主要特点如下：

1. TCP是面向连接的传输层协议。这就是说，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。TCP通信类似打电话：通话前序拨号连接，通话后序挂机结束连接。
2. TCP连接只能有两个端点，每一条TCP连接只能点对点。
3. TCP提供可靠交付的服务。通过TCP连接传输数据，无差错、不丢失、不重复，并且按序到达。
4. TCP提供全双工通信。连接的两端都设有发送缓存和接收缓存，进程在任何时候都能收发数据。
5. 面向字节流。TCP中的流（stream）指的是流入到进程或从进程流出的字节序列。

  TCP把连接作为最基本的抽象。TCP的许多特性都与TCP是面向连接的这个基本特性有关。

**TCP首部格式**

​	TCP虽然是面向字节流的，但TCP传输的数据单元是报文段。

​	一个TCP报文段分为首部和数据部分，与UDP一致。而TCP的全部功能体现在它首部中各字段的作用。

​	TCP报文首部前20个字节是固定的，后面有4n（n为整数）字节根据首部需要而增加的选项。

​	TCP首部最小长度为20字节。

![image-20230728133247844](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728133247844.png)

**与wireshark抓包对照**

![image-20230728133332505](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728133332505.png)

**各字段说明**

 1. **源端口号**和**目的端口号** 各占2个字节，与UDP端口用法相似。

 2. **序号**占4个字节。序号范围是0~2^32 -1， 表示此次发送的数据在整个报文段中的起始字节数。为了安全起见，它的初始值是一个随机生成的数，它到达最大值后，又从零开始。在TCP连接中传送的字节流中**每一个字节都是按顺序编号**。

    例如：

    > 一段报文的序号是301，携带的数据共有100字节。表明：本段数据第一个字节的序号是301，最后一个字节的序号是400。如果此时还有下一段报文，数据的序号应当从401开始，即下一段的序号字段值应该为401。

 3. **确认号**占4个字节，指定的是**期望收到下一个报文段的第一个字节的序号**

    B正确收到A发来的报文段，其**序号**字段值是301，数据长度是100字节。表明B正确收到了A发送的到序号400为止的数据。因此B期望收到A的下一个数据序号是401，于是B在发送给A的确认报文段中把确认号置位401。

    

 4. **数据偏移**占4**位**，指出TCP报文段的首部长度。因为首部中有长度可变选项，因此此字段是必要的。应注意此字段的单位是**32位（4字节）**，4位二进制数能表达的最大十进制数是15，因此可表达的最大长度值为15*4=60字节。即后面的**选项**字段长度不能超过40字节。

 5. **保留**占6位，保留为后续开发功能使用。当前置为0

 6. **紧急URG**，占1位，置为1时表明该字段有效。标明报文有紧急数据，传输优先级高

 7. **确认ACK**，占1位，当ACK=1时确认字段有效。当为0时，确认无效。TCP规定，**在连接建立后所有传送的报文段都必须把ACK置1**

 8. **推送PSH（PuSH）**，占1位，当两个进程在通信时，一端的进程希望在键入一个命令后立即能够收到对方响应。这种情况下，TCP就可以使用推送操作。发送方把PSH置1，并发送出去，接收方收到PSH = 1的报文就会尽快地交付相应资源。平时很少使用

 9. **复位RST**，占1位，当RST置1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接

 10. **同步SYN**，占1位，在连接建立时用来同步序号。当SYN=1而ACK=0，表名这是一个连接请求报文。若同意建立连接，响应报文中使SYN=1和ACK=1。后面三次握手会重点说

 11. **终止FIN**，占1位，用来释放一个连接。当FIN=1时，表明此报文的发送方的数据已发完毕，并要求释放连接。后面四次挥手也会用到

 12. **窗口**占2个字节。窗口值是0 ~ 2^16 -1之间的整数。窗口指的是自己的 **接收窗口**。窗口值告诉对方自己能接收的**数据量**（字节为单位）。之所以有这个限制，是因为接收方的数据缓存空间时有限的。根据进程的处理速度，窗口值经常在动态的变化

 13. **检验和**，占2字节。检验和字段检验的范围包括**首部**和**数据**两部分。和UDP一致，要在TCP报文的前面加上12字节的伪首部。与之前的UDP那篇一样，只不过将**协议号**，和**长度**字段变换

 14. **紧急指针**，占2字节。紧急指针仅在URG=1有意义。它指出本报文段中紧急数据的长度即字节数。注意：即使窗口为零时也可以发送紧急数据

 15. **选项**填充，长度可变，最长40字节。当没有使用此字段时，TCP的首部长度是20字节

     

**TCP的连接建立****(三次握手)**

![image-20230728134407961](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728134407961.png)

**注意：**

> 其中大写**ACK**（Acknowledgment）是确认字段，小写**ack**（Acknowledgment number ）是**确认号**字段，seq是**序号**字段

假定主机A运行的是TCP客户程序，B运行的是TCP服务器程序。最初两端的TCP进程都处于CLOSED（关闭）状态。上图，主机下面的方框分别是TCP进程所处的状态。本例中，A主动打开连接，B被动打开连接。
  一开始，B的TCP服务进程会一直处于LISTEN（监听）状态，等待客户的连接请求。

  1. A的TCP客户进程打算与B建立TCP连接时，向B发出连接请求报文，结合上面总结过的FLAGS字段各个标志位，这时报文TCP首部中同步位SYN=1，同时序号字段随机初始化一个数值seq=x。TCP规定，SYN=1的报文不能携带数据，但要消耗一个序号（即A的下个报文序号需+1）。这时TCP客户进程进入SYN-SENT（同步已发送）状态。
          2. B收到连接请求报文后，如果统一建立连接，这向A发送确认。在回应的TCP报文中把SYN和ACK字段都置1，确认号ack=x+1，同时也为自己随机初始化一个序号seq=y。此段报文也不能携带数据，但同样需要消耗一个序号（即B的下个报文序号需+1）。这时TCP服务进程进入SYN-RCVD（同步收到）状态。
                  3. A的TCP客户进程收到B的确认响应后，还需向B给出确认。报文段中TCP首部ACK字段置1，确认号ack=y+1，自己的序号seq=x+1。ACK=1的报文段可以携带数据。如果不携带数据则不消耗序号（即A的下一个TCP报文序号字段仍是seq=x+1）。这时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态
          4. B收到A的确认后也进入ESTABLISHED状态。
       ![image-20230728134529972](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728134529972.png)

**TCP的连接释放(四次挥手)**

![image-20230728134707941](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728134707941.png)

 如上图，A,B双方都处于ESTABLISHED，假设A的应用进程先主动关闭TCP连接。

  1. A应用进程发出释放连接报文段，TCP报文首部终止控制位FIN置1，其序号seq=u，u等于前面已传送的数据的最后一个字节的序号加1。这时A进入FIN-WAIT-1（终止等待1）状态，等待B的确认。注意：FIN报文段即使不携带数据，也要消耗一个序号，与SYN，ACK报文一致
          2. B收到连接释放报文后即发出确认并响应，首部中，seq=v,确认号ack=u+1。然后B进入CLOSE-WAIT（关闭等待）。因为A到B这个方向连接已释放，这时TCP连接处于半关闭（half-close）状态，即A到B已经没有数据要发送了，但若B发送数据到A，A仍然要接收，B到A的连接并未关闭，这个状态持续时间根据B的情况而定。
                A收到来自B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出释放连接报文
                    3. 当B已经没有要向A发送的数据时，B发出连接释放报文段，TCP首部中FIN=1。其中假定序号seq=w,确认序号认为ack=u+1。此时B进入LAST-ACK（最后确认）状态，等待A的确认
          4. A收到B的连接释放报文段后，必须对此发出确认。在确认报文中把ACK置1，确认序号ack=w+1,自己的序号seq=u+1。然后进入TIME-WAIT（时间等待）状态。注意：此时TCP连接还没释放掉。必须经过时间等待计时器设定时间2 MSL后（设定的时间为多长不同场景不定，大家可自行查询），A才能进入到CLOSED状态。B收到A发出的确认，进入CLOSED状态。


![image-20230728134910204](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728134910204.png)

设置时间等待的原因：

> 1、为了保证A发送的ACK报文段能够到达B。
> 2、防止“已失效连接请求报文段”。

## 13 应用层

### 13.1 网络应用模型

![image-20230728135245625](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728135245625.png)

![image-20230728135310106](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728135310106.png)

### 13.2 URL、域名、DNS

1. URL
     即Uniform Resource Locator，统一资源定位符，也叫做网址。是互联网用来标识主机的名字，该名字具有唯一性，层次性，字面意思可以标识主机的账号、功能、性质、所属的地区或组织、便于所有互联网用户记忆与使用，用于指明互联网主机的服务器及具体的网页位置，URL的构成策略与示例如下：
   URL示例：
   ![image-20230728135418460](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728135418460.png)

   上述URL的组成为

> 协议 ——http
> 服务器名（域名） ——www.ocp.org
> 目录 ——protocol
> 文件 ——index. html

2. 域名
     域名domain name，又称网域，是由一串点分隔的名字组成的。代表网络上某台计算机或计算机组的名称，不同于URL，域名不带后面的文件路径，是计算机的定位标识.
        由于ip地址不便于记忆且不能直观显示地址组织名称，人们设计出了域名，并通过网域名称系统DNS，domain name system来讲域名和ip地址相互映射，使人们更方便地访问互联网，而不用几组能被机器直接读取的IP地址。
        域名构成

   https://www.baidu.com/
   顶级域名 ——com
   二级域名 ——baidu
   三级域名 ——www


3. DNS
     计算机通过域名并不能直接访问到相关计算机，因此需要有域名解析系统存在，将域名转换为计算机能识别的IP并访问到相关主机。
        DNS中文意思是域名系统，是互联网中提供域名与IP地址互相映射的分部是数据库。
        通过域名获得对应IP地址的过程叫做域名解析，参与域名解析过程重要的环节就是域名服务器。
   ![image-20230728135538372](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728135538372.png)

### 13.3 文件传输协议

1. FTP
     文件传送协议 FTP（File Transfer Protocol）是互联网上使用的最广泛的文件传输协议。FTP提供交互式访问，允许客户指明文件的类型与格式，并允许文件具有存取权限（如访问文件的用户必须经过授权，如输入有效的用户名或密码）。FTP屏蔽了各种计算机系统的细节，因而适合于在复杂的网络中任意计算机之间传送文件。

2. FTP的基本工作原理
     网络环境中的一项基本应用就是将文件从一台计算机中复制到另一台可能相距很远的计算机中。初看起来，在两台主机之间传送文件很简单的事情。其实这往往非常困难。原因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。经常遇到的问题是：

   计算机存储数据的格式不同
   文件的目录结构和文件命名的规定不同
   对于相同的文件存储功能，操作系统使用的命令不同
   访问控制方法不同

  文件传输协议FTP只是提供文件传输的一些基本的服务，它使用TCP可靠的传输服务。FTP主要的功能是减少或消除在不同操作系统下处理文件的不兼容性。
  FTP使用客户端服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由两大部分组成：一个主进程，负责接收请求；另外有若干个从属进程，负责处理单个请求。
  主进程的工作步骤：

​	打开熟知端口号（端口号为21），使客户进程能够连接上。
​	等待客户进程发出连接请求。
​	启动从属进程处理客户进程发来的请求。
​	回到等待状态继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发的。
![image-20230728135834763](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728135834763.png)

当客户进程想服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口号 21，同时还要告诉服务器自己的端口号，用于建立数据传送连接。接着服务器进程用自己传送数据的熟知端口号 20 与客户进程所提供的的端口号建立数据传送连接。由于FTP使用了两个不同的端口号，所以数据连接与控制不会发送混乱。
  FTP并非对所有的数据传输都是最佳的。例如，计算机 A 上运行的应用程序要修改远地计算机 B 的一个很大的文件。若使用FTP，则应先将此文件从计算机 B 传送到计算机 A ，然后进行修改，再用FTP将此文件传送到计算机 B ，来回传送这样的大文件很花时间。实际上这种传送是不必要的，因为计算机 A 并没有使用该文件的内容。

3. TFTP
     TCP/IP协议族中还有一个简单文件传输协议TFTP（Trivial File Transfer Protocol），它是一个很小且易于实现的文件传输协议。TFTP虽然也是用客户端服务器方式，但它使用 UDP 数据报，因此TFTP需要有自己的差错改正的措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。
        TFTP 的主要优点有两个。第一，TFTP 可用于UDP 环境。例如，当需要将程序或文件同时向许多机器下载时就往往需要使用TFTP 。第二，TFTP 代码所占内存较小。这对较小的计算机或某些特殊用途的设备是很重要的。这些设备不需要硬盘， 只需要固化了 TFTP、UDP 和 IP的小容量只读存储器即可。


### 13.4 万维网

​	目前我们用浏览器浏览网页大部分网址都是www开头如www.baidu.com。

​	www（world wide web）万维网，并非某种特殊的计算机网络。

​	万维网是一个大规模的、联机式的信息储藏所，英文简称web。

​	万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。

​	万维网以客户服务器方式工作。上面所说的浏览器就是在用户主机上的万维网客户程序。

​	万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。

​	客户程序向服务器程序发出请求，服务器程序向客户程序应答所要的万维网文档。

​	在一个客户程序主窗口上显示出来的万维网文档称为页面（page）

​	如下图说明了万维网提供分布式服务的特点。
![image-20230728140059043](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728140059043.png)

**链接**
  上图画出了五个万维网上的站点，他们可以相隔数千公里，但都必须连接在互联网上。

​	每个万维网站点都存放了许多文档。在这些文档中有一些地方的文字是特殊方式显示的（不同颜色，或下划线），我们将鼠标移动到这些地方时，鼠标箭头就变成了一直收的形状。

​	这就表明这些地方有一个链接（link，这种链接有时候也称为超链接hyperlink），如果我们在这些地方点击鼠标，就可以从这个文档链接到可能相隔很远的另一个文档。

**超媒体和超文本**
  万维网是一个分布式的超媒体（hypermedia）系统，它是超文本（hypertext）系统的扩充。

​	超文本：使用的应用层协议是http。是指包含指向其他文档链接的文本（text）。一个超文本由多个信息源链接成，而这些信息源可以分布在世界各地，并且数	目也是不受限制的。利用一个链接可使用户找到远在异地的另一个文档，而这有可链接到其他的文档。超文本是万维网的基础。
​	超媒体：与超文本的区别是文档的内容不同。超文本文档仅包含文本信息，超媒体文档还包含其他表示方式的信息如图形、图像、声音、动画以及视频图像等。**统一资源定定位符**

  **统一资源定位符URL**是用来表示从互联网上得到的资源位置和访问这些资源的方法。URL 给资源的位置提供一种抽象的识别，并用这种方法给资源定位。只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找属性。URL的一般形式由以下四个部分组成。

```
<协议>://<主机>:<端口>/<路径>
```

现在有些浏览器为了方便用户，在输入URL时，可以把最前面的“http://”甚至把主机名前面的“www”给省略，然后浏览器替用户把省略的字符填上。如只需要输入Baidu浏览器就会把未键入的字符补齐，变成http://www.baidu.com。

# 网络编程

## 1 TCP/ UDP

### 1.1 TCP怎么保证可靠性？

1. 序列号、确认应答、超时重传

   数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且**确认序号会说明了它下一次需要接收的数据序列号**。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。  

2. **窗口控制与高速重发控制/快速重传（重复确认应答）**  

   TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。**如果不使用窗口控制，每一个没收到确认应答的数据都要重发**

   使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒…

### 1.2 TCP建立连接和断开连接的过程  

**TCP建立连接和断开连接的过程**  

![image-20230728140716158](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728140716158.png)

**三次握手**

1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认
2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J 1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态
3. Client收到确认后，检查ack是否为J 1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K 1，并将该数据包发送给Server，Server检查ack是否为K 1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。  

**四次挥手**

由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

1. 数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据
2. 服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号 1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态
3. 当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认
4. 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号 1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

### 1.3 TCP的三次握手和四次挥手的原因是什么？

**为什么是三次握手？**

1. 为了防止已失效的连接请求报文段突然有送到了B，因而产生错误
2. 假设两次握手时，A发出的第一个请求连接报文段在某一网络节点长时间滞留，以致延误到连接释放后才到达B。B收到失效的连接请求报文段后，认为是A又发出一次新的连接请求。于是向A发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致B的资源白白浪费
3. 假设两次握手时，A发出一个请求报文段，但发送过后A就因为问题而导致下线。之后B收到了A发来的请求连接报文段，给A发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致B的资源白白浪费

**为什么是四次挥手？**

1. TCP协议是全双工通信，这意味着客户端和服务器端都可以向彼此发送数据，所以关闭连接是双方都需要确认的共同行为
2. 假设是三次挥手时，首先释放了A到B方向的连接，此时TCP连接处于半关闭（Half-Close）状态，这时A不能向B发送数据，而B还是可以向A发送数据。如果此时A收到了B的确认报文段后，就立即发送一个确认报文段，这会导致B向A还在发送数据时连接就被关闭。这样会导致A没有完整收到B所发的报文段

### 1.4 TCP，UDP的区别是什么？

1. TCP 是面向连接的，UDP 是面向无连接的
2. UDP程序结构较简单
3. TCP 是面向字节流的，UDP 是基于数据报的
4. TCP 保证数据正确性，UDP 可能丢包
5. TCP 保证数据顺序，UDP 不保证

### 1.5 TCP，UDP的优缺点是什么？

**TCP的优点**：可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源

**TCP的缺点**：慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

**UDP的优点**：快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击。

**UDP的缺点**：不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

### 1.6 TCP，UDP适用场景

**TCP应用场景**

效率要求相对低，但对准确性要求相对高的场景。

因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。

举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

**UDP应用场景**

效率要求相对高，对准确性要求相对低的场景。

举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

### 1.7  TCP相比UDP为什么是可靠的？

1. 确认和重传机：制建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础传输过程中，如果Checksum校验失败、丢包或延时，发送端重传
2. 数据排序：TCP有专门的序列号SN字段，可提供数据re-order
3. 流量控制：窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量
4. 拥塞控制：TCP的拥塞控制由4个核心算法组成。“慢启动”（Slow Start）、“拥塞避免”（Congestion avoidance）、“快速重传 ”（Fast Retransmit）、“快速恢复”（Fast Recovery）以上就是TCP比UDP传输更可靠的原因。

### 1.8 什么是TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？

**拥塞控制**

如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。

**慢启动**

定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个RTT），将拥塞窗口大小*2

**拥塞避免**：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。

将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。

快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。

然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。

**采用慢开始和拥塞避免算法的时候**

1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度

2. 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度

   

**采用快恢复和快重传算法的时候**

1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度
2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度

### 1.9 OSI和TCP/IP协议栈的对应关系  

![image-20230728143945626](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728143945626.png)

OSI 参考模型共有 7 层，从下到上分别为：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层

TCP/IP 模型大体分为四层：网络接口层、网际层、运输层、应用层

两者的对应关系为：

物理层+数据链路层 => 网络接口层

网络层 => 网际层运输层 => 运输层

会话层 + 表示层 + 应用层 => 应用层

### 1.10 TCP/IP数据链路层的交互过程是怎么样的？ 

网络层等在数据链路层用MAC地址作为通信目标，数据包到达网络层等往数据链路层发送的时候，

首先回去ARP缓存表去查找IP对应的MAC地址，如果查到了，就将此IP对应的MAC地址封装到链路层数据包的包头。

如果缓存中没有找到，则会发起一个广播，who is IP xxx tell IP xxxx，所有收到广播的机器看到这个IP是不是自己的，如果是自己的，则以单播的形式将自己的mac地址回复给请求机器   

### 1.11 传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文？  

根据端口继续区分需接受的程序；根据IP协议头中标识字段：UDP 17 、TCP 6

### 1.12 UDP的connect函数  

除非套接字已连接，否则异步错误是不会反悔到UDP套接字的。

我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。

内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。

对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。

其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。

一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。

1. 我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用send to，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0
2. 不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报
3. 由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。

### 1.13 TCP连接中time_wait状态的理解  

![image-20230728144852167](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728144852167.png)

time_wait状态如何产生？

由上面的变迁图，首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2 MSL时间之后才会回到初始状态。MSL值得是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2 MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。

time_wait状态产生的原因

1. 为实现TCP全双工连接的可靠释放由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前， client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2 MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常
2. 为使旧的数据包在网络因过期而消失为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。  
3. 具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2 MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况  

time_wait状态如何避免

首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。

在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。

### 1.14 为什么要设置time_wait？

1. 保证A发送的最后一个ACK报文能够到达B。因为这个ACK报文有可能丢失，B收不到这个对FIN+ACK报文的确认，所以B就会超时重传这个FIN+ACK报文段，这样A就能在2 MSL时间内收到重传的FIN+ACK，接着A再重传一次确认报文段，重新启动时间等待计时器
2. A在发送完最后一个ACK报文段后，经过2 MSL后，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失  

### 1.15 TCP的模型的状态转移  

![image-20230728145417189](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728145417189.png)

**服务端的状态转移**

服务端打开后处于listen，等待客户端的连接请求。当服务端接收到客户端发来的连接请求syn后，服务端进入synreceive状态，并回复syn和ack表示接受连接后，当服务端再次收到ack后。服务端认为连接已建立并进入establish状态。当服务端接收到fin=1后，表明客户端要关闭连接，这时服务端进入close_wait状态，此时，服务端不在接收数据，但是可以继续发送数据，当服务端数据发送完后，服务端会发送fin，并计入lask_ack状态，在lask_ack状态下，服务端收到客户端发来的fin和ack后，服务端关闭连接，处于close状态。

**客户端的状态转移**

客户端发送syn = 1 后，会处于synsned状态，当收到服务端发来的syn和ack后，客户端会返回一个确认发送ack，发完之后会进入establish状态。客户端发送fin=1主动关闭连接，会处于fin_wait_1状态。此状态下：1.服务端会回复一个ack表示服务端还能发送数据，此时客户端会进入fin_wait_2状态，表明等待服务端关闭连接。2.收到服务端发来的fin =1 ，此时客户端发送ack，进入closing状态。3.收到服务端发来额fin+ack，此时客户端会发送ack进入time_wait状态，等到2 MSL后，就会彻底关闭

### 1.16 典型网络模型，简单说说有哪些？

网络模型一般是指OSI七层参考模型和TCP/IP四层参考模型。

OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。

网络层：IP协议、ICMP协议、ARP协议、RARP协议。

传输层：UDP协议、TCP协议。

应用层：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议。

### 1.17 搜索Baidu，会用到计算机网络中的什么层？每层是干什么的?

**浏览器中输入URL浏览器要将URL解析为IP地址，解析域名就要用到DNS协议**，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。**DNS服务器是基于UDP的，因此会用到UDP协议**。

得**到IP地址后，浏览器就要与服务器建立一个http连接**。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。**当然在一个网段内的寻址是通过以太网协议实现**(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。

其中：

1. DNS协议，http协议，https协议属于应用层

   应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务

2. TCP/UDP属于传输层

   传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层

3. IP协议，ARP协议属于网络层

   网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机

4. 数据链路层

   当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错

5. 物理层

   物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层

## 2 HTTP/IP

### 2.1 什么是http协议？

HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW :World Wide Web）服务器传输超文本到本地浏览器的传送协议。

HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）

HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。

HTTP协议工作于客户端-服务端架构为上。

浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。

### 2.2 http协议有什么特点？

1. 简单快速客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
2. 灵活HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记
3. 无连接无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
4. 无状态HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快
5. 支持B/S及C/S模式。
6. 默认端口80
7. 基于TCP协议

2.3 https建立连接过程是什么?

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

HTTP协议采用了请求/响应模型。

客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。

服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

HTTP 请求/响应的步骤如下：

1. 客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.baidu.com
2. 发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成
3. 服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成
4. 释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求
5. 客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

### 2.3 http和https的区别是什么？https有什么优缺点？

**区别**

1. HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS(传输层安全协议)加密后的，HTTPS具有更高的安全性
2. HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥
3. HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书
4. HTTP协议端口是80，HTTPS协议端口是443

**HTTPS优点**

HTTPS传输数据过程中使用密钥进行加密，所以安全性更高

HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器

**HTTPS缺点**

HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加

HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高

### 2.4 http返回码

HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下： 

1xx：指示信息--表示请求已接收，继续处理。

2xx：成功--表示请求已被成功接收、理解、接受。

3xx：重定向--要完成请求必须进行更进一步的操作。

4xx：客户端错误--请求有语法错误或请求无法实现。

5xx：服务器端错误--服务器未能实现合法的请求。常见状态代码、状态描述的详细说明如下。

200 OK：客户端请求成功。

206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围

300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。

301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。

302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，

304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。

403 Forbidden：服务器收到请求，但是拒绝提供服务。t Found：请求资源不存在，举个例子：输入了错误的URL

### 2.5 http 1.1和http 1.0的区别？

HTTP 1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP 1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP 1.1也是当前使用最为广泛的HTTP协议。

主要区别主要体现在：

1. 缓存处理，在HTTP 1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP 1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-NoneMatch等更多可供选择的缓存头来控制缓存策略
2. 带宽优化及网络连接的使用，HTTP 1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP 1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接
3.  错误通知的管理，在HTTP 1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除
4. Host头处理，在HTTP 1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）
5. 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP 1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP 1.0每次请求都要创建连接的缺点。

### 2.6 请你说一下http协议会话结束标志怎么截出来？

看TCP连接是否有断开的四部挥手阶段。

### 2.7 请你说一说IP地址作用，以及MAC地址作用

MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

## 3 SOCKET

### 3.1 请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？

服务端：socket-bind-listen-accept

客户端：socket-connect

### 3.2 请你来说一下socket编程中服务器端和客户端主要用到哪些函数？

**基于TCP的socket** 

1. 服务器端程序

   （1）创建一个socket，用函数socket()

   （2）绑定IP地址、端口等信息到socket上，用函数bind()

   （3）设置允许的最大连接数，用函数listen()

   （4）接收客户端上来的连接，用函数accept()

   （5）收发数据，用函数send()和recv()，或者read()和write()

   （6）关闭网络连接

2. 客户端程序

   （1）创建一个socket，用函数socket()

   （2）设置要连接的对方的IP地址和端口等属性

   （3）连接服务器，用函数connect()

   （4）收发数据，用函数send()和recv()，或read()和write()

   （5）关闭网络连接

![image-20230728151943069](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728151943069.png)

**基于UDP的socket**

1. 服务器端流程

   （1）建立套接字文件描述符，使用函数socket()，生成套接字文件描述符

   （2）设置服务器地址和侦听端口，初始化要绑定的网络地址结构

   （3）绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定

   （4）接收客户端的数据，使用recvfrom()函数接收客户端的网络数据

   （5）向客户端发送数据，使用send to()函数向服务器主机发送数据

   （6）关闭套接字，使用close()函数释放资源。

2. 客户端流程

   （1）建立套接字文件描述符，socket()

   （2）设置服务器地址和端口，struct sockaddr

   （3）向服务器发送数据，send to()

   （4）接收服务器的数据，recvfrom()

   （5）关闭套接字，close()

   ![image-20230728154313069](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230728154313069.png)

### 3.3 请你讲述一下Socket编程的send() recv() accept() socket()函数？  

send函数将要发送的数据从用户空间拷贝到TCP关联的内核发送缓冲区

recv函数从TCP关联的内核接收缓冲区中取出数据到程序定义的缓冲区

accept函数从连接队列里边儿取出已经成完成三次握手的连接

socket函数返回一个用于网络通讯的文件描述符

## 4 客户端/服务端

### 4.1 URI（统一资源标识符）和URL（统一资源定位符）之间的区别

URL 统一资源定位符（Uniform Resource Locator），其实就是我们访问web页面时需要输入的”网页地址“”网址“，比如：https://www.google.com/ 就是URL。

完整定义如下

```
协议类型 : // 登录信息（认证） @ 服务器地址 : 端口号 / 带层次的文件路径 ? 查询字符串 # 片段标识符

htttp : // user:pass @ www.example.jp : 80 / dir/index.html ? uid=1 # ch  
```

URI 统一资源标识符（Uniform Resource Identifier），就是某个网络协议方案表示的资源的定位标识符，比如：https://www.google.com/ 

也同样可以说是，在https网络协议下的一个URI。

如果想要了解 URI统一资源标识符，那么我们必须理清它和 URL统一资源定位符 之间的关系。

第一，URL统一资源定位符 是一个具体的概念，而 URI统一资源标识符 是一个抽象的概念。

第二，URL统一资源定位符 是 URI统一资源标识符 的子集。

它是 URL，而 URL 属于 URI。：

```
htttp : // user:pass @ www.example.jp : 80 /dir/index.html ? uid=1#ch
```

它是 URI：

联系地址 : // 访客:央视记者 @ 央视 : 直播 / 中国/湖北/武汉/红十字会的仓库 ? 物品=捐款物资

### 4.2 为什么服务端易受到SYN攻击？

SYN- Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它就是利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。

这种攻击早在1996年就被发现，但至今仍然显示出强大的生命力。

它的数据包特征通常是，源发送了大量的SYN包，并且缺少三次握手的最后一步握手ACK回复。

原理：攻击者首先伪造地址对服务器发起SYN请求，服务器回应(SYN+ACK)包，而真实的IP会认为，我没有发送请求，不作回应。服务器没有收到回应，这样的话，服务器不知道(SYN+ACK)是否发送成功，默认情况下会重试5次。这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。

### 4.3 为什么客户端最后还要等待2 MSL？

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2 MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2 MSL计时器。

防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2 MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。建立连接的时候，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接

### 4.4 若server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？

这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态。

如果使用了epoll,select等这样的io复用情况下，处于运行状态。

### 4.5 GET和POST的区别

1. get参数通过url传递，post放在request body中
2.  get请求在url中传递的参数是有长度限制的，而post没有
3.  get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息
4.  get请求只能进行url编码，而post支持多种编码方式
5.  get请求会浏览器主动cache，而post支持多种编码方式
6.  get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留
7. GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制， 导致他们在应用过程中体现出一些不同
8. GET产生一个TCP数据包；POST产生两个TCP数据包

# STM32

## 1 STM32F1和F4的区别

​								内核不同：F1是Cortex-M3内核，F4是Cortex-M4内核；
​								主频不同：F1主频72 MHz，F4主频168 MHz；
​								浮点运算：F1无浮点运算单位，F4有；
​								功能性能：F4外设比F1丰富且功能更强大，比如GPIO翻转速率、上下拉电阻配置、ADC精度等；
​								内存大小：F1内部SRAM最大64 K，F4有192 K(112+64+16)

**STM32F103C8T6**
								内核：  ARM Cortex-M3
								主频：  72 MHz
								RAM： 20 K（SRAM）
								ROM： 64 K（Flash）
								供电：2.0~3.6 V（标准3.3 V）
								封装：LQFP48

## 2 STM32启动过程

				  通过Boot引脚设定,寻找初始地址
				  初始化栈指针 __initial_sp
				  指向复位程序 Reset_Hander
				  设置异常中断 HardFault_Handler
			      设置系统时钟 SystemInit
				  调用C库函数 _main

**启动配置**

![image-20230801161451882](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230801161451882.png)

系统存储区（SystemMemory）为ST公司出厂配置锁死，用户无法编辑，用于对FLASH区域进行重新编程

所以我们烧写程序务必选择BOOT1 = 0，这样通过内嵌的自举程序对FLASH进行烧写，比如中断向量表和代码

## 3 系统结构

![image-20230801161540529](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230801161540529.png)

主系统由以下部分构成：
								● 四个驱动单元：
								─ Cortex™-M3内核DCode总线(D-bus)，和系统总线(S-bus)
								─ 通用DMA1和通用DMA2
								● 四个被动单元
								─ 内部SRAM
								─ 内部闪存存储器
								─ FSMC
								─ AHB到APB的桥(AHB2APBx)，它连接所有的APB设备

总线						ICode总线(指令总线)：将Cortex™-M3内核的指令总线与闪存指令接口相连接。指令预取在此总线上完成;
								DCode总线：将Cortex™-M3内核的DCode总线与闪存存储器的数据接口相连接(常量加载和调试访问)。//这两个总线连接Flash(存储我们编写								的程序)
								System总线：连接Cortex™-M3内核的系统总线(外设总线)到总线矩阵，总线矩阵协调着内核和DMA间的访问

总线矩阵				(非互联网型产品)总线矩阵包含4个驱动部件(CPU的DCode总线、系统总线、 DMA1总线和DMA2总线)和4个被动部件(闪存存储器接口(FLITF)、 								SRAM、 FSMC和AHB2APB桥)。
								AHB系统总线挂载主要外设(复位和时钟控制RCC、SDIO)
								桥接1、2连接APB总线，APB2和AHB同频72 MHZ，APB1一般36 MHZ

​								总线矩阵采用轮换算法对系统总线和DMA进行仲裁

存储器组织
								程序存储器、数据存储器、寄存器和输入输出端口被组织在同一个4 GB的线性地址空间内。
								数据字节以小端格式存放在存储器中。
								可访问的存储器空间被分成8个主要块，每个块为512 MB。

FLASH

​								FLASH的一页为1 K(小容量和中容量)，大容量是2 K

## 4 复位和时钟控制

三种不同的**时钟源**可被用来驱动系统时钟(SYSCLK)：
								● HSI振荡器时钟(8 MHz)
								● HSE振荡器时钟
								● PLL时钟

**在使用一个外设之前，必须设置寄存器RCC_AHBENR来打开该外设的时钟**

STM32复位有三种：系统复位、上电复位、备份区域复位

单片机复位后所有I/O口均为浮空输入状态

## 5 GPIO

**通用输入输出端口**							

输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等

输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等

**GPIO构成**								

两个32位配置寄存器(GPIOx_CRL， GPIOx_CRH)，两个32位数据寄存器(GPIOx_IDR和GPIOx_ODR)，一个32位置位/复位寄存器(GPIOx_BSRR)，一个16位复位寄存器(GPIOx_BRR)和一个32位锁定寄存器(GPIOx_LCKR)。

STM32F103ZET6芯片为144脚芯片

7个通用目的的输入/输出口（GPIO）组，

分别为GPIOA、GPIOB、GPIOC、GPIOD、GPIOE、GPIOF、GPIOG，同时每组GPIO口组有16个GPIO口。

通常简略称为PAx、PBx、PCx、PDx、PEx、PFx、PGx，其中x为0-15。

**内部电路结构**		

保护二极管：IO引脚上下两边两个二极管用于防止引脚外部过高、过低的电压输入。当引脚电压高于VDD时，上方的二极管导通；

当引脚电压低于VSS时，下方的二极管导通，防止不正常电压引入芯片导致芯片烧毁

P-MOS管和N-MOS管：由P-MOS管和N-MOS管组成的单元电路使得GPIO具有“推挽输出”和“开漏输出”的模式。

TTL肖特基触发器：信号经过触发器后，模拟信号转化为0和1的数字信号

但是，当GPIO引脚作为ADC采集电压的输入通道时，用其“模拟输入”功能，此时信号不再经过触发器进行TTL电平转换。ADC外设要采集到的原始的模拟信号。

**GPIO 8种工作模式**：
								● GPIO_Mode_AIN 模拟输入
								● GPIO_Mode_IN_FLOATING 浮空输入
								● GPIO_Mode_IPD 下拉输入
								● GPIO_Mode_IPU 上拉输入
								● GPIO_Mode_Out_OD 开漏输出
								● GPIO_Mode_Out_PP 推挽输出
								● GPIO_Mode_AF_OD 复用开漏输出
								● GPIO_Mode_AF_PP 复用推挽输出

● GPIO_Mode_AIN 模拟输入						

模拟输入模式下，I/O端口的模拟信号（电压信号，而非电平信号）直接模拟输入到片上外设模块，比如ADC模块等等

![image-20230801162547043](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230801162547043.png)

● GPIO_Mode_IN_FLOATING 浮空输入					

浮空输入模式下，I/O端口的电平信号直接进入输入数据寄存器。

也就是说，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的

![image-20230801162616923](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230801162616923.png)

● GPIO_Mode_IPU 上拉输入

上拉输入模式下，I/O端口的电平信号直接进入输入数据寄存器。

但是在I/O端口悬空（在无信号输入）的情况下，输入端的电平可以保持在高电平；并且在I/O端口输入为低电平的时候，输入端的电平也还是低电平

![image-20230801162807645](C:\Users\mm611\AppData\Roaming\Typora\typora-user-images\image-20230801162807645.png)

●GPIO_Mode_IPD 下拉输入

- 下拉输入模式（下拉输入模式下，I/O端口的电平信号直接进入输入数据寄存器。

- 但是在I/O端口悬空（在无信号输入）的情况下，输入端的电平可以保持在低电平；并且在I/O端口输入为高电平的时候，输入端的电平也还是高电平。）

![图片](https://mmbiz.qpic.cn/mmbiz_png/K9mVOHgVt7zqsQX649KM4qKPhVSD5mJNeEX0P9dN5ukuMOE1SR71TjAqtESQqIgdW0paD7VPHbXfDOGLmrAGicg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

● GPIO_Mode_Out_OD 开漏输出

​	开漏输出模式下，通过设置位设置/清除寄存器或者输出数据寄存器的值，途经N-MOS管，最终输出到I/O端口。

​	这里要注意N-MOS管，当设置输出的值为高电平的时候，N-MOS管处于关闭状态，此时I/O端口的电平就不会由输出的高低电平决定，而是由I/O端口外部的上拉或者下拉决定；

​	当设置输出的值为低电平的时候，N-MOS管处于开启状态，此时I/O端口的电平就是低电平。同时，I/O端口的电平也可以通过输入电路进行读取；

​	注意，I/O端口的电平不一定是输出的电平

![图片](https://mmbiz.qpic.cn/mmbiz_png/K9mVOHgVt7zqsQX649KM4qKPhVSD5mJNguJibJqKNyOBWjyyO0iceW3sXdlWl8r8pFqOhzaSTw5nVWmxzNQY7nhA/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

● GPIO_Mode_Out_PP 推挽输出

​	推挽输出模式下，通过设置位设置/清除寄存器或者输出数据寄存器的值，途经P-MOS管和N-MOS管，最终输出到I/O端口。

​	这里要注意P-MOS管和N-MOS管，当设置输出的值为高电平的时候，P-MOS管处于开启状态，N-MOS管处于关闭状态，此时I/O端口的电平就由P-MOS管决定：高电平；

​	当设置输出的值为低电平的时候，P-MOS管处于关闭状态，N-MOS管处于开启状态，此时I/O端口的电平就由N-MOS管决定：低电平。

​	同时，I/O端口的电平也可以通过输入电路进行读取；

​	注意，此时I/O端口的电平一定是输出的电平

![图片](https://mmbiz.qpic.cn/mmbiz_png/K9mVOHgVt7zqsQX649KM4qKPhVSD5mJNmv1ia6ACG4pzODNW4w8LZia4MIicak1L6ibLN3F3xCD7yZWolqh3k7S7tA/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

● GPIO_Mode_AF_OD 复用开漏输出

开漏复用输出模式，与开漏输出模式很是类似。

只是输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的。

![图片](https://mmbiz.qpic.cn/mmbiz_png/K9mVOHgVt7zqsQX649KM4qKPhVSD5mJNtsvbjqOwDmhdnFkmLqwhFjewNMGyTZ8iak47VuR9MvJHog11m9MbAwg/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

● GPIO_Mode_AF_PP 复用推挽输出

​	推挽复用输出模式，与推挽输出模式很是类似。

​	只是输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的	

![图片](https://mmbiz.qpic.cn/mmbiz_png/K9mVOHgVt7xnHG8FXVUicxxcnrQia24sRIibEK8AichoTnASc8uzCkUaAzfvWQ12LeMy7JFTgmiaydf77BfIsvicZoNQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

**什么是推挽结构和推挽电路？**

​	推挽结构一般是指两个参数相同的三极管或MOS管分别受两互补信号的控制，总是在一个三极管或MOS管导通的时候另一个截止。

​	高低电平由输出电平决定。

​	推挽电路是两个参数相同的三极管或MOSFET，以推挽方式存在于电路中，各负责正负半周的波形放大任务。

​	电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。

​	推拉式输出级既提高电路的负载能力，又提高开关速度。

**开漏输出和推挽输出的区别？**

​	开漏输出：只可以输出强低电平，高电平得靠外部电阻拉高。

​	输出端相当于三极管的集电极。适合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)；

- 推挽输出:可以输出强高、低电平，连接数字器件。

## 6 嵌套向量中断控制器 NVIC 

**68**个**可屏蔽中断通道**，**16个可编程优先级**，**16个内核中断，一共68+16=84个中断**。

103系列只有60个中断，107系列才有68个中断

**中断嵌套**：

当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回


四、UART



问题一：串行通信方式介绍？
同步通信：I2C 半双工，SPI 全双工异步通信：RS485 半双工、RS232 全双工

问题二：串口配置？
串口设置的一般步骤可以总结为如下几个步骤：（1）串口时钟使能，GPIO时钟使能（2）串口复位（3）GPIO端口模式设置TX的GPIO工作模式为：GPIO_Mode_AF_PP;//复用推挽输出RX的GPIO工作模式为：GPIO_Mode_IN_FLOATING;//浮空输入（4）串口参数初始化主要包含：波特率设置（115200）、8个数据位、1个停止位、无奇偶校验位、无硬件数据流控制、收发模式。（5）开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）（6）使能串口（7）编写中断处理函数

问题三：USART主要特点？
（1）全双工操作（相互独立的接收数据和发送数据）；（2）同步操作时，可主机时钟同步，也可从机时钟同步；（3）独立的高精度波特率发生器，不占用定时/计数器；（4）支持5、6、7、8和9位数据位，1或2位停止位的串行数据桢结构；（5）由硬件支持的奇偶校验位发生和检验；（6）数据溢出检测；（7）帧错误检测；（8）包括错误起始位的检测噪声滤波器和数字低通滤波器；（9）三个完全独立的中断，TX发送完成、TX发送数据寄存器空、RX接收完成；（10）支持多机通信模式；（11）支持倍速异步通信模式。

解答：
参看：STM32开发 – 串口详解
应用场景：GPS、蓝牙、4G模块




五、I2C



问题一：I2C 总线在传送数据过程中共有三种类型信号？
（1）开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。（2）结束信号：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。（3）应答信号：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的低电平脉冲，表示已收到数据。CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障。

问题二：I2C配置主机模式端口该怎么配置？
硬件模式：复用开漏输出、既不上拉也不下拉。（快速模式：400 Kbit/s）软件模拟：推挽输出、配置上拉电阻。

问题三：I2C仲裁机制？
参看：S5PV210开发 – I2C 你知道多少？（三）
I2C 仲裁机制，理解了 线“与”（Wired-AND），就一目了然了。简单说，它遵循“低电平优先”的原则，即谁先发送低电平谁就会掌握对总线的控制权。

解答：
参看：STM32开发 – PMIC、I2C详解
硬件模式： 是有通信速率设置的
/* STM32 I2C 快速模式 */
#define I2C_Speed 400000

/* 通信速率 */

I2C_InitStructure.I2C_ClockSpeed = I2C_Speed;

软件模拟： 没有设置通信速率，该怎么计算呢？
通过I2C总线位延迟函数 i2c_Delay：

static void i2c_Delay(void)
{
	uint8_t i;

	/*　
	 	下面的时间是通过安富莱AX-Pro逻辑分析仪测试得到的。
		CPU主频72MHz时，在内部Flash运行, MDK工程不优化
		循环次数为10时，SCL频率 = 205KHz 
		循环次数为7时，SCL频率 = 347KHz， SCL高电平时间1.5us，SCL低电平时间2.87us 
	 	循环次数为5时，SCL频率 = 421KHz， SCL高电平时间1.25us，SCL低电平时间2.375us 
	    
	IAR工程编译效率高，不能设置为7
	*/
	for (i = 0; i < 10; i++);
}
应用场景：PMIC、加速度计、陀螺仪




六、SPI



问题一：SPI需要几根线？
SPI 接口一般使用 4 条线通信：MISO 主设备数据输入，从设备数据输出。MOSI 主设备数据输出，从设备数据输入。SCLK 时钟信号，由主设备产生。CS 从设备片选信号，由主设备控制。

问题二：SPI通信的四种模式？
SPI 有四种工作模式，各个工作模式的不同在于 SCLK 不同, 具体工作由 CPOL，CPHA 决定。（1）CPOL: (Clock Polarity)，时钟极性：
SPI的CPOL，表示当SCLK空闲idle的时候，其电平的值是低电平0还是高电平1：CPOL=0，时钟空闲idle时候的电平是低电平，所以当SCLK有效的时候，就是高电平，就是所谓的active-high；CPOL=1，时钟空闲idle时候的电平是高电平，所以当SCLK有效的时候，就是低电平，就是所谓的active-low；

图片



（2）CPHA:(Clock Phase)，时钟相位：
相位，对应着数据采样是在第几个边沿（edge），是第一个边沿还是第二个边沿，
0对应着第一个边沿，1对应着第二个边沿。对于：
CPHA=0，表示第一个边沿：
对于CPOL=0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿；
对于CPOL=1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿；
CPHA=1，表示第二个边沿：
对于CPOL=0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿；
对于CPOL=1，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿；

图片



问题三：该如何确定使用哪种模式？
（1）先确认从机需求的 SCLK 极性，不工作时是在低电位还是高电位，由此确认 CPOL 为 0 或 1。看原理图，我们设置串行同步时钟的空闲状态为高电平所以我们选择 SPI_CPOL_High。也就是CPOL为1
（2）再由slave芯片 datasheet 中的时序图确认 slave 芯片是在 SCLK 的下降沿采集数据，还是在SCLK的上升沿。翻译一下：W25Q32JV通过SPI兼容总线访问，包括四个信号:串行时钟(CLK)，芯片选择(/CS)，串行数据输入(DI)和串行数据输出(DO)。标准SPI指令使用DI输入引脚串行地将指令、地址或数据写入CLK上升沿上的设备。DO输出引脚用于从CLK下降沿上的设备读取数据或状态。支持模式0(0,0)和3(1,1)的SPI总线操作。模式0和模式3关注的是当SPI总线主端处于待机状态，数据没有被传输到串行Flash时CLK信号的正常状态。对于模式0，在下降和上升时，CLK信号通常是低的边缘/ CS。对于模式3，在/CS的下降和上升边缘上CLK信号通常是高的。既然串行同步时钟的空闲状态为高电平，这里我们选择第二个跳变沿，所以选择 SPI_CPHA_2Edge。也就是CPHA为1
即，我们选择的是模式3(1,1)。

图片



解答：
参看：STM32开发 – W25Q32JV SPI FlASH详解
参看：详解SPI中的极性CPOL和相位CPHA
应用场景：SPI Flash，W25Q32 存储器容量 32Mb (4M x 8)，即4M byte





七、CAN



问题一：CAN总结介绍一下？
CAN控制器根据 CAN_L 和 CAN_H上 的电位差来判断总线电平。总线电平分为显性电平和隐性电平，二者比居其一。发送方通过使总线电平发生变化，将消息发送给接收方。

问题二：CAN初始化配置步骤?
（1）配置相关引脚的复用功能，使能CAN时钟（2）设置CAN工作模式及波特率等（CAN初始化环回模式,波特率500Kbps ）（3）设置滤波器

问题三：CAN发送数据格式?
CanTxMsg TxMessage;TxMessage.StdId=0x12; // 标准标识符TxMessage.ExtId=0x12; // 设置扩展标示符TxMessage.IDE=CAN_Id_Standard; // 标准帧TxMessage.RTR=CAN_RTR_Data; // 数据帧TxMessage.DLC=len; // 要发送的数据长度 发送8个字节for(i=0;i<len;i++)TxMessage.Data[i]=msg[i]; //数据

解答：
参看：STM32开发 – CAN总线详解




八、DMA



问题一：DMA介绍？
直接存储器存取(DMA) 用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。无须CPU干预，数据可以通过DMA快速地移动，这就节省了CPU的资源来做其他操作。

问题一：DMA传输模式有几种？
DMA_Mode_Circular 循环模式DMA_Mode_Normal 正常缓存模式应用场景：GPS、蓝牙，都是用的循环采集，DMA_Mode_Circular模式。

解答：
参看：STM32开发 – DMA详解

一个比较重要的函数，获取当前剩余数据量大小，根据设置的接收buff大小减去当前剩余数据量 ，得到当前接收数据大小。




九、中断



问题一：描述一下中断的处理流程？
（1）初始化中断，设置触发方式是上升沿/下降沿/双沿触发。（2）触发中断，进入中断服务函数

问题二：STM32的中断控制器支持多少个外部中断？
STM32的中断控制器支持19个外部中断/事件请求：
从图上来看，GPIO 的管脚 GPIOx.0~GPIOx.15(x=A，B，C，D，E，F，G)分别对应中断线 0 ~ 15。另外四个EXTI线的连接方式如下：● EXTI线16连接到PVD输出● EXTI线17连接到RTC闹钟事件● EXTI线18连接到USB唤醒事件● EXTI线19连接到以太网唤醒事件(只适用于互联型产品)中断服务函数列表：
IO口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数。EXTI0_IRQHandlerEXTI1_IRQHandlerEXTI2_IRQHandlerEXTI3_IRQHandlerEXTI4_IRQHandlerEXTI9_5_IRQHandlerEXTI15_10_IRQHandler

解答：
参看：STM32开发 – 外部中断详解




十、STM32有几个时钟源？



STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。　④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。⑤、PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。
解答：
参看：STM32开发 – 时钟系统详解





十一、RTOS的任务是怎么写的？如何切出这个任务？



解答：
一个任务，也称作一个线程。
UCOS有一个任务调度机制，根据任务的优先级进行调度。
一个是硬件中断， 那么系统会将当前任务有关变量入栈，然后执行中断服务程序，执行完成后出栈返回.
另一个是任务之间的切换，使用的方法就是任务调度，每一个任务有自己的栈，顺度也是一样的入栈，然后执行另一个程序，然后出线返回。

并非是每一任务按优先级顺序轮流执行的，而是高优先级的任务独占运行，除非其主动放弃执行，否则低优先级任务不能抢占，同时高优先级可以把放出去给低优先级任务使用的CPU占用权抢回来。所以ucos的任务间要注意插入等待延时，以便ucos切出去让低优先级任务执行。




十二、UCOSII中任务间的通信方式有哪几种？



解答：
在UCOSII中，是使用信号量、邮箱（消息邮箱）和消息队列这些被称作事件的中间环节来实现任务间的通信的，还有全局变量。
信号量：
参看：ucosII 信号量使用总结(举例讲解)
信号量用于：
1.控制共享资源的使用权（满足互斥条件）
2.标志某时间的发生
3.使2个任务的行为同步

应用实例：互斥信号量
作为互斥条件，信号量初始化为1。
实现目标：调用串口发送命令，必须等待返回“OK”字符过后，才能发送下一条命令。每个任务都有可能使用到此发送函数，不能出现冲突！

邮箱（消息邮箱）：

消息队列：
概念：
（1）消息队列实际上就是邮箱阵列。
（2）任务和中断都可以将一则消息放入队列中，任务可以从消息队列中获取消息。
（3）先进入队列的消息先传给任务(FIFO)。
（4）每个消息队列有一张等待消息任务的等待列表，如果消息列中没有消息，则等待消息的任务就被挂起，直到消息到来。

应用场景：
串口接收程序中的接收缓冲区。
储存外部事件。




十三、项目使用了自定义协议，是什么结构？



解答：
了解过Modbus协议。
结构为：帧头（SDTC）+帧长度+指令+流水号+数据+CRC校验。




十四、uCOSII和Linux的差异？



解答：
μC/OS-II是专门为计算机的嵌入式应用设计的，μC/OS-II 具有执行效率高、占用空间小、实时性能优良和可扩展性强等特点， 最小内核可编译至 2KB 。μC/OS-II 已经移植到了几乎所有知名的CPU 上。
linux 免费，安全，稳定，应用范围广，在嵌入式上，服务器上，家用机，都有广泛应用。
μC/OS-II Linux 都适合用在嵌入式上。但μC/OS-II 是专为嵌入式而设计，这样的结果是，运行效率更高，占用资源更少。
linux 都可以用作服务器上，使用率高。linux 虽然不是专门针对服务器而开发，但其源码公开，完全可以修改，使得两者差异不大，最主要的发行版redhat linux 就是在服务器上用得很多的系统。




十五、Git提交代码



问题：Git提交代码过程？
解答：
1、显示工作路径下已修改的文件：

$ git status
2、进入修改文件目录：

$cd -
3、显示与上次提交版本文件的不同：

$ git diff
4、把当前所有修改添加到下次提交中：

$ git add .
5、添加相关功能说明，（第一次提交使用这个）

$ git commit -s
其中还要注明:
Fuction: 修改代码的功能
Ticket: 对应Bug号
注意：每一个文件夹下都要重新提一次。
6、查看提交代码

$ tig .
7、请勿修改已发布的提交记录! （以后提交使用这个）

$git commit --amend
命令模式下：
：x ( 写入文件并退出)
8、推送到服务器

$ git push origin HEAD:refs/for/master



十六、ucosii和ucosiii和freeRTOS比较



问题一：三者比较？

解答：
ucosii和freeRTOS比较：
（1）freeRTOS只支持TCP/IP， uCOSii则有大量外延支持，比如FS， USB， GUI， CAN等的支持。（我们用于tbox要用到CAN，所以选择uCOSii）
（2）freeRTOS 是在商业上免费应用。uCOSii在商业上的应用是要付钱的。
（3）任务间通讯freeRTOS只支持队列， 信号量， 互斥量。uCOSii除这些外，还支持事件标志组，邮箱。
（4）理论上讲，freeRTOS 可以管理超过64个任务，而uCOSii只能管理64个。

ucosii和ucosiii比较：
那么从μC/OS-II到μC/OS-III有哪些不同的地方呢？增加了什么，我们看改动还是很大的。一个是原来只有0~63个优先级，而且优先级不能重复，现在允许几个任务使用同一个优先级，在同一个优先级里面，支持时间片调度法；第二个是允许用户在程序运行中动态配置实时操作系统内核资源，比如，任务、任务栈、信号量、事件标志组、消息队列、消息数、互斥型信号量、存储块划分和定时器，可以在程序运行中变更。这样，用户可以避免在程序编译过程中出现资源不够分配的问题。在资源复用上，也做了一些改进。μC/OS-II中，最多任务数有64个，到了版本2.82以后是256个，μC/OS-III中，用户可以由任意多的任务、任意多的信号量、互斥型信号量、事件标志、消息列表、定时器和任意分配的存储块容量，仅受限于用户CPU可以使用的RAM量。这个也是一个很大的扩展。（问：邵老师，它的这个数是启动时就固定的，还是启动后随便定？）它是配置的时候可以自由定义的，只有你的RAM足够大的话。第四点是增加了很多功能，功能总是越来越多的，大伙可以看一下的。原来这些功能在μC/OS-II里面是没有的。




十七、低功耗模式



问题一：低功耗模式有几种？唤醒方式是什么？

解答：
图片




十八、物联网的架构



问题一：物联网的架构分为几层?每一层都负责哪些功能？

解答：
分三层，物联网从架构上面可以分为感知层、网络层和应用层，
（1）感知层： 负责信息采集和物物之间的信息传输，信息采集的技术包括传感器、条码和二维码、 RFID射频技术、音视频等多媒体信息，信息传输包括远近距离数据传输技术、自组织组网技术、协同信息处理技术、信息采集中间件技术等传感器网络。感知层是实现物联网全面感知的核心能力，是物联网中包括关键技术、标准化方面、产业化方面亟待突破的部分，关键在于具备更精确、更全面的感知能力，并解决低功耗、小型化和低成本的问题。
（2）网络层： 是利用无线和有线网络对采集的数据进行编码、认证和传输，广泛覆盖的移动通信网络是实现物联网的基础设施，是物联网三层中标准化程度昀高、产业化能力昀强、昀成熟的部分，关键在于为物联网应用特征进行优化和改进，形成协同感知的网络。
（3）应用层： 提供丰富的基于物联网的应用，是物联网发展的根本目标，将物联网技术与行业信息化需求相结合，实现广泛智能化应用的解决方案集，关键在于行业融合、信息资源的开发利用、低成本高质量的解决方案、信息安全的保障以及有效的商业模式的开发。




十九、内存管理



问题一：UCOS中内存管理的方法有哪些？

解答：
系统通过与内存分区相关联的内存控制块来对内存分区进行管理。

动态内存管理函数有：
创建动态内存分区函数OSMemCreate();
请求获得内存块函数OSMemGet();
释放内存块函数OSMemPut();




二十、Ucos中任务的状态有哪几种？画出任务状态之间的关系图？



解答：
有5种状态：
睡眠状态、就绪状态、运行状态、等待状态（等待某一事件发生）和中断服务状态。

UCOSII任务的5个状态转换关系：

图片




二十一、ADC



问题一：简述STM32的ADC系统的功能特性？
（1）12bit分辨率（2）自动校准（3）可编程数据对齐（转换结果支持左对齐或右对齐方式存储在16位数据寄存器）（4）单次和连续转换模式

参看：STM32开发 – ADC详解




二十二、系统时钟



问题一：简述设置系统时钟的基本流程？
（1）打开HSE,等待就绪后,设置Flash等待操作。（2）设置AHB,APB1,APB2分频系数,确定他们各自和系统时钟的关系。（3）设置CFGR寄存器确定PLL的时钟来源和倍频系数(HSE外部8M*9倍=72MHz)。（4）使能PLL,将系统时钟源切换到PLL.




二十三、HardFault_Handler处理



问题一：造成原因？
(1)数组越界操作；(2)内存溢出，访问越界；(3)堆栈溢出，程序跑飞；(4)中断处理错误；

问题二：处理方式？
（1）在startup_stm32f10x_cl.s里找到HardFault_Handler的地址重映射，并重新编写，让其跳转到HardFaultHandle函数。
（2）打印查看R0、R1、R2、R3、R12、LR、PC、PSR寄存器。（3） 查看Fault状态寄存器组（SCB->CFSR和SCB->HFSR）

参看：STM32开发 – HardFault_Handler处理
参看：Cortex-M3和Cortex-M4 Fault异常应用之一 ----- 基础知识




二十四、TTS语音合成方法



问题一：sim7600 TTS语音使用什么方法？

解答：
（1）使用unicode编码合成声音
AT+CTTS=1,”
6B228FCE4F7F75288BED97F3540862107CFB7EDF”
内容是“欢迎使用语音合成系统”，模块收发中文短信就是unicode编码，所以很容易将短信朗读出来；
（2）直接输入文本，普通字符采用ASIIC码，汉字采用GBK编码。
AT+CTTS=2,”欢迎使用语音合成系统”




二十五、定时器



问题一：已知STM32的系统时钟为72MHz，如何设置相关寄存器，实现20ms定时？

解答：
参看：STM32开发 – Systick定时器
通过SysTick_Config(SystemCoreClock / OS_TICKS_PER_SEC))//1ms定时器

其中：

uint32_t SystemCoreClock         = SYSCLK_FREQ_72MHz;        /*!< System Clock Frequency (Core Clock) */
#define SYSCLK_FREQ_72MHz  72000000
#define OS_TICKS_PER_SEC       1000    /* Set the number of ticks in one second
如果需要20ms则，可以通一设置一个全局变量，然后定初值得为20，这样，每个systick中断一次，这个全局变量减1，减到0,即systick中断20次，时间为：1ms*20=20ms。从而实现20ms的定时。




二十六、优先级



问题一：如果是两个优先级相同的任务怎么运行？

解答：
使获得信号量任务的优先级在使用共享资源期间暂时提升到所有任务最高优先级的高一个级别上，以使该任务不被其他任务所打断，从而能尽快地使用完共享资源并释放信号量，然后在释放信号量之后，再恢复该任务原来的优先级别。




二十七、状态机



问题一：使用的什么状态机？

解答：
参看：STM32开发 – 状态机与状态切换逻辑

有限状态机，（英语：Finite-state machine, FSM），又称有限状态自动机，简称状态机。
参看：有限状态机FSM详解及其实现

假设状态机的状态转换由下表所示：

图片



实现：（使用switch语句）

//横着写
void event0func(void)
{
    switch(cur_state)
    {
        case State0:
             action0;
             cur_state = State1;
        break;
         case State1:
             action1;
             cur_state = State2;
        break;
         case State2:
             action1;
             cur_state = State0;
        break;
        default:break;
    }
}

void event1func(void)
{
    switch(cur_state)
    {
        case State0:
             action4;
             cur_state = State1;
        break;
        default:break;
    }
}

void event2func(void)
{
    switch(cur_state)
    {
        case State0:
             action5;
             cur_state = State2;
        break;
         case State1:
             action6;
             cur_state = State0;
        break;
        default:break;
    }
}

# FreeRTOS

## 1 FreeRTOS概述与体验

1.1 FreeRTOS目录结构

以Keil工具下STM32F103芯片为例，它的FreeRTOS的目录如下:

![img](https://pic3.zhimg.com/80/v2-d2e76981f3b8286d3895c03621eb8962_720w.webp)



主要涉及2个目录：



- Demo

- - Demo目录下是工程文件，以"芯片和编译器"组合成一个名字
  - 比如：CORTEX_STM32F103_Keil



- Source

- - 根目录下是核心文件，这些文件是通用的

  - portable目录下是移植时需要实现的文件

  - - 目录名为：[compiler]/[architecture]
    - 比如：RVDS/ARM_CM3，这表示cortexM3架构在RVDS工具上的移植文件



### 1.2 核心文件

FreeRTOS的最核心文件只有2个：



- FreeRTOS/Source/tasks.c
- FreeRTOS/Source/list.c



其他文件的作用也一起列表如下：

![img](https://pic4.zhimg.com/80/v2-492a5bd138926fc2d9052420f275561f_720w.webp)

### 1.3 移植时涉及的文件

移植FreeRTOS时涉及的文件放在`FreeRTOS/Source/portable/[compiler]/[architecture]`目录下，

比如：RVDS/ARM_CM3，这表示cortexM3架构在RVDS或Keil工具上的移植文件。

里面有2个文件：

- port.c
- portmacro.h



### 1.4 头文件相关

#### 1.4.1 头文件目录

FreeRTOS需要3个头文件目录：



- FreeRTOS本身的头文件：FreeRTOS/Source/include
- 移植时用到的头文件：FreeRTOS/Source/portable/[compiler]/[architecture]
- 含有配置文件FreeRTOSConfig.h的目录



#### 1.4.2 头文件

列表如下：

![img](https://pic2.zhimg.com/80/v2-c831f37d851f37fe61b15438d6abb161_720w.webp)

### 1.5 内存管理

文件在`FreeRTOS/Source/portable/MemMang`下，它也是放在`portable`目录下，表示你可以提供自己的函数。

源码中默认提供了5个文件，对应内存管理的5种方法。

参考文章：[FreeRTOS说明书吐血整理【适合新手+入门】](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_43212092/article/details/104845158)

后续章节会详细讲解。

![img](https://pic3.zhimg.com/80/v2-1c52dadc0cf0518e89292d3650946116_720w.webp)

### 1.6 Demo

Demo目录下是预先配置好的、没有编译错误的工程。目的是让你可以基于它进行修改，以适配你的单板。

这些Demo还可以继续精简：



- `Demo/Common`中的文件可以完全删除

- main函数中只需要保留2个函数：

- - prvSetupHardware()
  - vTaskStartScheduler()
  - 如下图所示

![img](https://pic2.zhimg.com/80/v2-ef5efb1a0a1958fe81b76fcb978125e9_720w.webp)



### 1.7 数据类型和编程规范

#### 1.7.1 数据类型

每个移植的版本都含有自己的`portmacro.h`头文件，里面定义了2个数据类型：



- TickType_t：

- - FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt
  - 每发生一次中断，中断次数累加，这被称为tick count
  - tick count这个变量的类型就是TickType_t
  - TickType_t可以是16位的，也可以是32位的
  - FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t
  - 否则TickType_t就是uint32_t
  - 对于32位架构，建议把TickType_t配置为uint32_t



- BaseType_t：

- - 这是该架构最高效的数据类型
  - 32位架构中，它就是uint32_t
  - 16位架构中，它就是uint16_t
  - 8位架构中，它就是uint8_t
  - BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如`pdTRUE/pdFALSE`



#### 1.7.2 变量名

变量名有前缀：

![img](https://pic3.zhimg.com/80/v2-23e710c6cf9bc68ac0587734e1d2ac1a_720w.webp)

#### 1.7.3 函数名

函数名的前缀有2部分：返回值类型、在哪个文件定义。

![img](https://pic3.zhimg.com/80/v2-3faa58d37f47e337589164cfaf60afbe_720w.webp)

#### 1.7.4 宏的名

宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在哪个文件中定义。

![img](https://pic1.zhimg.com/80/v2-cc38b7b05447e29eae1ff192eab3076c_720w.webp)

通用的宏定义如下：

![img](https://pic1.zhimg.com/80/v2-4a113f76cdfa564e74c6512b04750ba0_720w.webp)

## 2 内存管理

### 2.1 为什么要自己实现内存管理

后续的章节涉及这些内核对象：task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。

内存的动态管理是C程序的知识范畴，并不属于FreeRTOS的知识范畴，但是它跟FreeRTOS关系是如此紧密，所以我们先讲解它。

在C语言的库函数中，有mallc、free等函数，但是在FreeRTOS中，它们不适用：



- 不适合用在资源紧缺的嵌入式系统中
- 这些函数的实现过于复杂、占据的代码空间太大
- 并非线程安全的(thread-safe)
- 运行有不确定性：每次调用这些函数时花费的时间可能都不相同
- 内存碎片化
- 使用不同的编译器时，需要进行复杂的配置
- 有时候难以调试



注意：我们经常"堆栈"混合着说，其实它们不是同一个东西：



- 堆，heap，就是一块空闲的内存，需要提供管理函数

- - malloc：从堆里划出一块空间给程序使用
  - free：用完后，再把它标记为"空闲"的，可以再次使用



- 栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中

- - 可以从堆中分配一块空间用作栈







![img](https://pic1.zhimg.com/80/v2-49e32f7168e6348d6fff047d694c9bd4_720w.webp)



### 2.2 FreeRTOS的5种内存管理方法

FreeRTOS中内存管理的接口函数为：pvPortMalloc 、vPortFree，对应于C库的malloc、free。

文件在`FreeRTOS/Source/portable/MemMang`下，它也是放在`portable`目录下，表示你可以提供自己的函数。

源码中默认提供了5个文件，对应内存管理的5种方法。

参考文章：[FreeRTOS说明书吐血整理【适合新手+入门】](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_43212092/article/details/104845158)

![img](https://pic4.zhimg.com/80/v2-b51da16d0dda0600cac4ad5f1236cd67_720w.webp)

#### 2.2.1 Heap_1

它只实现了pvPortMalloc，没有实现vPortFree。

如果你的程序不需要删除内核对象，那么可以使用heap_1：



- 实现最简单
- 没有碎片问题
- 一些要求非常严格的系统里，不允许使用动态内存，就可以使用heap_1



它的实现原理很简单，首先定义一个大数组：

```text
/* Allocate the memory for the heap. */
#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )

/* The application writer has already defined the array used for the RTOS
* heap - probably so it can be placed in a special segment or address. */
    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#else
    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#endif /* configAPPLICATION_ALLOCATED_HEAP */
```

然后，对于pvPortMalloc调用时，从这个数组中分配空间。

FreeRTOS在创建任务时，需要2个内核对象：task control block(TCB)、stack。

使用heap_1时，内存分配过程如下图所示：



- A：创建任务之前整个数组都是空闲的
- B：创建第1个任务之后，蓝色区域被分配出去了
- C：创建3个任务之后的数组使用情况





![img](https://pic3.zhimg.com/80/v2-64b00a2826c8fd3829e5081173f31b26_720w.webp)



#### 2.2.2 Heap_2

Heap_2之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用Heap_2。建议使用Heap_4来替代Heap_2，更加高效。

Heap_2也是在数组上分配内存，跟Heap_1不一样的地方在于：



- Heap_2使用**最佳匹配算法**(best fit)来分配内存
- 它支持vPortFree



最佳匹配算法：



- 假设heap有3块空闲内存：5字节、25字节、100字节

- pvPortMalloc想申请20字节

- 找出最小的、能满足pvPortMalloc的内存：25字节

- 把它划分为20字节、5字节

- - 返回这20字节的地址
  - 剩下的5字节仍然是空闲状态，留给后续的pvPortMalloc使用





与Heap_4相比，Heap_2不会合并相邻的空闲内存，所以Heap_2会导致严重的"碎片化"问题。

但是，如果申请、分配内存时大小总是相同的，这类场景下Heap_2没有碎片化的问题。所以它适合这种场景：频繁地创建、删除任务，但是任务的栈大小都是相同的(创建任务时，需要分配TCB和栈，TCB总是一样的)。

虽然不再推荐使用heap_2，但是它的效率还是远高于malloc、free。

使用heap_2时，内存分配过程如下图所示：



- A：创建了3个任务
- B：删除了一个任务，空闲内存有3部分：顶层的、被删除任务的TCB空间、被删除任务的Stack空间
- C：创建了一个新任务，因为TCB、栈大小跟前面被删除任务的TCB、栈大小一致，所以刚好分配到原来的内存





![img](https://pic2.zhimg.com/80/v2-b289311eff9f31f7bfd7e1e6b85caa75_720w.webp)



#### 2.2.3 Heap_3

Heap_3使用标准C库里的malloc、free函数，所以堆大小由链接器的配置决定，配置项configTOTAL_HEAP_SIZE不再起作用。

C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。

#### 2.2.4 Heap_4

跟Heap_1、Heap_2一样，Heap_4也是使用大数组来分配内存。

Heap_4使用**首次适应算法**(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。

首次适应算法：



- 假设堆中有3块空闲内存：5字节、200字节、100字节

- pvPortMalloc想申请20字节

- 找出第1个能满足pvPortMalloc的内存：200字节

- 把它划分为20字节、180字节

- - 返回这20字节的地址
  - 剩下的180字节仍然是空闲状态，留给后续的pvPortMalloc使用





Heap_4会把相邻空闲内存合并为一个大的空闲内存，可以较少内存的碎片化问题。适用于这种场景：频繁地分配、释放不同大小的内存。

Heap_4的使用过程举例如下：



- A：创建了3个任务

- B：删除了一个任务，空闲内存有2部分：

- - 顶层的
  - 被删除任务的TCB空间、被删除任务的Stack空间合并起来的



- C：分配了一个Queue，从第1个空闲块中分配空间
- D：分配了一个User数据，从Queue之后的空闲块中分配
- E：释放的Queue，User前后都有一块空闲内存
- F：释放了User数据，User前后的内存、User本身占据的内存，合并为一个大的空闲内存





![img](https://pic2.zhimg.com/80/v2-b289311eff9f31f7bfd7e1e6b85caa75_720w.webp)



Heap_4执行的时间是不确定的，但是它的效率高于标准库的malloc、free。

#### 2.2.5 Heap_5

Heap_5分配内存、释放内存的算法跟Heap_4是一样的。

相比于Heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。

在嵌入式系统中，内存的地址可能并不连续，这种场景下可以使用Heap_5。

既然内存是分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大：



- 在使用pvPortMalloc之前，必须先指定内存块的信息
- 使用vPortDefineHeapRegions来指定这些信息



怎么指定一块内存？使用如下结构体：

```text
typedef struct HeapRegion
{
    uint8_t * pucStartAddress; // 起始地址
    size_t xSizeInBytes;       // 大小
} HeapRegion_t;
```

怎么指定多块内存？使用一个HeapRegion_t数组，在这个数组中，低地址在前、高地址在后。

比如：

```text
HeapRegion_t xHeapRegions[] =
{
  { ( uint8_t * ) 0x80000000UL, 0x10000 }, // 起始地址0x80000000，大小0x10000
  { ( uint8_t * ) 0x90000000UL, 0xa0000 }, // 起始地址0x90000000，大小0xa0000
  { NULL, 0 } // 表示数组结束
 };
```

vPortDefineHeapRegions函数原型如下：

```text
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );
```

把xHeapRegions数组传给vPortDefineHeapRegions函数，即可初始化Heap_5。

### 2.3 Heap相关的函数

#### 2.3.1 pvPortMalloc/vPortFree

函数原型：

```text
void * pvPortMalloc( size_t xWantedSize );	// 分配内存，如果分配内存不成功，则返回值为NULL。
void vPortFree( void * pv );	// 释放内存
```

作用：分配内存、释放内存。

如果分配内存不成功，则返回值为NULL。

#### 2.3.2 xPortGetFreeHeapSize

函数原型：

```text
size_t xPortGetFreeHeapSize( void );
```

当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么configTOTAL_HEAP_SIZE就可减小2000。

注意：在heap_3中无法使用。

#### 2.3.3 xPortGetMinimumEverFreeHeapSize

函数原型：

```text
size_t xPortGetMinimumEverFreeHeapSize( void );
```

返回：程序运行过程中，空闲内存容量的最小值。

注意：只有heap_4、heap_5支持此函数。

#### 2.3.4 malloc失败的钩子函数

在pvPortMalloc函数内部：

```text
void * pvPortMalloc( size_t xWantedSize )
{
    ......
    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
        }
    #endif
    
    return pvReturn;        
}
```

所以，如果想使用这个钩子函数：



- 在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1
- 提供vApplicationMallocFailedHook函数
- pvPortMalloc失败时，才会调用此函数



## 3 任务管理

### 3.1 基本概念

对于整个单片机程序，我们称之为application，应用程序。

使用FreeRTOS时，我们可以在application中创建多个任务(task)，有些文档把任务也称为线程(thread)。



![img](https://pic1.zhimg.com/80/v2-98dce0d17d6aa6e74ebd7d7fb2e7c224_720w.webp)



以日常生活为例，比如这个母亲要同时做两件事：



- 喂饭：这是一个任务
- 回信息：这是另一个任务



这可以引入很多概念：



- 任务状态(State)：

- - 当前正在喂饭，它是running状态；另一个"回信息"的任务就是"not running"状态

  - "not running"状态还可以细分：

  - - ready：就绪，随时可以运行
    - blocked：阻塞，卡住了，母亲在等待同事回信息
    - suspended：挂起，同事废话太多，不管他了





- 优先级(Priority)

- - 我工作生活兼顾：喂饭、回信息优先级一样，轮流做
  - 我忙里偷闲：还有空闲任务，休息一下
  - 厨房着火了，什么都别说了，先灭火：优先级更高



- 栈(Stack)

- - 喂小孩时，我要记得上一口喂了米饭，这口要喂青菜了
  - 回信息时，我要记得刚才聊的是啥
  - 做不同的任务，这些细节不一样
  - 对于人来说，当然是记在脑子里
  - 对于程序，是记在栈里
  - 每个任务有自己的栈



- 事件驱动

- - 孩子吃饭太慢：先休息一会，等他咽下去了、等他提醒我了，再喂下一口



- 协助式调度(Co-operative Scheduling)

- - 你在给同事回信息

  - - 同事说：好了，你先去给小孩喂一口饭吧，你才能离开
    - 同事不放你走，即使孩子哭了你也不能走



- - 你好不容易可以给孩子喂饭了

  - - 孩子说：好了，妈妈你去处理一下工作吧，你才能离开
    - 孩子不放你走，即使同事连发信息你也不能走







这涉及很多概念，后续章节详细分析。

### 3.2 任务创建与删除

#### 3.2.1 什么是任务

在FreeRTOS中，任务就是一个函数，原型如下：

```text
void ATaskFunction( void *pvParameters );
```

要注意的是：



- 这个函数不能返回

- 同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数

- 函数内部，尽量使用局部变量：

- - 每个任务都有自己的栈

  - 每个任务运行这个函数时

  - - 任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里
    - 不同任务的局部变量，有自己的副本



- - 函数使用全局变量、静态变量的话

  - - 只有一个副本：多个任务使用的是同一个副本
    - 要防止冲突(后续会讲)



下面是一个示例：

```text
void ATaskFunction( void *pvParameters )
{
	/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */
	int32_t lVariableExample = 0;
	
    /* 任务函数通常实现为一个无限循环 */
	for( ;; )
	{
		/* 任务的代码 */
	}

    /* 如果程序从循环中退出，一定要使用vTaskDelete删除自己
     * NULL表示删除的是自己
     */
	vTaskDelete( NULL );
    
    /* 程序不会执行到这里, 如果执行到这里就出错了 */
}
```

### 4

创建任务时使用的函数如下：

```text
BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 函数指针, 任务函数
                        const char * const pcName, // 任务的名字
                        const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,10表示40字节
                        void * const pvParameters, // 调用任务函数时传入的参数
                        UBaseType_t uxPriority,    // 优先级
                        TaskHandle_t * const pxCreatedTask ); // 任务句柄, 以后使用它来操作这个任务
```

参数说明：

![img](https://pic4.zhimg.com/80/v2-d826aa5cb1ad8f1501d15fa9417fba9f_720w.webp)

#### 3.2.3 示例1: 创建任务

代码为：`FreeRTOS_01_create_task`

使用2个函数分别创建2个任务。

任务1的代码：

```text
void vTask1( void *pvParameters )
{
	const char *pcTaskName = "T1 run\r\n";
	volatile uint32_t ul; /* volatile用来避免被优化掉 */
	
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		/* 打印任务1的信息 */
		printf( pcTaskName );
		
		/* 延迟一会(比较简单粗暴) */
		for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
		{
		}
	}
}
```

任务2的代码：

```text
void vTask2( void *pvParameters )
{
	const char *pcTaskName = "T2 run\r\n";
	volatile uint32_t ul; /* volatile用来避免被优化掉 */
	
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		/* 打印任务1的信息 */
		printf( pcTaskName );
		
		/* 延迟一会(比较简单粗暴) */
		for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
		{
		}
	}
}
```

main函数：

```text
int main( void )
{
	prvSetupHardware();
	
	xTaskCreate(vTask1, "Task 1", 1000, NULL, 1, NULL);
	xTaskCreate(vTask2, "Task 2", 1000, NULL, 1, NULL);

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

运行结果如下：



![img](https://pic1.zhimg.com/80/v2-98dce0d17d6aa6e74ebd7d7fb2e7c224_720w.webp)



注意：



- task 2先运行！
- 要分析xTaskCreate的代码才能知道原因：更高优先级的、或者后面创建的任务先运行。



任务运行图：



- 在t1：Task2进入运行态，一直运行直到t2
- 在t2：Task1进入运行态，一直运行直到t3；在t3，Task2重新进入运行态





![img](https://pic3.zhimg.com/80/v2-e3779c1c97c155bac8ee60c015b3f7be_720w.webp)



#### 3.2.4 示例2: 使用任务参数

代码为：`FreeRTOS_02_create_task_use_params`

我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？



- 栈不同
- 创建任务时可以传入不同的参数



我们创建2个任务，使用同一个函数，代码如下：

```text
void vTaskFunction( void *pvParameters )
{
	const char *pcTaskText = pvParameters;
	volatile uint32_t ul; /* volatile用来避免被优化掉 */
	
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		/* 打印任务的信息 */
		printf(pcTaskText);
		
		/* 延迟一会(比较简单粗暴) */
		for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
		{
		}
	}
}
```

上述代码中的`pcTaskText`来自参数`pvParameters`，`pvParameters`来自哪里？创建任务时传入的。

代码如下：



- 使用xTaskCreate创建2个任务时，第4个参数就是pvParameters
- 不同的任务，pvParameters不一样



```text
static const char *pcTextForTask1 = "T1 run\r\n";
static const char *pcTextForTask2 = "T2 run\r\n";

int main( void )
{
	prvSetupHardware();
	
	xTaskCreate(vTaskFunction, "Task 1", 1000, (void *)pcTextForTask1, 1, NULL);
	xTaskCreate(vTaskFunction, "Task 2", 1000, (void *)pcTextForTask2, 1, NULL);

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

#### 3.2.5 任务的删除

删除任务时使用的函数如下：

```text
void vTaskDelete( TaskHandle_t xTaskToDelete );
```

参数说明：

![img](https://pic4.zhimg.com/80/v2-62afa081eed1fe32daa67c278cab9d5b_720w.webp)

怎么删除任务？举个不好的例子：



- 自杀：`vTaskDelete(NULL)`
- 被杀：别的任务执行`vTaskDelete(pvTaskCode)`，pvTaskCode是自己的句柄
- 杀人：执行`vTaskDelete(pvTaskCode)`，pvTaskCode是别的任务的句柄



#### 3.2.6 示例3: 删除任务

代码为：`FreeRTOS_03_delete_task`

本节代码会涉及优先级的知识，可以只看vTaskDelete的用法，忽略优先级的讲解。

我们要做这些事情：



- 创建任务1：任务1的大循环里，创建任务2，然后休眠一段时间
- 任务2：打印一句话，然后就删除自己



任务1的代码如下：

```text
void vTask1( void *pvParameters )
{
	const TickType_t xDelay100ms = pdMS_TO_TICKS( 100UL );		
	BaseType_t ret;
	
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		/* 打印任务的信息 */
		printf("Task1 is running\r\n");
		
		ret = xTaskCreate( vTask2, "Task 2", 1000, NULL, 2, &xTask2Handle );
		if (ret != pdPASS)
			printf("Create Task2 Failed\r\n");
		
		// 如果不休眠的话, Idle任务无法得到执行
		// Idel任务会清理任务2使用的内存
		// 如果不休眠则Idle任务无法执行, 最后内存耗尽
		vTaskDelay( xDelay100ms );
	}
```

任务2的代码如下：

```text
void vTask2( void *pvParameters )
{	
	/* 打印任务的信息 */
	printf("Task2 is running and about to delete itself\r\n");

	// 可以直接传入参数NULL, 这里只是为了演示函数用法
	vTaskDelete(xTask2Handle);
}
```

main函数代码如下：

```text
int main( void )
{
	prvSetupHardware();
	
	xTaskCreate(vTask1, "Task 1", 1000, NULL, 1, NULL);

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

运行结果如下：



![img](https://pic2.zhimg.com/80/v2-874113062cb083c3b3277de44bd0b44d_720w.webp)



任务运行图：



- main函数中创建任务1，优先级为1。任务1运行时，它创建任务2，任务2的优先级是2。
- 任务2的优先级最高，它马上执行。
- 任务2打印一句话后，就删除了自己。
- 任务2被删除后，任务1的优先级最高，轮到任务1继续运行，它调用`vTaskDelay()`进入Block状态
- 任务1 Block期间，轮到Idle任务执行：它释放任务2的内存(TCB、栈)
- 时间到后，任务1变为最高优先级的任务继续执行。
- 如此循环。





![img](https://pic3.zhimg.com/80/v2-01f1543481989ca7b143c79bf90ade52_720w.webp)



在任务1的函数中，如果不调用vTaskDelay，则Idle任务用于没有机会执行，它就无法释放创建任务2是分配的内存。

而任务1在不断地创建任务，不断地消耗内存，最终内存耗尽再也无法创建新的任务。

现象如下：



![img](https://pic3.zhimg.com/80/v2-01f1543481989ca7b143c79bf90ade52_720w.webp)



任务1的代码中，需要注意的是：xTaskCreate的返回值。



- 很多手册里说它失败时返回值是pdFAIL，这个宏是0
- 其实失败时返回值是errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY，这个宏是-1
- 为了避免混淆，我们使用返回值跟pdPASS来比较，这个宏是1



### 3.3 任务优先级和Tick

#### 3.3.1 任务优先级

在上个示例中我们体验过优先级的使用：高优先级的任务先运行。

优先级的取值范围是：0~(configMAX_PRIORITIES – 1)，数值越大优先级越高。

FreeRTOS的调度器可以使用2种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时，configMAX_PRIORITIES 的取值有所不同。



- 通用方法
  使用C函数实现，对所有的架构都是同样的代码。对configMAX_PRIORITIES的取值没有限制。但是configMAX_PRIORITIES的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。
  configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为0、或者未定义时，使用此方法。
- 架构相关的优化的方法
  架构相关的汇编指令，可以从一个32位的数里快速地找出为1的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。
  使用这种方法时，configMAX_PRIORITIES的取值不能超过32。
  configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为1时，使用此方法。



在学习调度方法之前，你只要初略地知道：



- FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行
- 对于相同优先级的、可运行的任务，轮流执行



这无需记忆，就像我们举的例子：



- 厨房着火了，当然优先灭火
- 喂饭、回复信息同样重要，轮流做



#### 3.3.2 Tick

对于同优先级的任务，它们“轮流”执行。怎么轮流？你执行一会，我执行一会。

"一会"怎么定义？

人有心跳，心跳间隔基本恒定。

FreeRTOS中也有心跳，它使用定时器产生固定间隔的中断。这叫Tick、滴答，比如每10ms发生一次时钟中断。

如下图：



- 假设t1、t2、t3发生时钟中断
- 两次中断之间的时间被称为时间片(time slice、tick period)
- 时间片的长度由configTICK_RATE_HZ 决定，假设configTICK_RATE_HZ为100，那么时间片长度就是10ms





![img](https://pic4.zhimg.com/80/v2-ae7d80f24165256a6e80c201ddf23827_720w.webp)



相同优先级的任务怎么切换呢？请看下图：



- 任务2从t1执行到t2

- 在t2发生tick中断，进入tick中断处理函数：

- - 选择下一个要运行的任务
  - 执行完中断处理函数后，切换到新的任务：任务1



- 任务1从t2执行到t3
- 从下图中可以看出，任务运行的时间并不是严格从t1,t2,t3哪里开始





![img](https://pic3.zhimg.com/80/v2-7c76ae1a828cef59b9fe7011f9e98ba6_720w.webp)



有了Tick的概念后，我们就可以使用Tick来衡量时间了，比如：

```text
vTaskDelay(2);  // 等待2个Tick，假设configTICK_RATE_HZ=100, Tick周期时10ms, 等待20ms

// 还可以使用pdMS_TO_TICKS宏把ms转换为tick
vTaskDelay(pdMS_TO_TICKS(100));	 // 等待100ms
```

注意，基于Tick实现的延时并不精确，比如`vTaskDelay(2)`的本意是延迟2个Tick周期，有可能经过1个Tick多一点就返回了。

如下图：



![img](https://pic1.zhimg.com/80/v2-4cfece4e0d1bd77bd041f198f3e2a9e4_720w.webp)



使用vTaskDelay函数时，建议以ms为单位，使用pdMS_TO_TICKS把时间转换为Tick。

这样的代码就与configTICK_RATE_HZ无关，即使配置项configTICK_RATE_HZ改变了，我们也不用去修改代码。

#### 3.3.3 示例4: 优先级实验

代码为：`FreeRTOS_04_task_priority`

本程序会创建3个任务：



- 任务1、任务2：优先级相同，都是1
- 任务3：优先级最高，是2



任务1、2代码如下：

```text
void vTask1( void *pvParameters )
{
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		/* 打印任务的信息 */
		printf("T1\r\n");				
	}
}

void vTask2( void *pvParameters )
{	
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		/* 打印任务的信息 */
		printf("T2\r\n");				
	}
}
```

任务3代码如下：

```text
void vTask3( void *pvParameters )
{	
	const TickType_t xDelay3000ms = pdMS_TO_TICKS( 3000UL );		
	
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		/* 打印任务的信息 */
		printf("T3\r\n");				

		// 如果不休眠的话, 其他任务无法得到执行
		vTaskDelay( xDelay3000ms );
	}
}
```

main函数代码如下：

```text
{
	prvSetupHardware();
	
	xTaskCreate(vTask1, "Task 1", 1000, NULL, 1, NULL);
	xTaskCreate(vTask2, "Task 2", 1000, NULL, 1, NULL);
	xTaskCreate(vTask3, "Task 3", 1000, NULL, 2, NULL);

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

运行情况如下图所示：



- 任务3优先执行，直到它调用vTaskDelay主动放弃运行
- 任务1、任务2：轮流执行





![img](https://pic1.zhimg.com/80/v2-c1d86c666fbdbcffa1ac06db8070960c_720w.webp)



调度情况如下图所示：



![img](https://pic1.zhimg.com/80/v2-119a85d1ef8403e5f037617960edd6b8_720w.webp)



#### 3.3.4 示例5: 修改优先级

本节代码为：`FreeRTOS_05_change_priority`。

使用uxTaskPriorityGet来获得任务的优先级：

```text
UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );
```

使用参数xTask来指定任务，设置为NULL表示获取自己的优先级。

使用vTaskPrioritySet 来设置任务的优先级：

```text
void vTaskPrioritySet( TaskHandle_t xTask,
                       UBaseType_t uxNewPriority );
```

使用参数xTask来指定任务，设置为NULL表示设置自己的优先级；
参数uxNewPriority表示新的优先级，取值范围是0~(configMAX_PRIORITIES – 1)。

main函数的代码如下，它创建了2个任务：任务1的优先级更高，它先执行：

```text
int main( void )
{
	prvSetupHardware();
	
	/* Task1的优先级更高, Task1先执行 */
	xTaskCreate( vTask1, "Task 1", 1000, NULL, 2, NULL );
	xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, &xTask2Handle );

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

任务1的代码如下：

```text
void vTask1( void *pvParameters )
{
	UBaseType_t uxPriority;
	
	/* Task1,Task2都不会进入阻塞或者暂停状态
	 * 根据优先级决定谁能运行
	 */
	
	/* 得到Task1自己的优先级 */
	uxPriority = uxTaskPriorityGet( NULL );
	
	for( ;; )
	{
		printf( "Task 1 is running\r\n" );

		printf("About to raise the Task 2 priority\r\n" );
		
		/* 提升Task2的优先级高于Task1
		 * Task2会即刻执行
 		 */
		vTaskPrioritySet( xTask2Handle, ( uxPriority + 1 ) );
		
		/* 如果Task1能运行到这里，表示它的优先级比Task2高
		* 那就表示Task2肯定把自己的优先级降低了
 		 */
	}
}
```

任务2的代码如下：

```text
void vTask2( void *pvParameters )
{
	UBaseType_t uxPriority;

	/* Task1,Task2都不会进入阻塞或者暂停状态
	 * 根据优先级决定谁能运行
	 */
	
	/* 得到Task2自己的优先级 */
	uxPriority = uxTaskPriorityGet( NULL );
	
	for( ;; )
	{
		/* 能运行到这里表示Task2的优先级高于Task1
		 * Task1提高了Task2的优先级
		 */
		printf( "Task 2 is running\r\n" );
		
		printf( "About to lower the Task 2 priority\r\n" );

		/* 降低Task2自己的优先级，让它小于Task1
		 * Task1得以运行
 		 */
		vTaskPrioritySet( NULL, ( uxPriority - 2 ) );
	}
}
```

调度情况如下图所示：



- 1：一开始Task1优先级最高，它先执行。它提升了Task2的优先级。
- 2：Task2的优先级最高，它执行。它把自己的优先级降低了。
- 3：Task1的优先级最高，再次执行。它提升了Task2的优先级。
- 如此循环。
- 注意：Task1的优先级一直是2，Task2的优先级是3或1，都大于0。所以Idel任务没有机会执行。





![img](https://pic1.zhimg.com/80/v2-8aa167b0094cced080ffef40df1aa570_720w.webp)



### 3.4 任务状态

以前我们很简单地把任务的状态分为2中：运行(Runing)、非运行(Not Running)。

对于非运行的状态，还可以继续细分，比如前面的`FreeRTOS_04_task_priority`中：



- Task3执行vTaskDelay后：处于非运行状态，要过3秒种才能再次运行

- Task3运行期间，Task1、Task2也处于非运行状态，但是它们**随时可以运行**

- 这两种"非运行"状态就不一样，可以细分为：

- - 阻塞状态(Blocked)
  - 暂停状态(Suspended)
  - 就绪状态(Ready)





#### 3.4.1 阻塞状态(Blocked)

在日常生活的例子中，母亲在电脑前跟同事沟通时，如果同事一直没回复，那么母亲的工作就被卡住了、被堵住了、处于阻塞状态(Blocked)。重点在于：母亲在**等待**。

在`FreeRTOS_04_task_priority`实验中，如果把任务3中的vTaskDelay调用注释掉，那么任务1、任务2根本没有执行的机会，任务1、任务2被"饿死"了(starve)。

在实际产品中，我们不会让一个任务一直运行，而是使用"事件驱动"的方法让它运行：



- 任务要等待某个事件，事件发生后它才能运行
- 在等待事件过程中，它不消耗CPU资源
- 在等待事件的过程中，这个任务就处于阻塞状态(Blocked)



在阻塞状态的任务，它可以等待两种类型的事件：



- 时间相关的事件

- - 可以等待一段时间：我等2分钟
  - 也可以一直等待，直到某个绝对时间：我等到下午3点



- 同步事件：这事件由别的任务，或者是中断程序产生

- - 例子1：任务A等待任务B给它发送数据

  - 例子2：任务A等待用户按下按键

  - 同步事件的来源有很多(这些概念在后面会细讲)：

  - - 队列(queue)
    - 二进制信号量(binary semaphores)
    - 计数信号量(counting semaphores)
    - 互斥量(mutexes)
    - 递归互斥量、递归锁(recursive mutexes)
    - 事件组(event groups)
    - 任务通知(task notifications)







在等待一个同步事件时，可以加上超时时间。比如等待队里数据，超时时间设为10ms：



- 10ms之内有数据到来：成功返回
- 10ms到了，还是没有数据：超时返回



#### 3.4.2 暂停状态(Suspended)

在日常生活的例子中，母亲正在电脑前跟同事沟通，母亲可以暂停：



- 好烦啊，我暂停一会
- 领导说：你暂停一下



FreeRTOS中的任务也可以进入暂停状态，唯一的方法是通过vTaskSuspend函数。函数原型如下：

```text
void vTaskSuspend( TaskHandle_t xTaskToSuspend );
```

参数xTaskToSuspend表示要暂停的任务，如果为NULL，表示暂停自己。

要退出暂停状态，只能由**别人**来操作：



- 别的任务调用：vTaskResume
- 中断程序调用：xTaskResumeFromISR



实际开发中，暂停状态用得不多。

#### 3.4.3 就绪状态(Ready)

这个任务完全准备好了，随时可以运行：只是还轮不到它。这时，它就处于就绪态(Ready)。

#### 3.4.4 完整的状态转换图



![img](https://pic1.zhimg.com/80/v2-5f7a88eb73e902532176b581ce20a124_720w.webp)



### 3.5 Delay函数

#### 3.5.1 两个Delay函数

有两个Delay函数：



- vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态
- vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。



这2个函数原型如下：

```text
void vTaskDelay( const TickType_t xTicksToDelay ); /* xTicksToDelay: 等待多少给Tick */

/* pxPreviousWakeTime: 上一次被唤醒的时间
 * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)
 * 单位都是Tick Count
 */
BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                            const TickType_t xTimeIncrement );
```

下面画图说明：



- 使用vTaskDelay(n)时，进入、退出vTaskDelay的时间间隔至少是n个Tick中断

- 使用xTaskDelayUntil(&Pre, n)时，前后两次退出xTaskDelayUntil的时间至少是n个Tick中断

- - 退出xTaskDelayUntil时任务就进入的就绪状态，一般都能得到执行机会
  - 所以可以使用xTaskDelayUntil来让任务周期性地运行







![img](https://pic3.zhimg.com/80/v2-3a51a314c17656c20a00a549b70fb436_720w.webp)



#### 3.5.2 示例6: Delay

本节代码为：`FreeRTOS_06_taskdelay`。

本程序会创建2个任务：



- Task1：

- - 高优先级
  - 设置变量flag为1，然后调用`vTaskDelay(xDelay50ms);`或`vTaskDelayUntil(&xLastWakeTime, xDelay50ms);`



- Task2：

- - 低优先级
  - 设置变量flag为0





main函数代码如下：

```text
int main( void )
{
	prvSetupHardware();
	
	/* Task1的优先级更高, Task1先执行 */
	xTaskCreate( vTask1, "Task 1", 1000, NULL, 2, NULL );
	xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

Task1的代码中使用条件开关来选择Delay函数，把`#if 1`改为`#if 0`就可以使用`vTaskDelayUntil`，代码如下：

```text
void vTask1( void *pvParameters )
{
	const TickType_t xDelay50ms = pdMS_TO_TICKS( 50UL );
	TickType_t xLastWakeTime;
	int i;
	
	/* 获得当前的Tick Count */
	xLastWakeTime = xTaskGetTickCount();
			
	for( ;; )
	{
		flag = 1;
		
		/* 故意加入多个循环，让程序运行时间长一点 */
		for (i = 0; i <5; i++)
			printf( "Task 1 is running\r\n" );

#if 1		
		vTaskDelay(xDelay50ms);
#else		
		vTaskDelayUntil(&xLastWakeTime, xDelay50ms);
#endif		
	}
}
```

Task2的代码如下：

```text
void vTask2( void *pvParameters )
{
	for( ;; )
	{
		flag = 0;
		printf( "Task 2 is running\r\n" );
	}
}
```

使用Keil的逻辑分析观察flag变量的bit波形，如下：



- flag为1时表示Task1在运行，flag为0时表示Task2在运行，也就是Task1处于阻塞状态
- vTaskDelay：指定的是阻塞的时间
- vTaskDelayUntil：指定的是任务执行的间隔、周期





![img](https://pic1.zhimg.com/80/v2-4e8b1db0b86bc1395081854dafa3946c_720w.webp)



### 3.6 空闲任务及其钩子函数

#### 3.6.1 介绍

在`FreeRTOS_03_delete_task`的实验里，我们体验过空闲任务(Idle任务)的作用：释放被删除的任务的内存。

除了上述目的之外，为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用`vTaskStartScheduler()`函数来创建、启动调度器时，这个函数内部会创建空闲任务：



- 空闲任务优先级为0：它不能阻碍用户任务运行
- 空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞



空闲任务的优先级为0，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务"抢占"(pre-empt)了空闲任务，这是由调度器实现的。

要注意的是：如果使用`vTaskDelete()`来删除任务，那么你就要确保空闲任务有机会执行，否则就无法释放被删除任务的内存。

我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：



- 执行一些低优先级的、后台的、需要连续执行的函数
- 测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。
- 让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。



空闲任务的钩子函数的限制：



- 不能导致空闲任务进入阻塞状态、暂停状态
- 如果你会使用`vTaskDelete()`来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。



#### 3.6.2 使用钩子函数的前提

在`FreeRTOS\Source\tasks.c`中，可以看到如下代码，所以前提就是：



- 把这个宏定义为1：configUSE_IDLE_HOOK
- 实现`vApplicationIdleHook`函数





![img](https://pic1.zhimg.com/80/v2-bddafb381f5ca95e8a1509aa4be9bd20_720w.webp)



### 3.7 调度算法

#### 3.7.1 重要概念

这些知识在前面都提到过了，这里总结一下。

正在运行的任务，被称为"正在使用处理器"，它处于运行状态。在单处理系统中，任何时间里只能有一个任务处于运行状态。

非运行状态的任务，它处于这3中状态之一：阻塞(Blocked)、暂停(Suspended)、就绪(Ready)。就绪态的任务，可以被调度器挑选出来切换为运行状态，调度器永远都是挑选最高优先级的就绪态任务并让它进入运行状态。

阻塞状态的任务，它在等待"事件"，当事件发生时任务就会进入就绪状态。事件分为两类：时间相关的事件、同步事件。所谓时间相关的事件，就是设置超时时间：在指定时间内阻塞，时间到了就进入就绪状态。使用时间相关的事件，可以实现周期性的功能、可以实现超时功能。同步事件就是：某个任务在等待某些信息，别的任务或者中断服务程序会给它发送信息。怎么"发送信息"？方法很多，有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)等。这些方法用来发送同步信息，比如表示某个外设得到了数据。

#### 3.7.2 配置调度算法

所谓调度算法，就是怎么确定哪个就绪态的任务可以切换为运行状态。

通过配置文件FreeRTOSConfig.h的两个配置项来配置调度算法：configUSE_PREEMPTION、configUSE_TIME_SLICING。

还有第三个配置项：configUSE_TICKLESS_IDLE，它是一个高级选项，用于关闭Tick中断来实现省电，后续单独讲解。现在我们假设configUSE_TICKLESS_IDLE被设为0，先不使用这个功能。

调度算法的行为主要体现在两方面：高优先级的任务先运行、同优先级的就绪态任务如何被选中。调度算法要确保同优先级的就绪态任务，能"轮流"运行，策略是"轮转调度"(Round Robin Scheduling)。轮转调度并不保证任务的运行时间是公平分配的，我们还可以细化时间的分配方法。

从3个角度统一理解多种调度算法：



- 可否抢占？高优先级的任务能否优先执行(配置项: configUSE_PREEMPTION)

- - 可以：被称作"可抢占调度"(Pre-emptive)，高优先级的就绪任务马上执行，下面再细化。

  - 不可以：不能抢就只能协商了，被称作"合作调度模式"(Co-operative Scheduling)

  - - 当前任务执行时，更高优先级的任务就绪了也不能马上运行，只能等待当前任务主动让出CPU资源。
    - 其他同优先级的任务也只能等待：更高优先级的任务都不能抢占，平级的更应该老实点





- 可抢占的前提下，同优先级的任务是否轮流执行(配置项：configUSE_TIME_SLICING)

- - 轮流执行：被称为"时间片轮转"(Time Slicing)，同优先级的任务轮流执行，你执行一个时间片、我再执行一个时间片
  - 不轮流执行：英文为"without Time Slicing"，当前任务会一直执行，直到主动放弃、或者被高优先级任务抢占



- 在"可抢占"+"时间片轮转"的前提下，进一步细化：空闲任务是否让步于用户任务(配置项：configIDLE_SHOULD_YIELD)

- - 空闲任务低人一等，每执行一次循环，就看看是否主动让位给用户任务
  - 空闲任务跟用户任务一样，大家轮流执行，没有谁更特殊





列表如下：

![img](https://pic3.zhimg.com/80/v2-e77105650509a1dfff33155a788697a2_720w.webp)



注：



- A：可抢占+时间片轮转+空闲任务让步
- B：可抢占+时间片轮转+空闲任务不让步
- C：可抢占+非时间片轮转+空闲任务让步
- D：可抢占+非时间片轮转+空闲任务不让步
- E：合作调度



#### 3.7.3 示例7: 调度

本节代码为：`FreeRTOS_07_scheduler`。后续的实验都是基于这个程序，通过修改配置项来观察效果。

代码里创建了3个任务：Task1、Task2的优先级都是0，跟空闲任务一样，Task3优先级最高为2。程序里定义了4个全局变量，当某个的任务执行时，对应的变量就被设为1，可以通过Keil的逻辑分析仪查看任务切换情况：

```text
static volatile int flagIdleTaskrun = 0;  // 空闲任务运行时flagIdleTaskrun=1
static volatile int flagTask1run = 0;     // 任务1运行时flagTask1run=1
static volatile int flagTask2run = 0;     // 任务2运行时flagTask2run=1
static volatile int flagTask3run = 0;     // 任务3运行时flagTask3run=1
```

main函数代码如下：

```text
int main( void )
{
	prvSetupHardware();
	
	xTaskCreate(vTask1, "Task 1", 1000, NULL, 0, NULL);
	xTaskCreate(vTask2, "Task 2", 1000, NULL, 0, NULL);
	xTaskCreate(vTask3, "Task 3", 1000, NULL, 2, NULL);

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

任务1、任务2代码如下，它们是"连续任务"(continuous task)：

```text
void vTask1( void *pvParameters )
{
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		flagIdleTaskrun = 0;
		flagTask1run = 1;
		flagTask2run = 0;
		flagTask3run = 0;
		
		/* 打印任务的信息 */
		printf("T1\r\n");				
	}
}

void vTask2( void *pvParameters )
{	
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		flagIdleTaskrun = 0;
		flagTask1run = 0;
		flagTask2run = 1;
		flagTask3run = 0;
		
		/* 打印任务的信息 */
		printf("T2\r\n");				
	}
}
```

任务3代码如下，它会调用`vTaskDelay`，这样别的任务才可以运行：

```text
void vTask3( void *pvParameters )
{	
	const TickType_t xDelay5ms = pdMS_TO_TICKS( 5UL );		
	
	/* 任务函数的主体一般都是无限循环 */
	for( ;; )
	{
		flagIdleTaskrun = 0;
		flagTask1run = 0;
		flagTask2run = 0;
		flagTask3run = 1;
		
		/* 打印任务的信息 */
		printf("T3\r\n");				

		// 如果不休眠的话, 其他任务无法得到执行
		vTaskDelay( xDelay5ms );
	}
}
```

提供了一个空闲任务的钩子函数：

```text
void vApplicationIdleHook(void)
{
	flagIdleTaskrun = 1;
	flagTask1run = 0;
	flagTask2run = 0;
	flagTask3run = 0;	
	
	/* 故意加入打印让flagIdleTaskrun变为1的时间维持长一点 */
	printf("Id\r\n");				
}
```

#### 3.7.4 对比效果: 抢占与否

在`FreeRTOSConfig.h`中，定义这样的宏，对比逻辑分析仪的效果：

```text
// 实验1：抢占
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING          1
#define configIDLE_SHOULD_YIELD		1

// 实验2：不抢占
#define configUSE_PREEMPTION	 	0
#define configUSE_TIME_SLICING          1
#define configIDLE_SHOULD_YIELD		1
```

从下面的对比图可以知道：



- 抢占时：高优先级任务就绪时，就可以马上执行
- 不抢占时：优先级失去意义了，既然不能抢占就只能协商了，图中任务1一直在运行(一点都没有协商精神)，其他任务都无法执行。即使任务3的`vTaskDelay`已经超时、即使它的优先级更高，都没办法执行。





![img](https://pic4.zhimg.com/80/v2-8b8ba05d63db9cf2f39235b96020aa5f_720w.webp)



#### 3.7.5 对比效果: 时间片轮转与否

在`FreeRTOSConfig.h`中，定义这样的宏，对比逻辑分析仪的效果：

```text
// 实验1：时间片轮转
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING          1
#define configIDLE_SHOULD_YIELD		1

// 实验2：时间片不轮转
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING          0
#define configIDLE_SHOULD_YIELD		1
```

从下面的对比图可以知道：



- 时间片轮转：在Tick中断中会引起任务切换
- 时间片不轮转：高优先级任务就绪时会引起任务切换，高优先级任务不再运行时也会引起任务切换。可以看到任务3就绪后可以马上执行，它运行完毕后导致任务切换。其他时间没有任务切换，可以看到任务1、任务2都运行了很长时间。





![img](https://pic4.zhimg.com/80/v2-1a27aec284bcde6c3fd1e5e7caa85eb7_720w.webp)



#### 3.7.6 对比效果: 空闲任务让步

在`FreeRTOSConfig.h`中，定义这样的宏，对比逻辑分析仪的效果：

```text
// 实验1：空闲任务让步
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING          1
#define configIDLE_SHOULD_YIELD		1

// 实验2：空闲任务不让步
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING          1
#define configIDLE_SHOULD_YIELD		0
```

从下面的对比图可以知道：



- 让步时：在空闲任务的每个循环中，会主动让出处理器，从图中可以看到flagIdelTaskrun的波形很小
- 不让步时：空闲任务跟任务1、任务2同等待遇，它们的波形宽度是差不多的





![img](https://pic1.zhimg.com/80/v2-711cfe4aaf7a461f46ef231098885fc8_720w.webp)

 

## 4 同步互斥与通信

### 概述

本章是概述性的内容。可以把多任务系统当做一个团队，里面的每一个任务就相当于团队里的一个人。团队成员之间要协调工作进度(同步)、争用会议室(互斥)、沟通(通信)。多任务系统中所涉及的概念，都可以在现实生活中找到例子。

各类RTOS都会涉及这些概念：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)等。我们先站在更高角度来讲解这些概念。

### 4.1 同步与互斥的概念

一句话理解同步与互斥：**我等你用完厕所，我再用厕所**。



- 什么叫同步？就是：哎哎哎，我正在用厕所，你等会。
- 什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。



同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？

再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用"同步"来实现"互斥"。

有时候看代码更容易理解，伪代码如下：

```text
01 void  抢厕所(void)
02 {
03    if (有人在用) 我眯一会;
04    用厕所;
05    喂，醒醒，有人要用厕所吗;
06 }
```

假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。
在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。

同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用。

### 4.2 同步与互斥并不简单

### 4.3 各类方法的对比

能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。

它们都有类似的操作方法：获取/释放、阻塞/唤醒、超时。比如：



- A获取资源，用完后A释放资源
- A获取不到资源则阻塞，B释放资源并把A唤醒
- A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为B释放资源而被唤醒。



这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。



- 能否传信息？只能传递状态？
- 为众生？只为你？
- 我生产，你们消费？
- 我上锁，只能由我开锁

![img](https://pic3.zhimg.com/80/v2-76796e31c00fc2100a2b7f09d157cc66_720w.webp)

使用图形对比如下：



- 队列：

- - 里面可以放任意数据，可以放多个数据
  - 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据



- 事件组：

- - 一个事件用一bit表示，1表示事件发生了，0表示事件没发生
  - 可以用来表示事件、事件的组合发生了，不能传递数据
  - 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒



- 信号量：

- - 核心是"计数值"
  - 任务、ISR释放信号量时让计数值加1
  - 任务、ISR获得信号量时，让计数值减1



- 任务通知：

- - 核心是任务的TCB里的数值
  - 会被覆盖
  - 发通知给谁？必须指定接收任务
  - 只能由接收任务本身获取该通知



- 互斥量：

- - 数值只有0或1
  - 谁获得互斥量，就必须由谁释放同一个互斥量







![img](https://pic1.zhimg.com/80/v2-098aecf536f7f78853f58e28ebe5edf0_720w.webp)

## 5 队列(queue)

### 概述

队列(queue)可以用于"任务到任务"、“任务到中断”、"中断到任务"直接传输信息。

本章涉及如下内容：



- 怎么创建、清除、删除队列
- 队列中消息如何保存
- 怎么向队列发送数据、怎么从队列读取数据、怎么覆盖队列的数据
- 在队列上阻塞是什么意思
- 怎么在多个队列上阻塞
- 读写队列时如何影响任务的优先级



### 5.1 队列的特性

#### 5.1.1 常规操作

队列的简化操如入下图所示，从此图可知：



- 队列可以包含若干个数据：队列中有若干项，这被称为"长度"(length)
- 每个数据大小固定
- 创建队列时就要指定长度、数据大小
- 数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读
- 也可以强制写队列头部：覆盖头部数据





![img](https://pic2.zhimg.com/80/v2-cd4b696c52080ee754205eccdeac91c5_720w.webp)



更详细的操作入下图所示：



![img](https://pic3.zhimg.com/80/v2-b14d0d27419de8c0dc0968ebb4145122_720w.webp)



#### 5.1.2 传输数据的两种方法

使用队列传输数据时有两种方法：



- 拷贝：把数据、把变量的值复制进队列里
- 引用：把数据、把变量的地址复制进队列里



FreeRTOS使用拷贝值的方法，这更简单：



- 局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据
- 无需分配buffer来保存数据，队列中有buffer
- 局部变量可以马上再次使用
- 发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据
- 如果数据实在太大，你还是可以使用队列传输它的地址
- 队列的空间有FreeRTOS内核分配，无需任务操心
- 对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。



#### 5.1.3 队列的阻塞访问

只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。

任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。

某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。

既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？



- 优先级最高的任务
- 如果大家的优先级相同，那等待时间最久的任务会进入就绪态



跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。

既然写队列的任务个数没有限制，那么当多个任务写"满队列"时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？



- 优先级最高的任务
- 如果大家的优先级相同，那等待时间最久的任务会进入就绪态



### 5.2 队列函数

使用队列的流程：创建队列、写队列、读队列、删除队列。

#### 5.2.1 创建

队列的创建有两种方法：动态分配内存、静态分配内存，



- 动态分配内存：xQueueCreate，队列的内存在函数内部动态分配



函数原型如下：

```text
QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );
```

![img](https://pic1.zhimg.com/80/v2-139766fcce0dc68e88892b20cb7aebdc_720w.webp)



- 静态分配内存：xQueueCreateStatic，队列的内存要事先分配好



函数原型如下：

```text
QueueHandle_t xQueueCreateStatic(
                           UBaseType_t uxQueueLength,
                           UBaseType_t uxItemSize,
                           uint8_t *pucQueueStorageBuffer,
                           StaticQueue_t *pxQueueBuffer
                       );
```

![img](https://pic4.zhimg.com/80/v2-b811a0da2e69165b45f594d934d872b3_720w.webp)

示例代码：

```text
// 示例代码
 #define QUEUE_LENGTH 10
 #define ITEM_SIZE sizeof( uint32_t )
 
 // xQueueBuffer用来保存队列结构体
 StaticQueue_t xQueueBuffer;
 
 // ucQueueStorage 用来保存队列的数据
 // 大小为：队列长度 * 数据大小
 uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
 
 void vATask( void *pvParameters )
 {
	QueueHandle_t xQueue1;
 
	// 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE
	xQueue1 = xQueueCreateStatic( QUEUE_LENGTH,
						  ITEM_SIZE,
						  ucQueueStorage,
						  &xQueueBuffer ); 
 }
```

#### 5.2.2 复位

队列刚被创建时，里面没有数据；使用过程中可以调用`xQueueReset()`把队列恢复为初始状态，此函数原型为：

```text
/* pxQueue : 复位哪个队列;
 * 返回值: pdPASS(必定成功)
 */
BaseType_t xQueueReset( QueueHandle_t pxQueue);
```

#### 5.2.3 删除

删除队列的函数为`vQueueDelete()`，只能删除使用动态方法创建的队列，它会释放内存。原型如下：

```text
void vQueueDelete( QueueHandle_t xQueue );
```

#### 5.2.4 写队列

可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：

```text
/* 等同于xQueueSendToBack
 * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait
 */
BaseType_t xQueueSend(
                                QueueHandle_t    xQueue,
                                const void       *pvItemToQueue,
                                TickType_t       xTicksToWait
                            );

/* 
 * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait
 */
BaseType_t xQueueSendToBack(
                                QueueHandle_t    xQueue,
                                const void       *pvItemToQueue,
                                TickType_t       xTicksToWait
                            );


/* 
 * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞
 */
BaseType_t xQueueSendToBackFromISR(
                                      QueueHandle_t xQueue,
                                      const void *pvItemToQueue,
                                      BaseType_t *pxHigherPriorityTaskWoken
                                   );

/* 
 * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait
 */
BaseType_t xQueueSendToFront(
                                QueueHandle_t    xQueue,
                                const void       *pvItemToQueue,
                                TickType_t       xTicksToWait
                            );

/* 
 * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞
 */
BaseType_t xQueueSendToFrontFromISR(
                                      QueueHandle_t xQueue,
                                      const void *pvItemToQueue,
                                      BaseType_t *pxHigherPriorityTaskWoken
                                   );
```

这些函数用到的参数是类似的，统一说明如下：

![img](https://pic1.zhimg.com/80/v2-be51bcfa627c776e5e3d7628d77b1c48_720w.webp)

#### 5.2.5 读队列

使用`xQueueReceive()`函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：

```text
BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait );

BaseType_t xQueueReceiveFromISR(
                                    QueueHandle_t    xQueue,
                                    void             *pvBuffer,
                                    BaseType_t       *pxTaskWoken
                                );
```

参数说明如下：

![img](https://pic3.zhimg.com/80/v2-b79aa776cb80ce3f7be1369cbfbbe132_720w.webp)

#### 5.2.6 查询

可以查询队列中有多少个数据、有多少空余空间。函数原型如下：

```text
/*
 * 返回队列中可用数据的个数
 */
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );

/*
 * 返回队列中可用空间的个数
 */
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );
```

#### 5.2.7 覆盖/偷看

当队列长度为1时，可以使用`xQueueOverwrite()`或`xQueueOverwriteFromISR()`来覆盖数据。
注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。
函数原型如下：

```text
/* 覆盖队列
 * xQueue: 写哪个队列
 * pvItemToQueue: 数据地址
 * 返回值: pdTRUE表示成功, pdFALSE表示失败
 */
BaseType_t xQueueOverwrite(
                           QueueHandle_t xQueue,
                           const void * pvItemToQueue
                      );

BaseType_t xQueueOverwriteFromISR(
                           QueueHandle_t xQueue,
                           const void * pvItemToQueue,
                           BaseType_t *pxHigherPriorityTaskWoken
                      );
```

如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用"窥视"，也就是`xQueuePeek()`或`xQueuePeekFromISR()`。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么"偷看"时会导致阻塞；一旦队列中有数据，以后每次"偷看"都会成功。
函数原型如下：

```text
/* 偷看队列
 * xQueue: 偷看哪个队列
 * pvItemToQueue: 数据地址, 用来保存复制出来的数据
 * xTicksToWait: 没有数据的话阻塞一会
 * 返回值: pdTRUE表示成功, pdFALSE表示失败
 */
BaseType_t xQueuePeek(
                          QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait
                      );

BaseType_t xQueuePeekFromISR(
                                 QueueHandle_t xQueue,
                                 void *pvBuffer,
                             );
```

### 5.3 示例8: 队列的基本使用

本节代码为：`FreeRTOS_08_queue`。

本程序会创建一个队列，然后创建2个发送任务、1个接收任务：



- 发送任务优先级为1，分别往队列中写入100、200
- 接收任务优先级为2，读队列、打印数值



main函数中创建的队列、创建了发送任务、接收任务，代码如下：

```text
/* 队列句柄, 创建队列时会设置这个变量 */
QueueHandle_t xQueue;

int main( void )
{
	prvSetupHardware();
	
    /* 创建队列: 长度为5，数据大小为4字节(存放一个整数) */
    xQueue = xQueueCreate( 5, sizeof( int32_t ) );

	if( xQueue != NULL )
	{
		/* 创建2个任务用于写队列, 传入的参数分别是100、200
		 * 任务函数会连续执行，向队列发送数值100、200
		 * 优先级为1
		 */
		xTaskCreate( vSenderTask, "Sender1", 1000, ( void * ) 100, 1, NULL );
		xTaskCreate( vSenderTask, "Sender2", 1000, ( void * ) 200, 1, NULL );

		/* 创建1个任务用于读队列
		 * 优先级为2, 高于上面的两个任务
		 * 这意味着队列一有数据就会被读走
		 */
		xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建队列 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务的函数中，不断往队列中写入数值，代码如下：

```text
static void vSenderTask( void *pvParameters )
{
	int32_t lValueToSend;
	BaseType_t xStatus;

	/* 我们会使用这个函数创建2个任务
	 * 这些任务的pvParameters不一样
 	 */
	lValueToSend = ( int32_t ) pvParameters;

	/* 无限循环 */
	for( ;; )
	{
		/* 写队列
		 * xQueue: 写哪个队列
		 * &lValueToSend: 写什么数据? 传入数据的地址, 会从这个地址把数据复制进队列
		 * 0: 不阻塞, 如果队列满的话, 写入失败, 立刻返回
		 */
		xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 );

		if( xStatus != pdPASS )
		{
			printf( "Could not send to the queue.\r\n" );
		}
	}
}
```

接收任务的函数中，读取队列、判断返回值、打印，代码如下：

```text
static void vReceiverTask( void *pvParameters )
{
	/* 读取队列时, 用这个变量来存放数据 */
	int32_t lReceivedValue;
	BaseType_t xStatus;
	const TickType_t xTicksToWait = pdMS_TO_TICKS( 100UL );

	/* 无限循环 */
	for( ;; )
	{
		/* 读队列
		 * xQueue: 读哪个队列
		 * &lReceivedValue: 读到的数据复制到这个地址
		 * xTicksToWait: 如果队列为空, 阻塞一会
		 */
		xStatus = xQueueReceive( xQueue, &lReceivedValue, xTicksToWait );

		if( xStatus == pdPASS )
		{
			/* 读到了数据 */
			printf( "Received = %d\r\n", lReceivedValue );
		}
		else
		{
			/* 没读到数据 */
			printf( "Could not receive from the queue.\r\n" );
		}
	}
}
```

程序运行结果如下：



![img](https://pic3.zhimg.com/80/v2-3a95dc48be386500b55887eac92ea22e_720w.webp)


任务调度情况如下图所示：



![img](https://pic1.zhimg.com/80/v2-8e30ea93674aa084a77c85c80e6d6934_720w.webp)



### 5.4 示例9: 分辨数据源

本节代码为：`FreeRTOS_09_queue_datasource`。

当有多个发送任务，通过同一个队列发出数据，接收任务如何分辨数据来源？数据本身带有"来源"信息，比如写入队列的数据是一个结构体，结构体中的lDataSouceID用来表示数据来源：

```text
typedef struct {
    ID_t eDataID;
    int32_t lDataValue;
}Data_t;
```

不同的发送任务，先构造好结构体，填入自己的`eDataID`，再写队列；接收任务读出数据后，根据`eDataID`就可以知道数据来源了，如下图所示：



- CAN任务发送的数据：eDataID=eMotorSpeed
- HMI任务发送的数据：eDataID=eSpeedSetPoint

![img](https://pic3.zhimg.com/80/v2-be0224a446a871dd54178226625d3aaa_720w.webp)





`FreeRTOS_09_queue_datasource`程序会创建一个队列，然后创建2个发送任务、1个接收任务：



- 创建的队列，用来发送结构体：数据大小是结构体的大小
- 发送任务优先级为2，分别往队列中写入自己的结构体，结构体中会标明数据来源
- 接收任务优先级为1，读队列、根据数据来源打印信息



main函数中创建了队列、创建了发送任务、接收任务，代码如下：

```text
/* 定义2种数据来源(ID) */
typedef enum
{
	eMotorSpeed,
	eSpeedSetPoint
} ID_t;

/* 定义在队列中传输的数据的格式 */
typedef struct {
    ID_t eDataID;
    int32_t lDataValue;
}Data_t;

/* 定义2个结构体 */
static const Data_t xStructsToSend[ 2 ] =
{
	{ eMotorSpeed,    10 }, /* CAN任务发送的数据 */
	{ eSpeedSetPoint, 5 }   /* HMI任务发送的数据 */
};

/* vSenderTask被用来创建2个任务，用于写队列
 * vReceiverTask被用来创建1个任务，用于读队列
 */
static void vSenderTask( void *pvParameters );
static void vReceiverTask( void *pvParameters );

/*-----------------------------------------------------------*/

/* 队列句柄, 创建队列时会设置这个变量 */
QueueHandle_t xQueue;

int main( void )
{
	prvSetupHardware();
	
    /* 创建队列: 长度为5，数据大小为4字节(存放一个整数) */
    xQueue = xQueueCreate( 5, sizeof( Data_t ) );

	if( xQueue != NULL )
	{
		/* 创建2个任务用于写队列, 传入的参数是不同的结构体地址
		 * 任务函数会连续执行，向队列发送结构体
		 * 优先级为2
		 */
		xTaskCreate(vSenderTask, "CAN Task", 1000, (void *) &(xStructsToSend[0]), 2, NULL);
		xTaskCreate(vSenderTask, "HMI Task", 1000, (void *) &( xStructsToSend[1]), 2, NULL);

		/* 创建1个任务用于读队列
		 * 优先级为1, 低于上面的两个任务
		 * 这意味着发送任务优先写队列，队列常常是满的状态
		 */
		xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建队列 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务的函数中，不断往队列中写入数值，代码如下：

```text
static void vSenderTask( void *pvParameters )
{
	BaseType_t xStatus;
	const TickType_t xTicksToWait = pdMS_TO_TICKS( 100UL );

	/* 无限循环 */
	for( ;; )
	{
		/* 写队列
		 * xQueue: 写哪个队列
		 * pvParameters: 写什么数据? 传入数据的地址, 会从这个地址把数据复制进队列
		 * xTicksToWait: 如果队列满的话, 阻塞一会
		 */
		xStatus = xQueueSendToBack( xQueue, pvParameters, xTicksToWait );

		if( xStatus != pdPASS )
		{
			printf( "Could not send to the queue.\r\n" );
		}
	}
}
```

接收任务的函数中，读取队列、判断返回值、打印，代码如下：

```text
static void vReceiverTask( void *pvParameters )
{
	/* 读取队列时, 用这个变量来存放数据 */
	Data_t xReceivedStructure;
	BaseType_t xStatus;

	/* 无限循环 */
	for( ;; )
	{
		/* 读队列
		 * xQueue: 读哪个队列
		 * &xReceivedStructure: 读到的数据复制到这个地址
		 * 0: 没有数据就即刻返回，不阻塞
		 */
		xStatus = xQueueReceive( xQueue, &xReceivedStructure, 0 );

		if( xStatus == pdPASS )
		{
			/* 读到了数据 */
			if( xReceivedStructure.eDataID == eMotorSpeed )
			{
				printf( "From CAN, MotorSpeed = %d\r\n", xReceivedStructure.lDataValue );
			}
			else if( xReceivedStructure.eDataID == eSpeedSetPoint )
			{
				printf( "From HMI, SpeedSetPoint = %d\r\n", xReceivedStructure.lDataValue );
			}
		}
		else
		{
			/* 没读到数据 */
			printf( "Could not receive from the queue.\r\n" );
		}
	}
}
```

运行结果如下：



![img](https://pic3.zhimg.com/80/v2-6d75b386125914ea0d697f65b8a5b662_720w.webp)



任务调度情况如下图所示：



- t1：HMI是最后创建的最高优先级任务，它先执行，一下子向队列写入5个数据，把队列都写满了
- t2：队列已经满了，HMI任务再发起第6次写操作时，进入阻塞状态。这时CAN任务是最高优先级的就绪态任务，它开始执行
- t3：CAN任务发现队列已经满了，进入阻塞状态；接收任务变为最高优先级的就绪态任务，它开始运行
- t4：现在，HMI任务、CAN任务的优先级都比接收任务高，它们都在等待队列有空闲的空间；一旦接收任务读出1个数据，会马上被抢占。被谁抢占？谁等待最久？HMI任务！所以在t4时刻，切换到HMI任务。
- t5：HMI任务向队列写入第6个数据，然后再次阻塞，这是CAN任务已经阻塞很久了。接收任务变为最高优先级的就绪态任务，开始执行。
- t6：现在，HMI任务、CAN任务的优先级都比接收任务高，它们都在等待队列有空闲的空间；一旦接收任务读出1个数据，会马上被抢占。被谁抢占？谁等待最久？CAN任务！所以在t6时刻，切换到CAN任务。
- t7：CAN任务向队列写入数据，因为仅仅有一个空间供写入，所以它马上再次进入阻塞状态。这时HMI任务、CAN任务都在等待空闲空间，只有接收任务可以继续执行。





![img](https://pic1.zhimg.com/80/v2-2ab5df2aef0c87f75bcbaca42f055c0c_720w.webp)



### 5.5 示例10: 传输大块数据

本节代码为：`FreeRTOS_10_queue_bigtransfer`。

FreeRTOS的队列使用拷贝传输，也就是要传输uint32_t时，把4字节的数据拷贝进队列；要传输一个8字节的结构体时，把8字节的数据拷贝进队列。

如果要传输1000字节的结构体呢？写队列时拷贝1000字节，读队列时再拷贝1000字节？不建议这么做，影响效率！

这时候，我们要传输的是这个巨大结构体的地址：把它的地址写入队列，对方从队列得到这个地址，使用地址去访问那1000字节的数据。

使用地址来间接传输数据时，这些数据放在RAM里，对于这块RAM，要保证这几点：



- RAM的所有者、操作者，必须清晰明了
  这块内存，就被称为"共享内存"。要确保不能同时修改RAM。比如，在写队列之前只有由发送者修改这块RAM，在读队列之后只能由接收者访问这块RAM。
- RAM要保持可用
  这块RAM应该是全局变量，或者是动态分配的内存。对于动然分配的内存，要确保它不能提前释放：要等到接收者用完后再释放。另外，不能是局部变量。



`FreeRTOS_10_queue_bigtransfer`程序会创建一个队列，然后创建1个发送任务、1个接收任务：



- 创建的队列：长度为1，用来传输"char *"指针
- 发送任务优先级为1，在字符数组中写好数据后，把它的地址写入队列
- 接收任务优先级为2，读队列得到"char *"值，把它打印出来



这个程序故意设置接收任务的优先级更高，在它访问数组的过程中，接收任务无法执行、无法写这个数组。

main函数中创建了队列、创建了发送任务、接收任务，代码如下：

```text
/* 定义一个字符数组 */
static char pcBuffer[100];


/* vSenderTask被用来创建2个任务，用于写队列
 * vReceiverTask被用来创建1个任务，用于读队列
 */
static void vSenderTask( void *pvParameters );
static void vReceiverTask( void *pvParameters );

/*-----------------------------------------------------------*/

/* 队列句柄, 创建队列时会设置这个变量 */
QueueHandle_t xQueue;

int main( void )
{
	prvSetupHardware();
	
    /* 创建队列: 长度为1，数据大小为4字节(存放一个char指针) */
    xQueue = xQueueCreate( 1, sizeof(char *) );

	if( xQueue != NULL )
	{
		/* 创建1个任务用于写队列
		 * 任务函数会连续执行，构造buffer数据，把buffer地址写入队列
		 * 优先级为1
		 */
		xTaskCreate( vSenderTask, "Sender", 1000, NULL, 1, NULL );

		/* 创建1个任务用于读队列
		 * 优先级为2, 高于上面的两个任务
		 * 这意味着读队列得到buffer地址后，本任务使用buffer时不会被打断
		 */
		xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建队列 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务的函数中，现在全局大数组pcBuffer中构造数据，然后把它的地址写入队列，代码如下：

```text
static void vSenderTask( void *pvParameters )
{
	BaseType_t xStatus;
	static int cnt = 0;
	
	char *buffer;

	/* 无限循环 */
	for( ;; )
	{
		sprintf(pcBuffer, "www.100ask.net Msg %d\r\n", cnt++);
		buffer = pcBuffer; // buffer变量等于数组的地址, 下面要把这个地址写入队列
		
		/* 写队列
		 * xQueue: 写哪个队列
		 * pvParameters: 写什么数据? 传入数据的地址, 会从这个地址把数据复制进队列
		 * 0: 如果队列满的话, 即刻返回
		 */
		xStatus = xQueueSendToBack( xQueue, &buffer, 0 ); /* 只需要写入4字节, 无需写入整个buffer */

		if( xStatus != pdPASS )
		{
			printf( "Could not send to the queue.\r\n" );
		}
	}
}
```

接收任务的函数中，读取队列、得到buffer的地址、打印，代码如下：

```text
static void vReceiverTask( void *pvParameters )
{
	/* 读取队列时, 用这个变量来存放数据 */
	char *buffer;
	const TickType_t xTicksToWait = pdMS_TO_TICKS( 100UL );	
	BaseType_t xStatus;

	/* 无限循环 */
	for( ;; )
	{
		/* 读队列
		 * xQueue: 读哪个队列
		 * &xReceivedStructure: 读到的数据复制到这个地址
		 * xTicksToWait: 没有数据就阻塞一会
		 */
		xStatus = xQueueReceive( xQueue, &buffer, xTicksToWait); /* 得到buffer地址，只是4字节 */

		if( xStatus == pdPASS )
		{
			/* 读到了数据 */
			printf("Get: %s", buffer);
		}
		else
		{
			/* 没读到数据 */
			printf( "Could not receive from the queue.\r\n" );
		}
	}
}
```

运行结果如下图所示：



![img](https://pic2.zhimg.com/80/v2-8280902439568ab0371ab61515619221_720w.webp)



### 5.6 示例11: 邮箱(Mailbox)

本节代码为：`FreeRTOS_11_queue_mailbox`。

FreeRTOS的邮箱概念跟别的RTOS不一样，这里的邮箱称为"橱窗"也许更恰当：



- 它是一个队列，队列长度只有1
- 写邮箱：新数据覆盖旧数据，在任务中使用`xQueueOverwrite()`，在中断中使用`xQueueOverwriteFromISR()`。
  既然是覆盖，那么无论邮箱中是否有数据，这些函数总能成功写入数据。
- 读邮箱：读数据时，数据不会被移除；在任务中使用`xQueuePeek()`，在中断中使用`xQueuePeekFromISR()`。
  这意味着，第一次调用时会因为无数据而阻塞，一旦曾经写入数据，以后读邮箱时总能成功。



main函数中创建了队列(队列长度为1)、创建了发送任务、接收任务：



- 发送任务的优先级为2，它先执行
- 接收任务的优先级为1



代码如下：

```text
/* 队列句柄, 创建队列时会设置这个变量 */
QueueHandle_t xQueue;

int main( void )
{
	prvSetupHardware();
	
    /* 创建队列: 长度为1，数据大小为4字节(存放一个char指针) */
    xQueue = xQueueCreate( 1, sizeof(uint32_t) );

	if( xQueue != NULL )
	{
		/* 创建1个任务用于写队列
		 * 任务函数会连续执行，构造buffer数据，把buffer地址写入队列
		 * 优先级为2
		 */
		xTaskCreate( vSenderTask, "Sender", 1000, NULL, 2, NULL );

		/* 创建1个任务用于读队列
		 * 优先级为1
		 */
		xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建队列 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务、接收任务的代码和执行流程如下：



- A：发送任务先执行，马上阻塞
- BC：接收任务执行，这是邮箱无数据，打印"Could not …"。在发送任务阻塞过程中，接收任务多次执行、多次打印。
- D：发送任务从阻塞状态退出，立刻执行、写队列
- E：发送任务再次阻塞
- FG、HI、……：接收任务不断"偷看"邮箱，得到同一个数据，打印出多个"Get: 0"
- J：发送任务从阻塞状态退出，立刻执行、覆盖队列，写入1
- K：发送任务再次阻塞
- LM、……：接收任务不断"偷看"邮箱，得到同一个数据，打印出多个"Get: 1"





![img](https://pic1.zhimg.com/80/v2-b5daea1da3480847ddf53102760b91dc_720w.webp)



运行结果如下图所示：

![img](https://pic4.zhimg.com/80/v2-4ec19230f1f7b533c323faa1f8c72b0f_720w.webp)



## 6 信号量(semaphore)

### 概述

前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。

有时候我们只需要传递状态，并不需要传递具体的信息，比如：



- 我的事做完了，通知一下你
- 卖包子了、卖包子了，做好了1个包子！做好了2个包子！做好了3个包子！
- 这个停车位我占了，你们只能等着



在这种情况下我们可以使用信号量(semaphore)，它更节省内存。

本章涉及如下内容：



- 怎么创建、删除信号量
- 怎么发送、获得信号量
- 什么是计数型信号量？什么是二进制信号量？



### 6.1 信号量的特性

#### 6.1.1 信号量的常规操作

信号量这个名字很恰当：



- 信号：起通知作用

- 量：还可以用来表示资源的数量

- - 当"量"没有限制时，它就是"计数型信号量"(Counting Semaphores)
  - 当"量"只有0、1两个取值时，它就是"二进制信号量"(Binary Semaphores)



- 支持的动作："give"给出资源，计数值加1；"take"获得资源，计数值减1



计数型信号量的典型场景是：



- 计数：事件产生时"give"信号量，让计数值加1；处理事件时要先"take"信号量，就是获得信号量，让计数值减1。
- 资源管理：要想访问资源需要先"take"信号量，让计数值减1；用完资源后"give"信号量，让计数值加1。



信号量的"give"、"take"双方并不需要相同，可以用于生产者-消费者场合：



- 生产者为任务A、B，消费者为任务C、D

- 一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果：

- - 阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间)
  - 即刻返回失败：不等



- 任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒
- 唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人



二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。



![img](https://pic2.zhimg.com/80/v2-2686e45514098ef3e8b6c46b52be9ecd_720w.webp)



#### 6.1.2 信号量跟队列的对比

差异列表如下：

![img](https://pic4.zhimg.com/80/v2-eece095763c849abb8c1ffa5a76e515b_720w.webp)

#### 6.1.3 两种信号量的对比

信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。

差别列表如下：

![img](https://pic4.zhimg.com/80/v2-6f4cee147ece20280e549431e3f35953_720w.webp)

### 6.2 信号量函数

使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。

#### 6.2.1 创建

使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。

对于二进制信号量、计数型信号量，它们的创建函数不一样：

![img](https://pic3.zhimg.com/80/v2-872cfb928bfbd79ef84702c07717b232_720w.webp)

创建二进制信号量的函数原型如下：

```text
* 创建一个二进制信号量，返回它的句柄。
 * 此函数内部会分配信号量结构体 
 * 返回值: 返回句柄，非NULL表示成功
 */
SemaphoreHandle_t xSemaphoreCreateBinary( void );

/* 创建一个二进制信号量，返回它的句柄。
 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针
 * 返回值: 返回句柄，非NULL表示成功
 */
SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer );
```

创建计数型信号量的函数原型如下：

```text
/* 创建一个计数型信号量，返回它的句柄。
 * 此函数内部会分配信号量结构体 
 * uxMaxCount: 最大计数值
 * uxInitialCount: 初始计数值
 * 返回值: 返回句柄，非NULL表示成功
 */
SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);

/* 创建一个计数型信号量，返回它的句柄。
 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针
 * uxMaxCount: 最大计数值
 * uxInitialCount: 初始计数值
 * pxSemaphoreBuffer: StaticSemaphore_t结构体指针
 * 返回值: 返回句柄，非NULL表示成功
 */
SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, 
                                                 UBaseType_t uxInitialCount, 
                                                 StaticSemaphore_t *pxSemaphoreBuffer );
```

#### 6.2.2 删除

对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。

vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：

```text
/*
 * xSemaphore: 信号量句柄，你要删除哪个信号量
 */
void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );
```

#### 6.2.3 give/take

二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：



![img](https://pic2.zhimg.com/80/v2-d7d33d520ef059a926d518454442638d_720w.webp)

xSemaphoreGive的函数原型如下：

```text
BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );
```

xSemaphoreGive函数的参数与返回值列表如下：

![img](https://pic4.zhimg.com/80/v2-70e5470047f544a9faa8701cba42057b_720w.webp)

pxHigherPriorityTaskWoken的函数原型如下：

```text
BaseType_t xSemaphoreGiveFromISR(
                        SemaphoreHandle_t xSemaphore,
                        BaseType_t *pxHigherPriorityTaskWoken
                    );
```

xSemaphoreGiveFromISR函数的参数与返回值列表如下：

![img](https://pic2.zhimg.com/80/v2-27f32bd41ab6214ab101685fae5403d1_720w.webp)

xSemaphoreTake的函数原型如下：

```text
BaseType_t xSemaphoreTake(
                   SemaphoreHandle_t xSemaphore,
                   TickType_t xTicksToWait
               );
```

xSemaphoreTake函数的参数与返回值列表如下：

![img](https://pic4.zhimg.com/80/v2-49209c7843fbea2aa1e2506b6cd70833_720w.webp)

xSemaphoreTakeFromISR的函数原型如下：

```text
BaseType_t xSemaphoreTakeFromISR(
                        SemaphoreHandle_t xSemaphore,
                        BaseType_t *pxHigherPriorityTaskWoken
                    );
```

xSemaphoreTakeFromISR函数的参数与返回值列表如下：

![img](https://pic4.zhimg.com/80/v2-c1dc5565c2ce3d616167d1f5a33f6177_720w.webp)

### 6.3 示例12: 使用二进制信号量来同步

本节代码为： `FreeRTOS_12_semaphore_binary` 。

main函数中创建了一个二进制信号量，然后创建2个任务：一个用于释放信号量，另一个用于获取信号量，代码如下：

```text
/* 二进制信号量句柄 */
SemaphoreHandle_t xBinarySemaphore;

int main( void )
{
	prvSetupHardware();
	
    /* 创建二进制信号量 */
    xBinarySemaphore = xSemaphoreCreateBinary( );

	if( xBinarySemaphore != NULL )
	{
		/* 创建1个任务用于释放信号量
		 * 优先级为2
		 */
		xTaskCreate( vSenderTask, "Sender", 1000, NULL, 2, NULL );

		/* 创建1个任务用于获取信号量
		 * 优先级为1
		 */
		xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建二进制信号量 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务、接收任务的代码和执行流程如下：



- A：发送任务优先级高，先执行。连续3次释放二进制信号量，只有第1次成功
- B：发送任务进入阻塞态
- C：接收任务得以执行，得到信号量，打印OK；再次去获得信号量时，进入阻塞状态
- 在发送任务的vTaskDelay退出之前，运行的是空闲任务：现在发送任务、接收任务都阻塞了
- D：发送任务再次运行，连续3次释放二进制信号量，只有第1次成功
- E：发送任务进入阻塞态
- F：接收任务被唤醒，得到信号量，打印OK；再次去获得信号量时，进入阻塞状态





![img](https://pic3.zhimg.com/80/v2-3876e831de664332f7b217abaaaa2402_720w.webp)



运行结果如下图所示，即使发送任务连续释放多个信号量，也只能成功1次。释放、获得信号量是一一对应的。



![img](https://pic3.zhimg.com/80/v2-5bffec02faca78282ed00b8a477bd4aa_720w.webp)



### 6.4 示例13: 防止数据丢失

本节代码为： `FreeRTOS_13_semaphore_circle_buffer` 。

在示例12中，发送任务发出3次"提醒"，但是接收任务只接收到1次"提醒"，其中2次"提醒"丢失了。

这种情况很常见，比如每接收到一个串口字符，串口中断程序就给任务发一次"提醒"，假设收到多个字符、发出了多次"提醒"。当任务来处理时，它只能得到1次"提醒"。

你需要使用其他方法来防止数据丢失，比如：



- 在串口中断中，把数据放入缓冲区
- 在任务中，一次性把缓冲区中的数据都读出
- 简单地说，就是：你提醒了我多次，我太忙只响应你一次，但是我一次性拿走所有数据



main函数中创建了一个二进制信号量，然后创建2个任务：一个用于释放信号量，另一个用于获取信号量，代码如下：

```text
/* 二进制信号量句柄 */
SemaphoreHandle_t xBinarySemaphore;

int main( void )
{
	prvSetupHardware();
	
    /* 创建二进制信号量 */
    xBinarySemaphore = xSemaphoreCreateBinary( );

	if( xBinarySemaphore != NULL )
	{
		/* 创建1个任务用于释放信号量
		 * 优先级为2
		 */
		xTaskCreate( vSenderTask, "Sender", 1000, NULL, 2, NULL );

		/* 创建1个任务用于获取信号量
		 * 优先级为1
		 */
		xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建二进制信号量 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务、接收任务的代码和执行流程如下：



- A：发送任务优先级高，先执行。连续写入3个数据、释放3个信号量：只有1个信号量起作用
- B：发送任务进入阻塞态
- C：接收任务得以执行，得到信号量
- D：接收任务一次性把所有数据取出
- E：接收任务再次尝试获取信号量，进入阻塞状态
- 在发送任务的vTaskDelay退出之前，运行的是空闲任务：现在发送任务、接收任务都阻塞了
- F：发送任务再次运行，连续写入3个数据、释放3个信号量：只有1个信号量起作用
- G：发送任务进入阻塞态
- H：接收任务被唤醒，得到信号量，一次性把所有数据取出





![img](https://pic1.zhimg.com/80/v2-836988edc4b0e83a4b31aa546ea716e0_720w.webp)



程序运行结果如下，数据未丢失：



![img](https://pic3.zhimg.com/80/v2-d87448ae06bcd00e6f7e82860f7812ea_720w.webp)



### 6.5 示例14: 使用计数型信号量

本节代码为： `FreeRTOS_14_semaphore_counting` 。

使用计数型信号量时，可以多次释放信号量；当信号量的技术值达到最大时，再次释放信号量就会出错。

如果信号量计数值为n，就可以连续n次获取信号量，第(n+1)次获取信号量就会阻塞或失败。

main函数中创建了一个计数型信号量，最大计数值为3，初始值计数值为0；然后创建2个任务：一个用于释放信号量，另一个用于获取信号量，代码如下：

```text
/* 计数型信号量句柄 */
SemaphoreHandle_t xCountingSemaphore;

int main( void )
{
	prvSetupHardware();
	
    /* 创建计数型信号量 */
    xCountingSemaphore = xSemaphoreCreateCounting(3, 0);

	if( xCountingSemaphore != NULL )
	{
		/* 创建1个任务用于释放信号量
		 * 优先级为2
		 */
		xTaskCreate( vSenderTask, "Sender", 1000, NULL, 2, NULL );

		/* 创建1个任务用于获取信号量
		 * 优先级为1
		 */
		xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建信号量 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务、接收任务的代码和执行流程如下：

- A：发送任务优先级高，先执行。连续释放4个信号量：只有前面3次成功，第4次失败
- B：发送任务进入阻塞态
- CDE：接收任务得以执行，得到3个信号量
- F：接收任务试图获得第4个信号量时进入阻塞状态
- 在发送任务的vTaskDelay退出之前，运行的是空闲任务：现在发送任务、接收任务都阻塞了
- G：发送任务再次运行，连续释放4个信号量：只有前面3次成功，第4次失败
- H：发送任务进入阻塞态
- IJK：接收任务得以执行，得到3个信号量
- L：接收任务再次获取信号量时进入阻塞状态



![img](https://pic4.zhimg.com/80/v2-3dc34d88db4ed705abb19fe6efb94593_720w.webp)



运行结果如下图所示：

![img](https://pic3.zhimg.com/80/v2-19da8a73107cae8a96c93443a819e416_720w.webp)



## 7 互斥量(mutex)

### 概述

怎么独享厕所？自己开门上锁，完事了自己开锁。

你当然可以进去后，让别人帮你把门：但是，命运就掌握在别人手上了。

使用队列、信号量，都可以实现互斥访问，以信号量为例：



- 信号量初始值为1
- 任务A想上厕所，"take"信号量成功，它进入厕所
- 任务B也想上厕所，"take"信号量不成功，等待
- 任务A用完厕所，"give"信号量；轮到任务B使用



这需要有2个前提：



- 任务B很老实，不撬门(一开始不"give"信号量)
- 没有坏人：别的任务不会"give"信号量



可以看到，使用信号量确实也可以实现互斥访问，但是不完美。

使用互斥量可以解决这个问题，互斥量的名字取得很好：



- 量：值为0、1
- 互斥：用来实现互斥访问



它的核心在于：谁上锁，就只能由谁开锁。

很奇怪的是，FreeRTOS的互斥锁，并没有在代码上实现这点：



- 即使任务A获得了互斥锁，任务B竟然也可以释放互斥锁。
- 谁上锁、谁释放：只是约定。



本章涉及如下内容：



- 为什么要实现互斥操作
- 怎么使用互斥量
- 互斥量导致的优先级反转、优先级继承



### 7.1 互斥量的使用场合

在多任务系统中，任务A正在使用某个资源，还没用完的情况下任务B也来使用的话，就可能导致问题。

比如对于串口，任务A正使用它来打印，在打印过程中任务B也来打印，客户看到的结果就是A、B的信息混杂在一起。

这种现象很常见：



- 访问外设：刚举的串口例子
- 读、修改、写操作导致的问题
  对于同一个变量，比如`int a`，如果有两个任务同时写它就有可能导致问题。
  对于变量的修改，C代码只有一条语句，比如：`a=a+8;`，它的内部实现分为3步：读出原值、修改、写入。





![img](https://pic3.zhimg.com/80/v2-cc4c98a7c5a0ccd6337372c28d79f92a_720w.webp)



我们想让任务A、B都执行add_a函数，a的最终结果是`1+8+8=17`。
假设任务A运行完代码①，在执行代码②之前被任务B抢占了：现在任务A的R0等于1。
任务B执行完add_a函数，a等于9。
任务A继续运行，在代码②处R0仍然是被抢占前的数值1，执行完②③的代码，a等于9，这跟预期的17不符合。



- 对变量的非原子化访问
  修改变量、设置结构体、在16位的机器上写32位的变量，这些操作都是非原子的。也就是它们的操作过程都可能被打断，如果被打断的过程有其他任务来操作这些变量，就可能导致冲突。
- 函数重入
  “可重入的函数"是指：多个任务同时调用它、任务和中断同时调用它，函数的运行也是安全的。可重入的函数也被称为"线程安全”(thread safe)。
  每个任务都维持自己的栈、自己的CPU寄存器，如果一个函数只使用局部变量，那么它就是线程安全的。
  函数中一旦使用了全局变量、静态变量、其他外设，它就不是"可重入的"，如果改函数正在被调用，就必须阻止其他任务、中断再次调用它。



上述问题的解决方法是：任务A访问这些全局变量、函数代码时，独占它，就是上个锁。这些全局变量、函数代码必须被独占地使用，它们被称为临界资源。

互斥量也被称为互斥锁，使用过程如下：



- 互斥量初始值为1
- 任务A想访问临界资源，先获得并占有互斥量，然后开始访问
- 任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞
- 任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源
- 任务B使用完毕，释放互斥量



正常来说：在任务A占有互斥量的过程中，任务B、任务C等等，都无法释放互斥量。

但是FreeRTOS未实现这点：任务A占有互斥量的情况下，任务B也可释放互斥量。

### 7.2 互斥量函数

#### 7.2.1 创建

互斥量是一种特殊的二进制信号量。

使用互斥量时，先创建、然后去获得、释放它。使用句柄来表示一个互斥量。

创建互斥量的函数有2种：动态分配内存，静态分配内存，函数原型如下：

```text
/* 创建一个互斥量，返回它的句柄。
 * 此函数内部会分配互斥量结构体 
 * 返回值: 返回句柄，非NULL表示成功
 */
SemaphoreHandle_t xSemaphoreCreateMutex( void );

/* 创建一个互斥量，返回它的句柄。
 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针
 * 返回值: 返回句柄，非NULL表示成功
 */
SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer );
```

要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义：

```text
#define configUSE_MUTEXES 1
```

#### 7.2.2 其他函数

要注意的是，互斥量不能在ISR中使用。

各类操作函数，比如删除、give/take，跟一般是信号量是一样的。

```text
/*
 * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量
 */
void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );

/* 释放 */
BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );

/* 释放(ISR版本) */
BaseType_t xSemaphoreGiveFromISR(
                       SemaphoreHandle_t xSemaphore,
                       BaseType_t *pxHigherPriorityTaskWoken
                   );

/* 获得 */
BaseType_t xSemaphoreTake(
                   SemaphoreHandle_t xSemaphore,
                   TickType_t xTicksToWait
               );
/* 获得(ISR版本) */
xSemaphoreGiveFromISR(
                       SemaphoreHandle_t xSemaphore,
                       BaseType_t *pxHigherPriorityTaskWoken
                   );
```

### 7.3 示例15: 互斥量基本使用

本节代码为： `FreeRTOS_15_mutex` 。

使用互斥量时有如下特点：



- 刚创建的互斥量可以被成功"take"
- “take"互斥量成功的任务，被称为"holder”，只能由它"give"互斥量；别的任务"give"不成功
- 在ISR中不能使用互斥量



本程序创建2个发送任务：故意发送大量的字符。可以做2个实验：



- 使用互斥量：可以看到任务1、任务2打印的字符串没有混杂在一起
- 不使用互斥量：任务1、任务2打印的字符串混杂在一起



main函数代码如下：

```text
/* 互斥量句柄 */
SemaphoreHandle_t xMutex;

int main( void )
{
	prvSetupHardware();
	
    /* 创建互斥量 */
    xMutex = xSemaphoreCreateMutex( );


	if( xMutex != NULL )
	{
		/* 创建2个任务: 都是打印
		 * 优先级相同
		 */
		xTaskCreate( vSenderTask, "Sender1", 1000, (void *)1, 1, NULL );
		xTaskCreate( vSenderTask, "Sender2", 1000, (void *)2, 1, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建互斥量 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务的函数如下：

```text
static void vSenderTask( void *pvParameters )
{
	const TickType_t xTicksToWait = pdMS_TO_TICKS( 10UL );	
	int cnt = 0;
	int task = (int)pvParameters;
	int i;
	char c;
	
	/* 无限循环 */
	for( ;; )
	{	
		/* 获得互斥量: 上锁 */
		xSemaphoreTake(xMutex, portMAX_DELAY);
		
		printf("Task %d use UART count: %d, ", task, cnt++);
		c = (task == 1 ) ? 'a' : 'A';
		for (i = 0; i < 26; i++)
			printf("%c", c + i);
		printf("\r\n");
		
		/* 释放互斥量: 开锁 */
		xSemaphoreGive(xMutex);
		
		vTaskDelay(xTicksToWait);
	}
}
```

可以做两个实验：vSenderTask函数的for循环中xSemaphoreTake和xSemaphoreGive这2句代码保留、不保留



- 保留：实验现象如下图左边，任务1、任务2的打印信息没有混在一起
- 不保留：实验现象如下图右边，打印信息混杂在一起



程序运行结果如下图所示：



![img](https://pic2.zhimg.com/80/v2-db920ad56e9eb735b34099d4e99a9445_720w.webp)



### 7.4 示例16: 谁上锁就由谁解锁？

互斥量、互斥锁，本来的概念确实是：谁上锁就得由谁解锁。

但是FreeRTOS并没有实现这点，只是要求程序员按照这样的惯例写代码。

本节代码为： `FreeRTOS_16_mutex_who_give` 。

main函数创建了2个任务：



- 任务1：高优先级，一开始就获得互斥锁，永远不释放。
- 任务2：任务1阻塞时它开始执行，它先尝试获得互斥量，失败的话就监守自盗(释放互斥量、开锁)，然后再上锁



代码如下：

```text
int main( void )
{
	prvSetupHardware();
	
    /* 创建互斥量 */
    xMutex = xSemaphoreCreateMutex( );

	if( xMutex != NULL )
	{
		/* 创建2个任务: 一个上锁, 另一个自己监守自盗(开别人的锁自己用)
		 */
		xTaskCreate( vTakeTask, "Task1", 1000, NULL, 2, NULL );
		xTaskCreate( vGiveAndTakeTask, "Task2", 1000, NULL, 1, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建互斥量 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

两个任务的代码和执行流程如下图所示：



- A：任务1的优先级高，先运行，立刻上锁
- B：任务1阻塞
- C：任务2开始执行，尝试获得互斥量(上锁)，超时时间设为0。根据返回值打印出：上锁失败
- D：任务2监守自盗，开锁，成功！
- E：任务2成功获得互斥量
- F：任务2阻塞



可见，任务1上的锁，被任务2解开了。所以，FreeRTOS并没有实现"谁上锁就得由谁开锁"的功能。



![img](https://pic1.zhimg.com/80/v2-080c1dac3c9c563b9eda61aae30c1b60_720w.webp)



程序运行结果如下图所示：



![img](https://pic3.zhimg.com/80/v2-95af1cb5b63d623ea5b0c479712d97d6_720w.webp)



### 7.5 示例17: 优先级反转

假设任务A、B都想使用串口，A优先级比较低：



- 任务A获得了串口的互斥量
- 任务B也想使用串口，它将会阻塞、等待A释放互斥量
- 高优先级的任务，被低优先级的任务延迟，这被称为"优先级反转"(priority inversion)



如果涉及3个任务，可以让"优先级反转"的后果更加恶劣。

本节代码为： `FreeRTOS_17_mutex_inversion` 。

互斥量可以通过"优先级继承"，可以很大程度解决"优先级反转"的问题，这也是FreeRTOS中互斥量和二级制信号量的差别。

本节程序使用二级制信号量来演示"优先级反转"的恶劣后果。

main函数创建了3个任务：LPTask/MPTask/HPTask(低/中/高优先级任务)，代码如下：

```text
/* 互斥量/二进制信号量句柄 */
SemaphoreHandle_t xLock;

int main( void )
{
	prvSetupHardware();
	
    /* 创建互斥量/二进制信号量 */
    xLock = xSemaphoreCreateBinary( );


	if( xLock != NULL )
	{
		/* 创建3个任务: LP,MP,HP(低/中/高优先级任务)
		 */
		xTaskCreate( vLPTask, "LPTask", 1000, NULL, 1, NULL );
		xTaskCreate( vMPTask, "MPTask", 1000, NULL, 2, NULL );
		xTaskCreate( vHPTask, "HPTask", 1000, NULL, 3, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建互斥量/二进制信号量 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

LPTask/MPTask/HPTask三个任务的代码和运行过程如下图所示：

- A：HPTask优先级最高，它最先运行。在这里故意打印，这样才可以观察到flagHPTaskRun的脉冲。
- HP Delay：HPTask阻塞
- B：MPTask开始运行。在这里故意打印，这样才可以观察到flagMPTaskRun的脉冲。
- MP Delay：MPTask阻塞
- C：LPTask开始运行，获得二进制信号量，然后故意打印很多字符
- D：HP Delay时间到，HPTask恢复运行，它无法获得二进制信号量，一直阻塞等待
- E：MP Delay时间到，MPTask恢复运行，它比LPTask优先级高，一直运行。导致LPTask无法运行，自然无法释放二进制信号量，于是HPTask用于无法运行。



总结：



- LPTask先持有二进制信号量，
- 但是MPTask抢占LPTask，是的LPTask一直无法运行也就无法释放信号量，
- 导致HPTask任务无法运行
- 优先级最高的HPTask竟然一直无法运行！





![img](https://pic1.zhimg.com/80/v2-34573c04ff2acfc8747e6a79c01baa84_720w.webp)



程序运行的时序图如下：



![img](https://pic2.zhimg.com/80/v2-8567c736b08874c74289c7d23fdfadf1_720w.webp)



### 7.6 示例18: 优先级继承

本节代码为： `FreeRTOS_18_mutex_inheritance` 。

示例17的问题在于，LPTask低优先级任务获得了锁，但是它优先级太低而无法运行。

如果能提升LPTask任务的优先级，让它能尽快运行、释放锁，"优先级反转"的问题不就解决了吗？

把LPTask任务的优先级提升到什么水平？

优先级继承：



- 假设持有互斥锁的是任务A，如果更高优先级的任务B也尝试获得这个锁
- 任务B说：你既然持有宝剑，又不给我，那就继承我的愿望吧
- 于是任务A就继承了任务B的优先级
- 这就叫：优先级继承
- 等任务A释放互斥锁时，它就恢复为原来的优先级
- 互斥锁内部就实现了优先级的提升、恢复



本节源码是在`FreeRTOS_17_mutex_inversion` 的代码上做了一些简单修改：

```text
int main( void )
{
	prvSetupHardware();
	
    /* 创建互斥量/二进制信号量 */
    //xLock = xSemaphoreCreateBinary( );
	xLock = xSemaphoreCreateMutex( );
```

运行时序图如下图所示：



- A：HPTask执行`xSemaphoreTake(xLock, portMAX_DELAY);`，它的优先级被LPTask继承
- B：LPTask抢占MPTask，运行
- C：LPTask执行`xSemaphoreGive(xLock);`，它的优先级恢复为原来值
- D：HPTask得到互斥锁，开始运行
- 互斥锁的"优先级继承"，可以减小"优先级反转"的影响





![img](https://pic3.zhimg.com/80/v2-2426b37ca69f146e4c94d65a0ea2ed3a_720w.webp)



### 7.7 递归锁

#### 7.7.1 死锁的概念

日常生活的死锁：我们只招有工作经验的人！我没有工作经验怎么办？那你就去找工作啊！

假设有2个互斥量M1、M2，2个任务A、B：



- A获得了互斥量M1
- B获得了互斥量M2
- A还要获得互斥量M2才能运行，结果A阻塞
- B还要获得互斥量M1才能运行，结果B阻塞
- A、B都阻塞，再无法释放它们持有的互斥量
- 死锁发生！



#### 7.7.2 自我死锁

假设这样的场景：



- 任务A获得了互斥锁M
- 它调用一个库函数
- 库函数要去获取同一个互斥锁M，于是它阻塞：任务A休眠，等待任务A来释放互斥锁！
- 死锁发生！



#### 7.7.3 函数

怎么解决这类问题？可以使用递归锁(Recursive Mutexes)，它的特性如下：



- 任务A获得递归锁M后，它还可以多次去获得这个锁
- "take"了N次，要"give"N次，这个锁才会被释放



递归锁的函数根一般互斥量的函数名不一样，参数类型一样，列表如下：

![img](https://pic2.zhimg.com/80/v2-782d42f4889e85978b7363c66eb8ebb5_720w.webp)

函数原型如下：

```text
/* 创建一个递归锁，返回它的句柄。
 * 此函数内部会分配互斥量结构体 
 * 返回值: 返回句柄，非NULL表示成功
 */
SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void );


/* 释放 */
BaseType_t xSemaphoreGiveRecursive( SemaphoreHandle_t xSemaphore );

/* 获得 */
BaseType_t xSemaphoreTakeRecursive(
                   SemaphoreHandle_t xSemaphore,
                   TickType_t xTicksToWait
               );
```

#### 7.7.4 示例19: 递归锁

本节代码为： `FreeRTOS_19_mutex_recursive` 。

递归锁实现了：谁上锁就由谁解锁。

本程序从`FreeRTOS_16_mutex_who_give`修改得来，它的main函数里创建了2个任务



- 任务1：高优先级，一开始就获得递归锁，然后故意等待很长时间，让任务2运行
- 任务2：低优先级，看看能否操作别人持有的锁



main函数代码如下：

```text
/* 递归锁句柄 */
SemaphoreHandle_t xMutex;

int main( void )
{
	prvSetupHardware();
	
    /* 创建递归锁 */
    xMutex = xSemaphoreCreateRecursiveMutex( );

	if( xMutex != NULL )
	{
		/* 创建2个任务: 一个上锁, 另一个自己监守自盗(看看能否开别人的锁自己用)
		 */
		xTaskCreate( vTakeTask, "Task1", 1000, NULL, 2, NULL );
		xTaskCreate( vGiveAndTakeTask, "Task2", 1000, NULL, 1, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建递归锁 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

两个任务经过精细设计，代码和运行流程如下图所示：



- A：任务1优先级最高，先运行，获得递归锁
- B：任务1阻塞，让任务2得以运行
- C：任务2运行，看看能否获得别人持有的递归锁：不能
- D：任务2故意执行"give"操作，看看能否释放别人持有的递归锁：不能
- E：任务2等待递归锁
- F：任务1阻塞时间到后继续运行，使用循环多次获得、释放递归锁
- 递归锁在代码上实现了：谁持有递归锁，必须由谁释放。





![img](https://pic3.zhimg.com/80/v2-fc786cd7391c56fa3094829be8971246_720w.webp)



程序运行结果如下图所示：

![img](https://pic1.zhimg.com/80/v2-a21c786c5408550f1f9d98968eb443ec_720w.webp)



### 7.8 常见问题

使用互斥量的两个任务是相同优先级时的注意事项。



## 8 事件组(event group)

### 概述

学校组织秋游，组长在等待：



- 张三：我到了
- 李四：我到了
- 王五：我到了
- 组长说：好，大家都到齐了，出发！



秋游回来第二天就要提交一篇心得报告，组长在焦急等待：张三、李四、王五谁先写好就交谁的。

在这个日常生活场景中：



- 出发：要等待这3个人都到齐，他们是"与"的关系
- 交报告：只需等待这3人中的任何一个，他们是"或"的关系



在FreeRTOS中，可以使用事件组(event group)来解决这些问题。

本章涉及如下内容：



- 事件组的概念与操作函数
- 事件组的优缺点
- 怎么设置、等待、清除事件组中的位
- 使用事件组来同步多个任务



### 8.1 事件组概念与操作

#### 8.1.1 事件组的概念

事件组可以简单地认为就是一个整数：



- 的每一位表示一个事件
- 每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下
- 这些位，值为1表示事件发生了，值为0表示事件没发生
- 一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位
- 可以等待某一位、某些位中的任意一个，也可以等待多位





![img](https://pic3.zhimg.com/80/v2-e529331919768dbe60ad09a6682825ba_720w.webp)



事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？



- 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件

- 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件

- configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑

- - 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位
  - 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位





#### 8.1.2 事件组的操作

事件组和队列、信号量等不太一样，主要集中在2个地方：



- 唤醒谁？

- - 队列、信号量：事件发生时，只会唤醒一个任务
  - 事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有"广播"的作用



- 是否清除事件？

- - 队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了
  - 事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件





以上图为列，事件组的常规操作如下：



- 先创建事件组

- 任务C、D等待事件：

- - 等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是"或"、"与"的关系。
  - 得到事件时，要不要清除？可选择清除、不清除。



- 任务A、B产生事件：设置事件组里的某一位、某些位



### 8.2 事件组函数

#### 8.2.1 创建

使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。

有两种创建方法：动态分配内存、静态分配内存。函数原型如下：

```text
/* 创建一个事件组，返回它的句柄。
 * 此函数内部会分配事件组结构体 
 * 返回值: 返回句柄，非NULL表示成功
 */
EventGroupHandle_t xEventGroupCreate( void );

/* 创建一个事件组，返回它的句柄。
 * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针
 * 返回值: 返回句柄，非NULL表示成功
 */
EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer );
```

#### 8.2.2 删除

对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。

vEventGroupDelete可以用来删除事件组，函数原型如下：

```text
/*
 * xEventGroup: 事件组句柄，你要删除哪个事件组
 */
void vEventGroupDelete( EventGroupHandle_t xEventGroup )
```

#### 8.2.3 设置事件

可以设置事件组的某个位、某些位，使用的函数有2个：



- 在任务中使用`xEventGroupSetBits()`
- 在ISR中使用`xEventGroupSetBitsFromISR()`



有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。

函数原型如下：

```text
/* 设置事件组中的位
 * xEventGroup: 哪个事件组
 * uxBitsToSet: 设置哪些位? 
 *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1
 *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0
 * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)
 */
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                    const EventBits_t uxBitsToSet );


/* 设置事件组中的位
 * xEventGroup: 哪个事件组
 * uxBitsToSet: 设置哪些位? 
 *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1
 *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0
 * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有
 * 返回值: pdPASS-成功, pdFALSE-失败
 */
BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,
									  const EventBits_t uxBitsToSet,
									  BaseType_t * pxHigherPriorityTaskWoken );
```

值得注意的是，ISR中的函数，比如队列函数`xQueueSendToBackFromISR`、信号量函数`xSemaphoreGiveFromISR`，它们会唤醒某个任务，最多只会唤醒1个任务。

但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以`xEventGroupSetBitsFromISR`函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。

如果后台任务的优先级比当前被中断的任务优先级高，`xEventGroupSetBitsFromISR`会设置`*pxHigherPriorityTaskWoken`为pdTRUE。

如果daemon task成功地把队列数据发送给了后台任务，那么`xEventGroupSetBitsFromISR`的返回值就是pdPASS。

#### 8.2.4 等待事件

使用`xEventGroupWaitBits`来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。

函数原型如下：

```text
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait );
```

先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫"unblock condition"，非阻塞条件，或称为"非阻塞条件成立"；当"非阻塞条件成立"后，该任务就可以变为就绪态。

函数参数说明列表如下：

![img](https://pic1.zhimg.com/80/v2-6b1439e88d407c321394bf506e265e84_720w.webp)

举例如下：

![img](https://pic2.zhimg.com/80/v2-7ea0130e34c626e71b38d6bcc2c73bc5_720w.webp)

你可以使用`xEventGroupWaitBits()`等待期望的事件，它发生之后再使用`xEventGroupClearBits()`来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。

可以使用设置`xClearOnExit`为pdTRUE，使得对事件组的测试、清零都在`xEventGroupWaitBits()`函数内部完成，这是一个原子操作。

#### 8.2.5 同步点

有一个事情需要多个任务协同，比如：



- 任务A：炒菜
- 任务B：买酒
- 任务C：摆台
- A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭



使用`xEventGroupSync()`函数可以同步多个任务：



- 可以设置某位、某些位，表示自己做了什么事
- 可以等待某位、某些位，表示要等等其他任务
- 期望的时间发生后，`xEventGroupSync()`才会成功返回。
- `xEventGroupSync`成功返回后，会清除事件



`xEventGroupSync`函数原型如下：

```text
EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet,
                                const EventBits_t uxBitsToWaitFor,
                                TickType_t xTicksToWait );
```

参数列表如下：

![img](https://pic2.zhimg.com/80/v2-0cae4409df781ccd994610eb99224281_720w.webp)

### 8.3 示例20: 等待多个事件

本节源码是`FreeRTOS_20_event_group_wait_multi_events`。

要使用事件组，代码中要有如下操作：

```text
/* 1. 工程中添加event_groups.c */

/* 2. 源码中包含头文件 */
#include "event_groups.h"
```

假设大厨要等手下做完这些事才可以炒菜：洗菜、生火。

本程序创建3个任务：



- 任务1：洗菜
- 任务2：生火
- 任务3：炒菜。



main函数代码如下，它创建了3个任务：

```text
int main( void )
{
	prvSetupHardware();
	
    /* 创建递归锁 */
    xEventGroup = xEventGroupCreate( );

	if( xEventGroup != NULL )
	{
		/* 创建3个任务: 洗菜/生火/炒菜
		 */
		xTaskCreate( vWashingTask, "Task1", 1000, NULL, 1, NULL );
		xTaskCreate( vFiringTask,  "Task2", 1000, NULL, 2, NULL );
		xTaskCreate( vCookingTask, "Task3", 1000, NULL, 3, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建事件组 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

这3个任务的代码和执行流程如下：



- A："炒菜任务"优先级最高，先执行。它要等待的2个事件未发生：洗菜、生火，进入阻塞状态
- B："生火任务"接着执行，它要等待的1个事件未发生：洗菜，进入阻塞状态
- C："洗菜任务"接着执行，它洗好菜，发出事件：洗菜，然后调用F等待"炒菜"事件
- D："生火任务"等待的事件满足了，从B处继续执行，开始生火、发出"生火"事件
- E："炒菜任务"等待的事件满足了，从A出继续执行，开始炒菜、发出"炒菜"事件
- F："洗菜任务"等待的事件满足了，退出F、继续执行C



要注意的是，代码B处等待到"洗菜任务"后并不清除该事件，如果清除的话会导致"炒菜任务"无法执行。



![img](https://pic2.zhimg.com/80/v2-2092947473847508949e6dca4dec994d_720w.webp)



运行结果如下图所示：

[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GH1MFoqF-1637808522268)(pic/chap8/03_multi_events_result.png)]

### 8.3 示例21: 任务同步

本节代码是`FreeRTOS_21_event_group_task_sync`。

假设ABC三人要吃饭，各司其职：



- A：炒菜
- B：买酒
- C：摆台



三人都做完后，才可以开饭。

main函数代码如下，它创建了3个任务：

```text
int main( void )
{
	prvSetupHardware();
	
    /* 创建递归锁 */
    xEventGroup = xEventGroupCreate( );

	if( xEventGroup != NULL )
	{
		/* 创建3个任务: 洗菜/生火/炒菜
		 */
		xTaskCreate( vCookingTask, "task1", 1000, "A", 1, NULL );
		xTaskCreate( vBuyingTask,  "task2", 1000, "B", 2, NULL );
		xTaskCreate( vTableTask,   "task3", 1000, "C", 3, NULL );

		/* 启动调度器 */
		vTaskStartScheduler();
	}
	else
	{
		/* 无法创建事件组 */
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

被创建的3个任务，代码都很类似，以任务1为例：

```text
static void vCookingTask( void *pvParameters )
{
	const TickType_t xTicksToWait = pdMS_TO_TICKS( 100UL );		
	int i = 0;
	
	/* 无限循环 */
	for( ;; )
	{
        /* 做自己的事 */
		printf("%s is cooking %d time....\r\n", (char *)pvParameters, i);
		
		/* 表示我做好了, 还要等别人都做好 */
		xEventGroupSync(xEventGroup, COOKING, ALL, portMAX_DELAY);
	
		/* 别人也做好了, 开饭 */
		printf("%s is eating %d time....\r\n", (char *)pvParameters, i++);
		vTaskDelay(xTicksToWait);
	}
}
```

要点在于`xEventGroupSync`函数，它有3个功能：



- 设置事件：表示自己完成了某个、某些事件
- 等待事件：跟别的任务同步
- 成功返回后，清除"等待的事件"



运行结果如下图所示：



![img](https://pic2.zhimg.com/80/v2-2092947473847508949e6dca4dec994d_720w.webp)



## 9 任务通知(Task Notifications)

### 概述

所谓"任务通知"，你可以反过来读"通知任务"。

我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。

使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信：



![img](https://pic3.zhimg.com/80/v2-c0826a67b5121ddb03f368b22d8b6836_720w.webp)



使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的"通知"：



![img](https://pic4.zhimg.com/80/v2-543e08d56b2d261632daaf7f4cc671fb_720w.webp)



本章涉及如下内容：



- 任务通知：通知状态、通知值
- 任务通知的使用场合
- 任务通知的优势



### 9.1 任务通知的特性

#### 9.1.1 优势及限制

任务通知的优势：



- 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。
- 更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。



任务通知的限制：



- 不能发送数据给ISR：
  ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。
- 数据只能给该任务独享
  使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。
  在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。
- 无法缓冲数据
  使用队列时，假设队列深度为N，那么它可以保持N个数据。
  使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。
- 无法广播给多个任务
  使用事件组可以同时给多个任务发送事件。
  使用任务通知，只能发个一个任务。
- 如果发送受阻，发送方无法进入阻塞状态等待
  假设队列已经满了，使用`xQueueSendToBack()`给队列发送数据时，任务可以进入阻塞状态等待发送完成。
  使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。



#### 9.1.2 通知状态和通知值

每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：



- 一个是uint8_t类型，用来表示通知状态
- 一个是uint32_t类型，用来表示通知值



```text
typedef struct tskTaskControlBlock
{
    ......
    /* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */
    volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
    volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
    ......
} tskTCB;
```

通知状态有3种取值：



- taskNOT_WAITING_NOTIFICATION：任务没有在等待通知
- taskWAITING_NOTIFICATION：任务在等待通知
- taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)



```text
#define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  /* 也是初始状态 */
#define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
#define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )
```

通知值可以有很多种类型：



- 计数值
- 位(类似事件组)
- 任意数值



### 9.2 任务通知的使用

使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。

#### 9.2.1 两类函数

任务通知有2套函数，简化版、专业版，列表如下：



- 简化版函数的使用比较简单，它实际上也是使用专业版函数实现的
- 专业版函数支持很多参数，可以实现很多功能



![img](https://pic4.zhimg.com/80/v2-7490fcb67856c50e8fb83d80ebafe35f_720w.webp)



#### 9.2.2 xTaskNotifyGive/ulTaskNotifyTake

在任务中使用xTaskNotifyGive函数，在ISR中使用vTaskNotifyGiveFromISR函数，都是直接给其他任务发送通知：



- 使得通知值加一
- 并使得通知状态变为"pending"，也就是`taskNOTIFICATION_RECEIVED`，表示有数据了、待处理



可以使用ulTaskNotifyTake函数来取出通知值：



- 如果通知值等于0，则阻塞(可以指定超时时间)
- 当通知值大于0时，任务从阻塞态进入就绪态
- 在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零



使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。

这几个函数的原型如下：

```text
BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );

void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );

uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );
```

xTaskNotifyGive函数的参数说明如下：

![img](https://pic3.zhimg.com/80/v2-945257ea39996afe3db1f9ff55e082d2_720w.webp)

vTaskNotifyGiveFromISR函数的参数说明如下：

![img](https://pic2.zhimg.com/80/v2-bfa4c7a3395ccfa6ad7681f3fe8b7b79_720w.webp)

ulTaskNotifyTake函数的参数说明如下：

![img](https://pic3.zhimg.com/80/v2-081c6dd11c0133dab9689396ed891e8a_720w.webp)

#### 9.2.3 xTaskNotify/xTaskNotifyWait

`xTaskNotify` 函数功能更强大，可以使用不同参数实现各类功能，比如：



- 让接收任务的通知值加一：这时`xTaskNotify()`等同于`xTaskNotifyGive()`
- 设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组
- 把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列
- 用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似`xQueueOverwrite()`函数，这就是轻量级的邮箱。



`xTaskNotify()`比`xTaskNotifyGive()`更灵活、强大，使用上也就更复杂。`xTaskNotifyFromISR()`是它对应的ISR版本。

这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？

使用`xTaskNotifyWait()`函数！它比`ulTaskNotifyTake()`更复杂：



- 可以让任务等待(可以加上超时时间)，等到任务状态为"pending"(也就是有数据)
- 还可以在函数进入、退出时，清除通知值的指定位



这几个函数的原型如下：

```text
BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );

BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify,
                               uint32_t ulValue, 
                               eNotifyAction eAction, 
                               BaseType_t *pxHigherPriorityTaskWoken );

BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, 
                            uint32_t ulBitsToClearOnExit, 
                            uint32_t *pulNotificationValue, 
                            TickType_t xTicksToWait );
```

xTaskNotify函数的参数说明如下：

![img](https://pic4.zhimg.com/80/v2-7808f9d5f24006b562c340bd8afd04a3_720w.webp)

eNotifyAction参数说明：

![img](https://pic4.zhimg.com/80/v2-2dc5b81098df0f1789dedeba9bddbeef_720w.webp)

xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数`pxHigherPriorityTaskWoken`。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：



- 被通知的任务，可能正处于阻塞状态
- `xTaskNotifyFromISR`函数发出通知后，会把接收任务从阻塞状态切换为就绪态
- 如果被唤醒的任务的优先级，高于当前任务的优先级，则"*pxHigherPriorityTaskWoken"被设置为pdTRUE，这表示在中断返回之前要进行任务切换。



xTaskNotifyWait函数列表如下：

![img](https://pic3.zhimg.com/80/v2-4ff28572db09dff75c9c11f683de2336_720w.webp)

### 9.3 示例22: 传输计数值

本节源码是`FreeRTOS_22_tasknotify_tansfer_count`，基于`FreeRTOS_13_semaphore_circle_buffer`修改。

本程序创建2个任务：



- 发送任务：把数据写入唤醒缓冲区，使用`xTaskNotifyGive()`让通知值加一
- 接收任务：使用`ulTaskNotifyTake()`取出通知值，这表示字符数，打印字符



main函数代码如下：

```text
int main( void )
{
	prvSetupHardware();

	/* 创建1个任务用于发送任务通知
	 * 优先级为2
	 */
	xTaskCreate( vSenderTask, "Sender", 1000, NULL, 2, NULL );

	/* 创建1个任务用于接收任务通知
	 * 优先级为1
	 */
	 xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, &xRecvTask );

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务、接收任务的代码和执行流程如下：



- A：发送任务优先级最高，先执行。连续存入3个字符、发出3次任务通知：通知值累加为3
- B：发送任务阻塞，让接收任务能执行
- C：接收任务读到通知值为3，并把通知值清零
- D：把3个字符依次读出、打印
- E：再次读取任务通知，阻塞





![img](https://pic4.zhimg.com/80/v2-ee4b8e672ee919a6ae52aefd6c342f5b_720w.webp)



运行结果如下图所示：



![img](https://pic2.zhimg.com/80/v2-efcc65164293ba3f242fc82ecf755c65_720w.webp)



本程序使用`xTaskNotifyGive/ulTaskNotifyTake`实现了轻量级的计数型信号量，代码更简单：



- 无需创建信号量
- 消耗内存更少
- 效率更高



信号量是个公开的资源，任何任务、ISR都可以使用它：可以释放、获取信号量。

而本节程序中，发送任务只能给指定的任务发送通知，目标明确；接收任务只能从自己的通知值中得到数据，来源明确。

### 9.4 示例23: 传输任意值

本节源码是`FreeRTOS_23_tasknotify_tansfer_value`。

在上述例子中使用任务通知来传输计数值、传输通知。

本节程序使用任务通知来传输任意数据，它创建2个任务：



- 发送任务：把数据通过`xTaskNotify()`发送给其他任务
- 接收任务：使用`xTaskNotifyWait`取出通知值，这表示字符，并打印出来



main函数代码如下：

```text
int main( void )
{
	prvSetupHardware();

	/* 创建1个任务用于发送任务通知
	 * 优先级为2
	 */
	xTaskCreate( vSenderTask, "Sender", 1000, NULL, 2, NULL );

	/* 创建1个任务用于接收任务通知
	 * 优先级为1
	 */
	 xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, &xRecvTask );

	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

发送任务、接收任务的代码和执行流程如下：



- A：发送任务优先级最高，先执行。连续给对方任务发送3个字符，只成功了1次
- B：发送任务阻塞，让接收任务能执行
- C：接收任务读取通知值
- D：把读到的通知值作为字符打印出来
- E：再次读取任务通知，阻塞





![img](https://pic4.zhimg.com/80/v2-a72efae195fff05b8751fbb182246213_720w.webp)



运行结果如下图所示：



![img](https://pic1.zhimg.com/80/v2-6063883c8cd3e13423694ed921d86f90_720w.webp)



本程序使用`xTaskNotify/xTaskNotifyWait`实现了轻量级的队列(该队列长度只有1)，代码更简单：



- 无需创建队列
- 消耗内存更少
- 效率更高



队列是个公开的资源，任何任务、ISR都可以使用它：可以存入数据、取出数据。

而本节程序中，发送任务只能给指定的任务发送通知，目标明确；接收任务只能从自己的通知值中得到数据，来源明确。

注意：任务通知值只有一个，数据可能丢失，设计程序时要考虑这点。



## 10 软件定时器(software timer)

### 概述

软件定时器就是"闹钟"，你可以设置闹钟，



- 在30分钟后让你起床工作
- 每隔1小时让你例行检查机器运行情况



软件定时器也可以完成两类事情：



- 在"未来"某个时间点，运行函数
- 周期性地运行函数



日常生活中我们可以定无数个"闹钟"，这无数的"闹钟"要基于一个真实的闹钟。

在FreeRTOS里，我们也可以设置无数个"软件定时器"，它们都是基于系统滴答中断(Tick Interrupt)。

本章涉及如下内容：



- 软件定时器的特性
- Daemon Task
- 定时器命令队列
- 一次性定时器、周期性定时器的差别
- 怎么操作定时器：创建、启动、复位、修改周期



### 10.1 软件定时器的特性

我们在手机上添加闹钟时，需要指定时间、指定类型(一次性的，还是周期性的)、指定做什么事；还有一些过时的、不再使用的闹钟。如下图所示：

![img](https://pic4.zhimg.com/80/v2-9afd8e66a8379b266df866cdf2a0be27_720w.webp)



使用定时器跟使用手机闹钟是类似的：



- 指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期(period)。

- 指定类型，定时器有两种类型：

- - 一次性(One-shot timers)：
    这类定时器启动后，它的回调函数只会被调用一次；
    可以手工再次启动它，但是不会自动启动它。
  - 自动加载定时器(Auto-reload timers )：
    这类定时器启动后，时间到之后它会自动启动它；
    这使得回调函数被周期性地调用。



- 指定要做什么事，就是指定回调函数



实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：



- 运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用
- 冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用



定时器运行情况示例如下：



- Timer1：它是一次性的定时器，在t1启动，周期是6个Tick。经过6个tick后，在t7执行回调函数。它的回调函数只会被执行一次，然后该定时器进入冬眠状态。
- Timer2：它是自动加载的定时器，在t1启动，周期是5个Tick。每经过5个tick它的回调函数都被执行，比如在t6、t11、t16都会执行。





![img](https://pic2.zhimg.com/80/v2-d9fef71e04880c020ec18037e367667d_720w.webp)



### 10.2 软件定时器的上下文

#### 10.2.1 守护任务

要理解软件定时器API函数的参数，特别是里面的`xTicksToWait`，需要知道定时器执行的过程。

FreeRTOS中有一个Tick中断，软件定时器基于Tick来运行。在哪里执行定时器函数？第一印象就是在Tick中断里执行：



- 在Tick中断中判断定时器是否超时
- 如果超时了，调用它的回调函数



FreeRTOS是RTOS，它不允许在内核、在中断中执行不确定的代码：如果定时器函数很耗时，会影响整个系统。

所以，FreeRTOS中，不在Tick中断中执行定时器函数。

在哪里执行？在某个任务里执行，这个任务就是：RTOS Damemon Task，RTOS守护任务。以前被称为"Timer server"，但是这个任务要做并不仅仅是定时器相关，所以改名为：RTOS Damemon Task。

当FreeRTOS的配置项`configUSE_TIMERS`被设置为1时，在启动调度器时，会自动创建RTOS Damemon Task。

我们自己编写的任务函数要使用定时器时，是通过"定时器命令队列"(timer command queue)和守护任务交互，如下图所示：



![img](https://pic2.zhimg.com/80/v2-d78a9a98b4a6d74abcb569605b450d65_720w.webp)



守护任务的优先级为：configTIMER_TASK_PRIORITY；定时器命令队列的长度为configTIMER_QUEUE_LENGTH。

#### 10.2.2 守护任务的调度

守护任务的调度，跟普通的任务并无差别。当守护任务是当前优先级最高的就绪态任务时，它就可以运行。它的工作有两类：



- 处理命令：从命令队列里取出命令、处理
- 执行定时器的回调函数



能否及时处理定时器的命令、能否及时执行定时器的回调函数，严重依赖于守护任务的优先级。下面使用2个例子来演示。

例子1：守护任务的优先性级较低



- t1：Task1处于运行态，守护任务处于阻塞态。
  守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。
  至于守护任务能否马上执行，取决于它的优先级。
- t2：Task1调用`xTimerStart()`
  要注意的是，`xTimerStart()`只是把"start timer"的命令发给"定时器命令队列"，使得守护任务退出阻塞态。
  在本例中，Task1的优先级高于守护任务，所以守护任务无法抢占Task1。
- t3：Task1执行完`xTimerStart()`
  但是定时器的启动工作由守护任务来实现，所以`xTimerStart()`返回并不表示定时器已经被启动了。
- t4：Task1由于某些原因进入阻塞态，现在轮到守护任务运行。
  守护任务从队列中取出"start timer"命令，启动定时器。
- t5：守护任务处理完队列中所有的命令，再次进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。
- 注意：假设定时器在后续某个时刻tX超时了，超时时间是"tX-t2"，而非"tX-t4"，从`xTimerStart()`函数被调用时算起。





![img](https://pic3.zhimg.com/80/v2-937d771536a01f6a881dc2d2cb70d10a_720w.webp)



例子2：守护任务的优先性级较高



- t1：Task1处于运行态，守护任务处于阻塞态。
  守护任务在这两种情况下会退出阻塞态切换为就绪态：命令队列中有数据、某个定时器超时了。
  至于守护任务能否马上执行，取决于它的优先级。
- t2：Task1调用`xTimerStart()`
  要注意的是，`xTimerStart()`只是把"start timer"的命令发给"定时器命令队列"，使得守护任务退出阻塞态。
  在本例中，守护任务的优先级高于Task1，所以守护任务抢占Task1，守护任务开始处理命令队列。
  Task1在执行`xTimerStart()`的过程中被抢占，这时它无法完成此函数。
- t3：守护任务处理完命令队列中所有的命令，再次进入阻塞态。
  此时Task1是优先级最高的就绪态任务，它开始执行。
- t4：Task1之前被守护任务抢占，对`xTimerStart()`的调用尚未返回。现在开始继续运行次函数、返回。
- t5：Task1由于某些原因进入阻塞态，进入阻塞态。Idel任务时优先级最高的就绪态任务，它执行。





![img](https://pic4.zhimg.com/80/v2-65d6a3610ce53ae67f722539f7a4ef0b_720w.webp)



注意，定时器的超时时间是基于调用`xTimerStart()`的时刻tX，而不是基于守护任务处理命令的时刻tY。假设超时时间是10个Tick，超时时间是"tX+10"，而非"tY+10"。

#### 10.2.3 回调函数

定时器的回调函数的原型如下：

void ATimerCallback( TimerHandle_t xTimer );

定时器的回调函数是在守护任务中被调用的，守护任务不是专为某个定时器服务的，它还要处理其他定时器。

所以，定时器的回调函数不要影响其他人：



- 回调函数要尽快实行，不能进入阻塞状态
- 不要调用会导致阻塞的API函数，比如`vTaskDelay()`
- 可以调用`xQueueReceive()`之类的函数，但是超时时间要设为0：即刻返回，不可阻塞



### 10.3 软件定时器的函数

根据定时器的状态转换图，就可以知道所涉及的函数：



![img](https://pic4.zhimg.com/80/v2-8c0c720bd299aaa643af9d8721d2d50f_720w.webp)



#### 10.3.1 创建

要使用定时器，需要先创建它，得到它的句柄。

有两种方法创建定时器：动态分配内存、静态分配内存。函数原型如下：

```text
/* 使用动态分配内存的方法创建定时器
 * pcTimerName:定时器名字, 用处不大, 尽在调试时用到
 * xTimerPeriodInTicks: 周期, 以Tick为单位
 * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性
 * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器
 * pxCallbackFunction: 回调函数
 * 返回值: 成功则返回TimerHandle_t, 否则返回NULL
 */
TimerHandle_t xTimerCreate( const char * const pcTimerName, 
							const TickType_t xTimerPeriodInTicks,
							const UBaseType_t uxAutoReload,
							void * const pvTimerID,
							TimerCallbackFunction_t pxCallbackFunction );

/* 使用静态分配内存的方法创建定时器
 * pcTimerName:定时器名字, 用处不大, 尽在调试时用到
 * xTimerPeriodInTicks: 周期, 以Tick为单位
 * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性
 * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器
 * pxCallbackFunction: 回调函数
 * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器
 * 返回值: 成功则返回TimerHandle_t, 否则返回NULL
 */
TimerHandle_t xTimerCreateStatic(const char * const pcTimerName,
                                 TickType_t xTimerPeriodInTicks,
                                 UBaseType_t uxAutoReload,
                                 void * pvTimerID,
                                 TimerCallbackFunction_t pxCallbackFunction,
                                 StaticTimer_t *pxTimerBuffer );
```

回调函数的类型是：

```text
void ATimerCallback( TimerHandle_t xTimer );

typedef void (* TimerCallbackFunction_t)( TimerHandle_t xTimer );
```

#### 10.3.2 删除

动态分配的定时器，不再需要时可以删除掉以回收内存。删除函数原型如下：

```text
/* 删除定时器
 * xTimer: 要删除哪个定时器
 * xTicksToWait: 超时时间
 * 返回值: pdFAIL表示"删除命令"在xTicksToWait个Tick内无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );
```

定时器的很多API函数，都是通过发送"命令"到命令队列，由守护任务来实现。

如果队列满了，"命令"就无法即刻写入队列。我们可以指定一个超时时间`xTicksToWait`，等待一会。

#### 10.3.3 启动/停止

启动定时器就是设置它的状态为运行态(Running、Active)。

停止定时器就是设置它的状态为冬眠(Dormant)，让它不能运行。

涉及的函数原型如下：

```text
/* 启动定时器
 * xTimer: 哪个定时器
 * xTicksToWait: 超时时间
 * 返回值: pdFAIL表示"启动命令"在xTicksToWait个Tick内无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );

/* 启动定时器(ISR版本)
 * xTimer: 哪个定时器
 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,
 *                            如果守护任务的优先级比当前任务的高,
 *                            则"*pxHigherPriorityTaskWoken = pdTRUE",
 *                            表示需要进行任务调度
 * 返回值: pdFAIL表示"启动命令"无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerStartFromISR(   TimerHandle_t xTimer,
                                 BaseType_t *pxHigherPriorityTaskWoken );

/* 停止定时器
 * xTimer: 哪个定时器
 * xTicksToWait: 超时时间
 * 返回值: pdFAIL表示"停止命令"在xTicksToWait个Tick内无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );

/* 停止定时器(ISR版本)
 * xTimer: 哪个定时器
 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,
 *                            如果守护任务的优先级比当前任务的高,
 *                            则"*pxHigherPriorityTaskWoken = pdTRUE",
 *                            表示需要进行任务调度
 * 返回值: pdFAIL表示"停止命令"无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerStopFromISR(    TimerHandle_t xTimer,
                                 BaseType_t *pxHigherPriorityTaskWoken );
```

注意，这些函数的`xTicksToWait`表示的是，把命令写入命令队列的超时时间。命令队列可能已经满了，无法马上把命令写入队列里，可以等待一会。

`xTicksToWait`不是定时器本身的超时时间，不是定时器本身的"周期"。

创建定时器时，设置了它的周期(period)。`xTimerStart()`函数是用来启动定时器。假设调用`xTimerStart()`的时刻是tX，定时器的周期是n，那么在`tX+n`时刻定时器的回调函数被调用。

如果定时器已经被启动，但是它的函数尚未被执行，再次执行`xTimerStart()`函数相当于执行`xTimerReset()`，重新设定它的启动时间。

#### 10.3.4 复位

从定时器的状态转换图可以知道，使用`xTimerReset()`函数可以让定时器的状态从冬眠态转换为运行态，相当于使用`xTimerStart()`函数。

如果定时器已经处于运行态，使用`xTimerReset()`函数就相当于重新确定超时时间。假设调用`xTimerReset()`的时刻是tX，定时器的周期是n，那么`tX+n`就是重新确定的超时时间。

复位函数的原型如下：

```text
/* 复位定时器
 * xTimer: 哪个定时器
 * xTicksToWait: 超时时间
 * 返回值: pdFAIL表示"复位命令"在xTicksToWait个Tick内无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );

/* 复位定时器(ISR版本)
 * xTimer: 哪个定时器
 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,
 *                            如果守护任务的优先级比当前任务的高,
 *                            则"*pxHigherPriorityTaskWoken = pdTRUE",
 *                            表示需要进行任务调度
 * 返回值: pdFAIL表示"停止命令"无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerResetFromISR(   TimerHandle_t xTimer,
                                 BaseType_t *pxHigherPriorityTaskWoken );
```

#### 10.3.5 修改周期

从定时器的状态转换图可以知道，使用`xTimerChangePeriod()`函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。

修改定时器的周期时，会使用新的周期重新计算它的超时时间。假设调用`xTimerChangePeriod()`函数的时间tX，新的周期是n，则`tX+n`就是新的超时时间。

相关函数的原型如下：

```text
/* 修改定时器的周期
 * xTimer: 哪个定时器
 * xNewPeriod: 新周期
 * xTicksToWait: 超时时间, 命令写入队列的超时时间 
 * 返回值: pdFAIL表示"修改周期命令"在xTicksToWait个Tick内无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerChangePeriod(   TimerHandle_t xTimer,
                                 TickType_t xNewPeriod,
                                 TickType_t xTicksToWait );

/* 修改定时器的周期
 * xTimer: 哪个定时器
 * xNewPeriod: 新周期
 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,
 *                            如果守护任务的优先级比当前任务的高,
 *                            则"*pxHigherPriorityTaskWoken = pdTRUE",
 *                            表示需要进行任务调度
 * 返回值: pdFAIL表示"修改周期命令"在xTicksToWait个Tick内无法写入队列
 *        pdPASS表示成功
 */
BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer,
                                      TickType_t xNewPeriod,
                                      BaseType_t *pxHigherPriorityTaskWoken );
```

#### 10.3.6 定时器ID

定时器的结构体如下，里面有一项`pvTimerID`，它就是定时器ID：



![img](https://pic4.zhimg.com/80/v2-1a84a4d99d27055f1c0ddcfcae7bfa13_720w.webp)



怎么使用定时器ID，完全由程序来决定：



- 可以用来标记定时器，表示自己是什么定时器
- 可以用来保存参数，给回调函数使用



它的初始值在创建定时器时由`xTimerCreate()`这类函数传入，后续可以使用这些函数来操作：



- 更新ID：使用`vTimerSetTimerID()`函数
- 查询ID：查询`pvTimerGetTimerID()`函数



这两个函数不涉及命令队列，它们是直接操作定时器结构体。

函数原型如下：

```text
/* 获得定时器的ID
 * xTimer: 哪个定时器
 * 返回值: 定时器的ID
 */
void *pvTimerGetTimerID( TimerHandle_t xTimer );

/* 设置定时器的ID
 * xTimer: 哪个定时器
 * pvNewID: 新ID
 * 返回值: 无
 */
void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );
```

### 10.4 示例24: 一般使用

本节程序为`FreeRTOS_24_software_timer`。

要使用定时器，需要做些准备工作：

```text
/* 1. 工程中 */
添加 timer.c

/* 2. 配置文件FreeRTOSConfig.h中 */
#define configUSE_TIMERS			 1   /* 使能定时器 */
#define configTIMER_TASK_PRIORITY    31  /* 守护任务的优先级, 尽可能高一些 */
#define configTIMER_QUEUE_LENGTH     5   /* 命令队列长度 */
#define configTIMER_TASK_STACK_DEPTH 32  /* 守护任务的栈大小 */
    
/* 3. 源码中 */
#include "timers.h"
```

main函数中创建、启动了2个定时器：一次性的、周期

```text
static volatile uint8_t flagONEShotTimerRun = 0;
static volatile uint8_t flagAutoLoadTimerRun = 0;

static void vONEShotTimerFunc( TimerHandle_t xTimer );
static void vAutoLoadTimerFunc( TimerHandle_t xTimer );

/*-----------------------------------------------------------*/

#define mainONE_SHOT_TIMER_PERIOD pdMS_TO_TICKS( 10 )
#define mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS( 20 )

int main( void )
{
	TimerHandle_t xOneShotTimer;
	TimerHandle_t xAutoReloadTimer;
	
	prvSetupHardware();

	xOneShotTimer = xTimerCreate(	
		"OneShot",                 /* 名字, 不重要 */
		mainONE_SHOT_TIMER_PERIOD, /* 周期 */
		pdFALSE,                   /* 一次性 */
		0,                         /* ID */
		vONEShotTimerFunc          /* 回调函数 */
	);	

	xAutoReloadTimer = xTimerCreate(	
		"AutoReload",                 /* 名字, 不重要 */
		mainAUTO_RELOAD_TIMER_PERIOD, /* 周期 */
		pdTRUE,                       /* 自动加载 */
		0,                            /* ID */
		vAutoLoadTimerFunc            /* 回调函数 */
	);	
	
	if (xOneShotTimer && xAutoReloadTimer)
	{
		/* 启动定时器 */
		xTimerStart(xOneShotTimer, 0);
		xTimerStart(xAutoReloadTimer, 0);
		
		/* 启动调度器 */
		vTaskStartScheduler();
	}

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

这两个定时器的回调函数比较简单：

```text
static void vONEShotTimerFunc( TimerHandle_t xTimer )
{
	static int cnt = 0;
	flagONEShotTimerRun = !flagONEShotTimerRun;
	printf("run vONEShotTimerFunc %d\r\n", cnt++);
}

static void vAutoLoadTimerFunc( TimerHandle_t xTimer )
{
	static int cnt = 0;
	flagAutoLoadTimerRun = !flagAutoLoadTimerRun;
	printf("run vAutoLoadTimerFunc %d\r\n", cnt++);
}
```

逻辑分析仪如下图所示：



![img](https://pic3.zhimg.com/80/v2-65c9c877a0d4d53c4165b81f5f63ff32_720w.webp)



运行结果如下图所示：



![img](https://pic3.zhimg.com/80/v2-2d3eb0eef1bdd27f38818cfb90c2f9ba_720w.webp)



### 10.5 示例25: 消除抖动

本节程序为`FreeRTOS_25_software_timer_readkey`。

在嵌入式开发中，我们使用机械开关时经常碰到抖动问题：引脚电平在短时间内反复变化。

怎么读到确定的按键状态？



- 连续读很多次，知道数值稳定：浪费CPU资源
- 使用定时器：要结合中断来使用



对于第2种方法，处理方法如下图所示，按下按键后：



- 在t1产生中断，这时不马上确定按键，而是复位定时器，假设周期时20ms，超时时间为"t1+20ms"
- 由于抖动，在t2再次产生中断，再次复位定时器，超时时间变为"t2+20ms"
- 由于抖动，在t3再次产生中断，再次复位定时器，超时时间变为"t3+20ms"
- 在"t3+20ms"处，按键已经稳定，读取按键值





![img](https://pic1.zhimg.com/80/v2-bc994111a6ab91e090a46618f6305fd8_720w.webp)



main函数中创建了一个一次性的定时器，从来处理抖动；创建了一个任务，用来模拟产生抖动。代码如下：

```text
/*-----------------------------------------------------------*/

static void vKeyFilteringTimerFunc( TimerHandle_t xTimer );
void vEmulateKeyTask( void *pvParameters );

static TimerHandle_t xKeyFilteringTimer;

/*-----------------------------------------------------------*/

#define KEY_FILTERING_PERIOD pdMS_TO_TICKS( 20 )

int main( void )
{
	
	prvSetupHardware();

	xKeyFilteringTimer = xTimerCreate(	
		"KeyFiltering",            /* 名字, 不重要 */
		KEY_FILTERING_PERIOD,      /* 周期 */
		pdFALSE,                   /* 一次性 */
		0,                         /* ID */
		vKeyFilteringTimerFunc          /* 回调函数 */
	);
	
    /* 在这个任务中多次调用xTimerReset来模拟按键抖动 */
	xTaskCreate( vEmulateKeyTask, "EmulateKey", 1000, NULL, 1, NULL );
			
	/* 启动调度器 */
	vTaskStartScheduler();

	/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */
	return 0;
}
```

模拟产生按键：每个循环里调用3次xTimerReset，代码如下：

```text
void vEmulateKeyTask( void *pvParameters )
{
	int cnt = 0;
	const TickType_t xDelayTicks = pdMS_TO_TICKS( 200UL );
	
	for( ;; )
	{
		/* 模拟按键抖动, 多次调用xTimerReset */		
		xTimerReset(xKeyFilteringTimer, 0); cnt++;
		xTimerReset(xKeyFilteringTimer, 0); cnt++;
		xTimerReset(xKeyFilteringTimer, 0); cnt++;

		printf("Key jitters %d\r\n", cnt);
		
		vTaskDelay(xDelayTicks);
	}
}
```

定时器回调函数代码如下：

```text
static void vKeyFilteringTimerFunc( TimerHandle_t xTimer )
{
	static int cnt = 0;
	printf("vKeyFilteringTimerFunc %d\r\n", cnt++);
}
```

在人户函数中多次调用xTimerReset，只触发1次定时器回调函数，运行结果如下图所示：



![img](https://pic3.zhimg.com/80/v2-a8e59b9dc271237df539600efdfc0e5a_720w.webp)



## 11 中断管理(Interrupt Management)

### 概述

在RTOS中，需要应对各类事件。这些事件很多时候是通过硬件中断产生，怎么处理中断呢？

假设当前系统正在运行Task1时，用户按下了按键，触发了按键中断。这个中断的处理流程如下：



- CPU跳到固定地址去执行代码，这个固定地址通常被称为中断向量，这个跳转时硬件实现的

- 执行代码做什么？

- - 保存现场：Task1被打断，需要先保存Task1的运行环境，比如各类寄存器的值
  - 分辨中断、调用处理函数(这个函数就被称为ISR，interrupt service routine)
  - 恢复现场：继续运行Task1，或者运行其他优先级更高的任务





你要注意到，ISR是在内核中被调用的，ISR执行过程中，用户的任务无法执行。ISR要尽量快，否则：



- 其他低优先级的中断无法被处理：实时性无法保证
- 用户任务无法被执行：系统显得很卡顿



如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：



- ISR：尽快做些清理、记录工作，然后触发某个任务
- 任务：更复杂的事情放在任务中处理
- 所以：需要ISR和任务之间进行通信



要在FreeRTOS中熟练使用中断，有几个原则要先说明：



- FreeRTOS把任务认为是硬件无关的，任务的优先级由程序员决定，任务何时运行由调度器决定

- ISR虽然也是使用软件实现的，但是它被认为是硬件特性的一部分，因为它跟硬件密切相关

- - 何时执行？由硬件决定
  - 哪个ISR被执行？由硬件决定



- ISR的优先级高于任务：即使是优先级最低的中断，它的优先级也高于任务。任务只有在没有中断的情况下，才能执行。



本章涉及如下内容：



- FreeRTOS的哪些API函数能在ISR中使用
- 怎么把中断的处理分为两部分：ISR、任务
- ISR和任务之间的通信



.. toctree:: :maxdepth: 2 section1

### 11.1 两套API函数

#### 11.1.1 为什么需要两套API

在任务函数中，我们可以调用各类API函数，比如队列操作函数：xQueueSendToBack。但是在ISR中使用这个函数会导致问题，应该使用另一个函数：xQueueSendToBackFromISR，它的函数名含有后缀"FromISR"，表示"从ISR中给队列发送数据"。

FreeRTOS中很多API函数都有两套：一套在任务中使用，另一套在ISR中使用。后者的函数名含有"FromISR"后缀。

为什么要引入两套API函数？



- 很多API函数会导致任务计入阻塞状态：

- - 运行这个函数的**任务**进入阻塞状态
  - 比如写队列时，如果队列已满，可以进入阻塞状态等待一会



- ISR调用API函数时，ISR不是"任务"，ISR不能进入阻塞状态
- 所以，在任务中、在ISR中，这些函数的功能是有差别的



为什么不使用同一套函数，比如在函数里面分辨当前调用者是任务还是ISR呢？示例代码如下：

```text
BaseType_t xQueueSend(...)
{
    if (is_in_isr())
    {
    	/* 把数据放入队列 */
        
        /* 不管是否成功都直接返回 */
    }
    else /* 在任务中 */
    {
    	/* 把数据放入队列 */
        /* 不成功就等待一会再重试 */
    }
}
```

FreeRTOS使用两套函数，而不是使用一套函数，是因为有如下好处：



- 使用同一套函数的话，需要增加额外的判断代码、增加额外的分支，是的函数更长、更复杂、难以测试

- 在任务、ISR中调用时，需要的参数不一样，比如：

- - 在任务中调用：需要指定超时时间，表示如果不成功就阻塞一会
  - 在ISR中调用：不需要指定超时时间，无论是否成功都要即刻返回
  - 如果强行把两套函数揉在一起，会导致参数臃肿、无效



- 移植FreeRTOS时，还需要提供监测上下文的函数，比如`is_in_isr()`
- 有些处理器架构没有办法轻易分辨当前是处于任务中，还是处于ISR中，就需要额外添加更多、更复杂的代码



使用两套函数可以让程序更高效，但是也有一些缺点，比如你要使用第三方库函数时，即会在任务中调用它，也会在ISR总调用它。这个第三方库函数用到了FreeRTOS的API函数，你无法修改库函数。这个问题可以解决：



- 把中断的处理推迟到任务中进行(Defer interrupt processing)，在任务中调用库函数

- 尝试在库函数中使用"FromISR"函数：

- - 在任务中、在ISR中都可以调用"FromISR"函数
  - 反过来就不行，非FromISR函数无法在ISR中使用



- 第三方库函数也许会提供OS抽象层，自行判断当前环境是在任务还是在ISR中，分别调用不同的函数



#### 11.1.2 两套API函数列表

![img](https://pic1.zhimg.com/80/v2-f355746a8a99240df8974c1052ecba94_720w.webp)

#### 11.1.3 xHigherPriorityTaskWoken参数

xHigherPriorityTaskWoken的含义是：是否有更高优先级的任务被唤醒了。如果为pdTRUE，则意味着后面要进行任务切换。

还是以写队列为例。

任务A调用`xQueueSendToBack()`写队列，有几种情况发生：



- 队列满了，任务A阻塞等待，另一个任务B运行
- 队列没满，任务A成功写入队列，但是它导致另一个任务B被唤醒，任务B的优先级更高：任务B先运行
- 队列没满，任务A成功写入队列，即刻返回



可以看到，在任务中调用API函数可能导致任务阻塞、任务切换，这叫做"context switch"，上下文切换。这个函数可能很长时间才返回，在函数的内部实现了任务切换。

`xQueueSendToBackFromISR()`函数也可能导致任务切换，但是不会在函数内部进行切换，而是返回一个参数：表示是否需要切换，函数原型与用法如下：

```text
/* 
 * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞
 */
BaseType_t xQueueSendToBackFromISR(
                                      QueueHandle_t xQueue,
                                      const void *pvItemToQueue,
                                      BaseType_t *pxHigherPriorityTaskWoken
                                   );

/* 用法示例 */

BaseType_t xHigherPriorityTaskWoken = pdFALSE;
xQueueSendToBackFromISR(xQueue, pvItemToQueue, &xHigherPriorityTaskWoken);

if (xHigherPriorityTaskWoken == pdTRUE)
{
    /* 任务切换 */    
}
```

pxHigherPriorityTaskWoken参数，就是用来保存函数的结果：是否需要切换



- *pxHigherPriorityTaskWoken等于pdTRUE：函数的操作导致更高优先级的任务就绪了，ISR应该进行任务切换
- *pxHigherPriorityTaskWoken等于pdFALSE：没有进行任务切换的必要



```text
void XXX_ISR()
{
    int i;
    for (i = 0; i < N; i++)
    {
        xQueueSendToBackFromISR(...); /* 被多次调用 */
    }
}
```

ISR中有可能多次调用"FromISR"函数，如果在"FromISR"内部进行任务切换，会浪费时间。解决方法是：



- 在"FromISR"中标记是否需要切换
- 在ISR返回之前再进行任务切换
- 示例代码如下

```text
void XXX_ISR()
{
    int i;
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    for (i = 0; i < N; i++)
    {
        xQueueSendToBackFromISR(..., &xHigherPriorityTaskWoken); /* 被多次调用 */
    }
	
    /* 最后再决定是否进行任务切换 */
    if (xHigherPriorityTaskWoken == pdTRUE)
	{
    	/* 任务切换 */    
	}
}
```

上述的例子很常见，比如UART中断：在UART的ISR中读取多个字符，发现收到回车符时才进行任务切换。

在ISR中调用API时不进行任务切换，而只是在"xHigherPriorityTaskWoken"中标记一下，除了效率，还有多种好处：



- 效率高：避免不必要的任务切换
- 让ISR更可控：中断随机产生，在API中进行任务切换的话，可能导致问题更复杂
- 可移植性
- 在Tick中断中，调用`vApplicationTickHook()`：它运行与ISR，只能使用"FromISR"的函数



使用"FromISR"函数时，如果不想使用xHigherPriorityTaskWoken参数，可以设置为NULL。

#### 11.1.4 怎么切换任务

FreeRTOS的ISR函数中，使用两个宏进行任务切换：

```text
portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
或
portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
```

这两个宏做的事情是完全一样的，在老版本的FreeRTOS中，



- `portEND_SWITCHING_ISR`使用汇编实现
- `portYIELD_FROM_ISR`使用C语言实现



新版本都统一使用`portYIELD_FROM_ISR`。

使用示例如下：

```text
void XXX_ISR()
{
    int i;
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    for (i = 0; i < N; i++)
    {
        xQueueSendToBackFromISR(..., &xHigherPriorityTaskWoken); /* 被多次调用 */
    }
	
    /* 最后再决定是否进行任务切换 
     * xHigherPriorityTaskWoken为pdTRUE时才切换
     */
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

### 11.2 中断的延迟处理

前面讲过，ISR要尽量快，否则：



- 其他低优先级的中断无法被处理：实时性无法保证
- 用户任务无法被执行：系统显得很卡顿
- 如果运行中断嵌套，这会更复杂，ISR越快执行约有助于中断嵌套



如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：



- ISR：尽快做些清理、记录工作，然后触发某个任务
- 任务：更复杂的事情放在任务中处理



这种处理方式叫"中断的延迟处理"(Deferring interrupt processing)，处理流程如下图所示：



- t1：任务1运行，任务2阻塞

- t2：发生中断，

- - 该中断的ISR函数被执行，任务1被打断
  - ISR函数要尽快能快速地运行，它做一些必要的操作(比如清除中断)，然后唤醒任务2



- t3：在创建任务时设置任务2的优先级比任务1高(这取决于设计者)，所以ISR返回后，运行的是任务2，它要完成中断的处理。任务2就被称为"deferred processing task"，中断的延迟处理任务。
- t4：任务2处理完中断后，进入阻塞态以等待下一个中断，任务1重新运行





![img](https://pic2.zhimg.com/80/v2-e9a35a1d43b1bda8b570dcae35e3351d_720w.webp)



### 11.3 中断与任务间的通信

前面讲解过的队列、信号量、互斥量、事件组、任务通知等等方法，都可使用。

要注意的是，在ISR中使用的函数要有"FromISR"后缀。



## 12 资源管理(Resource Management)

### 概述

在前面讲解互斥量时，引入过临界资源的概念。在前面课程里，已经实现了临界资源的互斥访问。

本章节的内容比较少，只是引入两个功能：屏蔽/使能中断、暂停/恢复调度器。

要独占式地访问临界资源，有3种方法：



- 公平竞争：比如使用互斥量，谁先获得互斥量谁就访问临界资源，这部分内容前面讲过。

- 谁要跟我抢，我就灭掉谁：

- - 中断要跟我抢？我屏蔽中断
  - 其他任务要跟我抢？我禁止调度器，不运行任务切换

```text
.. toctree::
   :maxdepth: 2

   section1
```

### 12.1 屏蔽中断

屏蔽中断有两套宏：任务中使用、ISR中使用：



- 任务中使用：`taskENTER_CRITICA()/taskEXIT_CRITICAL()`
- ISR中使用：`taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()`



#### 12.1.1 在任务中屏蔽中断

在任务中屏蔽中断的示例代码如下：

```text
/* 在任务中，当前时刻中断是使能的
 * 执行这句代码后，屏蔽中断
 */
taskENTER_CRITICAL();

/* 访问临界资源 */

/* 重新使能中断 */
taskEXIT_CRITICAL();
```

在`taskENTER_CRITICA()/taskEXIT_CRITICAL()`之间：



- 低优先级的中断被屏蔽了：优先级低于、等于`configMAX_SYSCALL_INTERRUPT_PRIORITY`

- 高优先级的中断可以产生：优先级高于`configMAX_SYSCALL_INTERRUPT_PRIORITY`

- - 但是，这些中断ISR里，不允许使用FreeRTOS的API函数



- 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生



这套`taskENTER_CRITICA()/taskEXIT_CRITICAL()`宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用`taskEXIT_CRITICAL()`才会重新使能中断。

使用`taskENTER_CRITICA()/taskEXIT_CRITICAL()`来访问临界资源是很粗鲁的方法：



- 中断无法正常运行
- 任务调度无法进行
- 所以，之间的代码要尽可能快速地执行



#### 12.1.2 在ISR中屏蔽中断

要使用含有"FROM_ISR"后缀的宏，示例代码如下：

```text
void vAnInterruptServiceRoutine( void )
{
    /* 用来记录当前中断是否使能 */
    UBaseType_t uxSavedInterruptStatus;
    
    /* 在ISR中，当前时刻中断可能是使能的，也可能是禁止的
     * 所以要记录当前状态, 后面要恢复为原先的状态
     * 执行这句代码后，屏蔽中断
     */
    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
    
    /* 访问临界资源 */

    /* 恢复中断状态 */
    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
    /* 现在，当前ISR可以被更高优先级的中断打断了 */
}
```

在`taskENTER_CRITICA_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()`之间：



- 低优先级的中断被屏蔽了：优先级低于、等于`configMAX_SYSCALL_INTERRUPT_PRIORITY`

- 高优先级的中断可以产生：优先级高于`configMAX_SYSCALL_INTERRUPT_PRIORITY`

- - 但是，这些中断ISR里，不允许使用FreeRTOS的API函数



- 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生



### 12.2 暂停调度器

如果有别的任务来跟你竞争临界资源，你可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。

如果只是禁止别的任务来跟你竞争，不需要关中断，暂停调度器就可以了：在这期间，中断还是可以发生、处理。

使用这2个函数来暂停、恢复调度器：

```text
/* 暂停调度器 */
void vTaskSuspendAll( void );

/* 恢复调度器
 * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了
 *        可以不理会这个返回值
 */
BaseType_t xTaskResumeAll( void );
```

示例代码如下：

```text
vTaskSuspendScheduler();

/* 访问临界资源 */

xTaskResumeScheduler();
```

这套`vTaskSuspendScheduler()/xTaskResumeScheduler()`宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用`taskEXIT_CRITICAL()`才会重新使能中断。

# Linux应用开发

## 1 Framebuffer

### 1.1 LCD Framebuffer操作原理

 LCD Framebuffer 就是一块显存，在嵌入式系统中，显存是被包含在内存中。LCD Framebuffer里的若干字节（根据驱动程序对LCD控制器的配置而定）表示LCD屏幕中的一个像素点，一一对应整个LCD屏幕。举个例子，LCD屏幕是800 * 600的分辨率，即LCD屏幕存在480000个像素点，若每个像素点4个字节表示，那么LCD Framebuffer显存大小为480000 * 4=960000字节，即1.92MB。因此我们的内存将会分割至少1.92MB的空间用作显存。具体地址在哪里，这个就是又驱动程序去定，应用程序只需直接使用即可，硬件相关操作已由驱动程序封装好。



![img](https://pic3.zhimg.com/80/v2-8958619b670f791ca3cacd669a40f3b6_720w.webp)



 如上图，我们只需要往Framebuffer中填入不同的值，驱动程序和硬件控制器就会把这些数据传输到对应LCD屏幕上的像素点，从而显示不同的颜色。由此可知，我们应用程序只需要针对Framebuffer操作即可，其他交给驱动程序和硬件。

### 1.2 Framebuffer API接口

#### 1.2.1 open系统调用



![img](https://pic2.zhimg.com/80/v2-48ef93f9500058f3ec3fc222cc44f209_720w.webp)



头文件：#include ，#include ，#include

函数原型：

- int open(const char *pathname, int flags);
- int open(const char *pathname, int flags, mode_t mode);

函数说明：

- pathname 表示打开文件的路径；
- Flags表示打开文件的方式，常用的有以下6种，

①：O_RDWR表示可读可写方式打开;

②：O_RDONLY表示只读方式打开;

③：O_WRONLY表示只写方式打开;

④：O_APPEND 表示如果这个文件中本来是有内容的，则新写入的内容会接续到原来内容的后面;

⑤：O_TRUNC表示如果这个文件中本来是有内容的，则原来的内容会被丢弃，截断；

⑥：O_CREAT表示当前打开文件不存在，我们创建它并打开它，通常与O_EXCL结合使用，当没有文件时创建文件，有这个文件时会报错提醒我们；

Mode表示创建文件的权限，只有在flags中使用了O_CREAT时才有效，否则忽略。

返回值：打开成功返回文件描述符，失败将返回-1。

#### 1.2.2 ioctl系统调用



![img](https://pic4.zhimg.com/80/v2-c873d3a534745f58f7f994990b2a072b_720w.webp)

头文件：#include

函数原型：

- int ioctl(int fd, unsigned long request, ...);

函数说明：

- fd 表示文件描述符；
- request表示与驱动程序交互的命令，用不同的命令控制驱动程序输出我们需要的数据；
- … 表示可变参数arg，根据request命令，设备驱动程序返回输出的数据。

返回值：打开成功返回文件描述符，失败将返回-1。

#### 1.2.3 mmap系统调用



![img](https://pic3.zhimg.com/80/v2-909936ba83e981258d1d013bedda4326_720w.webp)



头文件：#include

函数原型：

- void *mmap(void* addr, size_t length, int prot, int flags,int fd, off_t offset);

函数说明：

- addr表示指定映射的內存起始地址，通常设为 NULL表示让系统自动选定地址，并在成功映射后返回该地址；
- length表示将文件中多大的内容映射到内存中；
- prot 表示映射区域的保护方式，可以为以下4种方式的组合

①PROT_EXEC 映射区域可被执行

②PROT_READ 映射区域可被读写

③PROT_WRITE 映射区域可被写入

④PROT_NONE 映射区域不能存取

- Flags 表示影响映射区域的不同特性，常用的有以下两种

①MAP_SHARED 表示对映射区域写入的数据会复制回文件内，原来的文件会改变。

②MAP_PRIVATE 表示对映射区域的操作会产生一个映射文件的复制，对此区域的任何修改都不会写回原来的文件内容中。

返回值：若成功映射，将返回指向映射的区域的指针，失败将返回-1。

### 1.3 在LCD上描点操作

#### 1.3.1 在LCD上显示点阵理论基础



![img](https://pic2.zhimg.com/80/v2-b64a30effed84c9faf6fb011073f59b1_720w.webp)



 如上图，当我们需要显示一个字母‘A’时，是通过判断点阵的每一个位数值状态，来填充颜色，达到显示字符效果。其中‘1’表示一种颜色，‘0’表示填充另一种颜色。上图的是8*16的点阵，我们也可以用其他不同大小点阵，只要有这个点阵，我们就可以在LCD上面描点，达到显示字符的效果。

#### 1.3.2 获取fb_var_screeninfo结构体

 在用点阵显示字符之前，我们需要先从设备fb0中获取相关的LCD信息，下图截取我们将用到的fb_info结构体部分内容。



![img](https://pic1.zhimg.com/80/v2-90562d16bd66a49f88690f86cfd2267c_720w.webp)



 通过系统调用ioctl，获取xres(x方向总像素点)，yres（y方向总像素点），bits_per_pixel（每个像素点占据的位数），根据获取的三个资源，外加点阵，根据这四个资源，我们就可以显示一个字符。

程序文件：show_ascii.c

```c
4718        fd_fb = open("/dev/fb0", O_RDWR);
4719        if (fd_fb < 0)
4720        {
4721            printf("can't open /dev/fb0\n");
4722            return -1;
4723        }
4724        if (ioctl(fd_fb, FBIOGET_VSCREENINFO, &var))
4725        {
4726            printf("can't get var\n");
4727            return -1;
4728        }
```

 先打开LCD设备（fb0），获得文件描述符，再通过ioctl获取fb_var_screeninfo信息并保存在var变量，后续只需访问var这个结构体，就可以获得xres(x方向总像素点)，yres（y方向总像素点），bits_per_pixel（每个像素点占据的位数）这三个关于fb0的资源。

#### 1.3.3 根据fb_var_screeninfo计算变量

fb_var_screeninfo已保存在var结构体变量中，接着来访问var结构体变量即可

根据xres与bits_per_pixel算出每行像素点所占据的字节数

程序文件：show_ascii.c

```c
4730    line_width  = var.xres * var.bits_per_pixel / 8;
```

根据bits_per_pixel算出每个像素点所占据的字节数

程序文件：show_ascii.c

```c
4731    pixel_width = var.bits_per_pixel / 8;
```

根据xres，yres，bits_per_pixel算出全部像素点所占据的字节总和

程序文件：show_ascii.c

```c
4732    screen_size = var.xres * var.yres * var.bits_per_pixel / 8;
```

#### 1.3.4 使用mmap系统调用，映射内存

程序文件：show_ascii.c

```c
4733    fbmem = (unsigned char *)mmap(NULL , screen_size, PROT_READ |           PROT_WRITE, MAP_SHARED, fd_fb, 0);
4734    if (fbmem == (unsigned char *)-1)
4735    {
4736        printf("can't mmap\n");
4737        return -1;
4738    }
4739
4740    /* 清屏: 全部设为黑色 */
4741    memset(fbmem, 0, screen_size);
```

 调用mmap将显存映射在内存中，以可读可写（PROT_READ | PROT_WRITE）及内存回写（MAP_SHARED）的方式映射，从而获得一个指向映射在内存空间的首地址fbmem，后续操作就是在这个首地址的基础上计算各种不同的偏移量，填充颜色值。

#### 1.3.5 描点函数编写

程序文件：show_ascii.c

```c
4641    void lcd_put_pixel(int x, int y, unsigned int color)
```

描点函数有3个参数，x坐标，y坐标，像素点颜色值。

程序文件：show_ascii.c

```c
4643        unsigned char *pen_8 = fbmem+y*line_width+x*pixel_width;
4644        unsigned short *pen_16; 
4645        unsigned int *pen_32;   
4646
4647        unsigned int red, green, blue;  
4648
4649        pen_16 = (unsigned short *)pen_8;
4650        pen_32 = (unsigned int *)pen_8;
```

 在此处函数参数x与y表示的是像素点的坐标，而单个像素点所占据的显存大小可能会有不同的情况出现，如1字节表示一个像素点，2字节表示一个像素点，4字节表示一个像素点等，为了更多的兼容不同的情况，因此申请3个指针，pen_8指向的是占据1个字节的像素点空间, pen_16指向的是占据2个字节的像素点空间，pen_32指向的是占据4个字节的像素点空间。

fbmem是系统调用mmap返回的显存首地址，根据fbmem计算填充颜色的内存空间。

当像素点占据1个字节空间时

对应描点地址= fbmem+Y * 一行所占据的字节数 + x * 每个像素点所占据的字节数

程序文件：show_ascii.c

```c
4652        switch (var.bits_per_pixel)
4653        {
4654            case 8:
4655            {
4656                *pen_8 = color;
4657                break;
4658            }
4659            case 16:
4660            {
4661                /* 565 */
4662                red   = (color >> 16) & 0xff;
4663                green = (color >> 8) & 0xff;
4664                blue  = (color >> 0) & 0xff;
4665                color = ((red >> 3) << 11) | ((green >> 2) << 5) |                      (blue >> 3);
4666                *pen_16 = color;
4667                break;
4668            }
4669            case 32:
4670            {
4671                *pen_32 = color;
4672                break;
4673            }
4674            default:
4675            {
4676                printf("can't surport %dbpp\n", var.bits_per_pixel);
4677                break;
4678            }
4679        }
4680    }
```

 根据设备fb0实际的bits_per_pixel值，选择对应的pen（pen_8，pen_16，pen_32其中一个），最后把color颜色变量传入选择的pen中。

### 1.4 在LCD上使用点阵写字

#### 1.4.1 在LCD上显示英文字母

①找出英文字母在点阵数组中的地址，c所代表的是一个英文字母（ASCII值）。

程序文件：show_ascii.c

```c
4693        unsigned char *dots = (unsigned char *)&fontdata_8x16[c*16];
```

②根据获得的英文字母点阵，每一位依次判断，描点，‘1’表示白色，‘0’表示黑色。



![img](https://pic3.zhimg.com/80/v2-c62961d8b22ed193b55d622a81771c8a_720w.webp)



 根据上图，我们分析下如何利用点阵在LCD上显示一个英文字母，因为有十六行，所以首先要有一个循环16次的大循环，然后每一行里有8位，那么在每一个大循环里也需要一个循环8次的小循环，小循环里的判断单行的描点情况，如果是1，就填充白色，如果是0就填充黑色，如此一来，就可以显示出黑色底，白色轮廓的英文字母。

程序文件：show_ascii.c

```c
4697        for (i = 0; i < 16; i++)
4698        {
4699            byte = dots[i];
4700            for (b = 7; b >= 0; b--)
4701            {
4702                if (byte & (1<<b))
4703                {
4704                    /* show */
4705                    lcd_put_pixel(x+7-b, y+i, 0xffffff); /* 白 */
4706                }
4707                else
4708                {
4709                    /* hide */
4710                    lcd_put_pixel(x+7-b, y+i, 0); /* 黑 */
4711                }
4712            }
4713    }
```

③调用我们编写的lcd_put_ascii函数

程序文件：show_ascii.c

```c
4743 lcd_put_ascii(var.xres/2, var.yres/2, 'A'); /*在屏幕中间显示8*16的字母A*/
```

④编译c文件show_ascii.c

编译命令：arm-linux-gnueabihf-gcc -o show_ascii show_ascii.c

⑤将编译出来的show_ascii传输到开发板，并进入show_ascii的目录下

执行命令：./show_ascii

如果实验成功，我们将看到屏幕中间会显示出一个白色的字母‘A’。

#### 1.4.2 在LCD上显示汉字



![img](https://pic2.zhimg.com/80/v2-775df3251dc5f4e9e1fcb87d16833b2d_720w.webp)



 与显示英文字母有点不同，因为汉字的点阵我们是需要通过汉字库提取出来，并没有直接提供点阵数组，因此我们程序开头需要打开汉字库文件(HZK16)，然后再找到相应的位置，提取出汉字的点阵，最后再按显示英文字母一样显示它，不过这个汉字是16*16的。

① 打开汉字库文件

程序文件：show_font.c

```c
4760    fd_hzk16 = open("HZK16", O_RDONLY);
```

② 获取汉字库文件的属性，存在hzk_stat结构体变量中

程序文件：show_font.c

```c
4793    if(fstat(fd_hzk16, &hzk_stat))
```

此处主要是用知道该文件的大小，因为后面mmap时需要知道映射的文件大小。

③使用mmap系统调用

程序文件：show_font.c

```c
4798    hzkmem = (unsigned char *)mmap(NULL , hzk_stat.st_size,                 PROT_READ, MAP_SHARED, fd_hzk16, 0);
```

hzkmem与fbmem类似，也是一个指向映射内存的指针，但是它是指向汉字库，方便

后续计算汉字点阵偏移位置用。

④使用汉字库，调出点阵显示汉字

 HZK16 字库是符合GB2312标准的16×16点阵字库HZK16的编码，每个字需要32个字节的点阵来表示，例如我们将要显示的‘中’字，编码是D6D0，难道就是2个字节表示吗？不是说32字节吗？D6D0编码是一个类似于索引码，D6是区码，D0是位码，先要找到D6-A1才是真正区，在D6-A1区里找到D0-A1的真正位置，这才是‘中’字点阵的起始位置（减去A1是为了兼容ascii），每一个区有94个汉字。

程序文件：show_font.c

```c
4734        unsigned int area  = str[0] - 0xA1;
4735        unsigned int where = str[1] - 0xA1;
4736        unsigned char *dots = hzkmem + (area * 94 + where)*32;
```



![img](https://pic1.zhimg.com/80/v2-387b22682c37b77ffacac32942201280_720w.webp)



 上图是汉字点阵排布的示意图，总共有十六行，因此需要一个循环16次的大循环，考虑到一行有两个字节，我们大循环中加入一个循环2次的循环用于区分是哪个字节，最后判断当前字节的每一位，如果为 ‘1’描白色，如果为‘0’描黑色

程序文件：show_font.c

```c
4740    for (i = 0; i < 16; i++)
4741            for (j = 0; j < 2; j++)
4742            {
4743                byte = dots[i*2 + j];
4744                for (b = 7; b >=0; b--)
4745                {
4746                    if (byte & (1<<b))
4747                    {
4748                        /* show */
4749                        lcd_put_pixel(x+j*8+7-b, y+i, 0xffffff); /* 白 */
4750                    }
4751                    else
4752                    {
4753                        /* hide */
4754                        lcd_put_pixel(x+j*8+7-b, y+i, 0); /* 黑 */
4755                    }   
4756                }
4757            }
```

⑤调用我们编写的lcd_put_chinese函数

程序文件：show_font.c

```c
4810    printf("chinese code: %02x %02x\n", str[0], str[1]);
4811    lcd_put_chinese(var.xres/2 + 8,  var.yres/2, str);
```

⑥编译c文件show_font.c

编译命令：arm-linux-gnueabihf-gcc -o show_font show_font.c

注：使用此命令HZK16文件必须与show_font.C在同一目录下。

⑦将编译出来的show_font传输到开发板，并进入show_font的目录下

执行命令：./show_font

如果实验成功，我们将看到屏幕中间会显示出一个白色的字母‘A’与汉字‘中’，同时在串口打印信息中看到‘中’对应的编码。

```
chinese code: d6 d0
```

### 1.5 搭建freetype相关环境

#### 1.5.1 交叉编译freetype，并安装

①解压freetype源文件

```c
tar xjf freetype-2.4.10.tar.bz2
```

②进入解压后的freetype-2.4.10目录

```c
cd freetype-2.4.10
```

③配置freetype-2.4.10

```c
./configure --host=arm-linux-gnueabihf --prefix=/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/
```

④建个目录，避免后面安装出错提示缺少这个internal目录

```c
mkdir /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/freetype2/freetype/internal -p
```

④编译

```c
make
```

⑤安装

```c
make install
```

⑥移动freetype头文件，避免以后编译总是需要指定头文件路径

```c
mv /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/freetype2/freetype /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/
```

#### 1.5.2 freetype库，头文件移植至开发板

 由于100ask开发板已经有freetype相关的库和头文件，因此不需要移植，如果开发板没有freetype库和头文件就需要按以下方法移植

/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/* 复制到开发板的头文件目录中

/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib/*so* 复制到开发板的库文件目录中

注：链接文件需要保持它的链接属性（即加-d选项）。

### 1.6 使用freetype

#### 1.6.1 矢量字体引入

 点阵显示英文字母，汉字时，大小固定，如果放大会有锯齿出现，为了解决这个问题，引用矢量字体。

矢量字体形成分三步，若干的关键点，数学曲线（贝塞尔曲线），填充颜色组合而成。

①假设A字母的关键点如图中的黄色圈圈，确定关键点。



![img](https://pic2.zhimg.com/80/v2-0071e97a1bee518c20df17613c0bd1d1_720w.webp)



②用数学曲线将关键点都连接起来，成为封闭的曲线。



![img](https://pic4.zhimg.com/80/v2-48b488358aba03dd557fd49c91350c47_720w.webp)



③最后把封闭空间填满颜色，就显示出一个A字母。



![img](https://pic4.zhimg.com/80/v2-62e83b0d13a6762b2a606c8127556dfb_720w.webp)



 如果需要放大或者缩小字体，关键点的相对位置是不变的，跟进放大比例放大或缩小，但是相对位置不变，好像分数中的1/2 和 2/4，比例是不变的，但是值却大了，类似这个味道。

#### 1.6.2 Freetype理论介绍

 开源的Freetype字体引擎库它提供统一的接口来访问多种字体格式文件，从而实现矢量字体显示。我们只需要移植这个字体引擎，调用对应的API接口，提供字体关键点，就可以让freetype库帮我们实现闭合曲线，填充颜色，达到显示矢量字体的目的。

关键点（glyph）存在字体文件中，Windows使用的字体文件在FONTS目录下，扩展名为TTF的都是矢量字库，本次使用实验使用的是新宋字体simsun.ttc。



![img](https://pic2.zhimg.com/80/v2-ba7de10a45f7105823451de51f7c28b5_720w.webp)



字体文件结构如上图

 Charmaps表示字符映射表，字体文件可能支持哪一些编码，GBK，UNICODE，BIG5还是别的编码，如果字体文件支持该编码，跟进编码，通过charmap，找到对应的glyph，一般而言都支持UNICODE码。

有了以上基础，我们想象一个文字的显示过程

- ①给定一个文字吗‘A’（0x41），‘中’（GBK，UNICODE ,BIG5）可以确定它的编码值；
- ②跟进编码值，从枝头文件中通过charmap找到对应的关键点（glyph）；
- ③设置字体大；
- ④用某些函数把关键点（glyph）缩放为我们设置的字体大小；
- ⑤转换为位图点阵
- ⑥在LCD上显示出来



![img](https://pic4.zhimg.com/80/v2-d64d8b0ed37829eb6d70ba1772fa8523_720w.webp)



 如上图，参照step1，step2，step3里的内容，可以学习如何使用freetype库，大致总结下，为如下步骤。

①初始化：FT_InitFreetype

②加载（打开）字体Face：FT_New_Face

③设置字体大小：FT_Set_Char_Sizes 或 FT_Set_Pixel_Sizes

④选择charmap：FT_Select_Charmap

⑤根据编码值charcode找到glyph : glyph_index = FT_Get_Char_Index（face，charcode）

⑥根据glyph_index取出glyph：FT_Load_Glyph（face，glyph_index）

⑦转为位图：FT_Render_Glyph

⑧移动或旋转:FT_Set_Transform

### 1.7 在LCD上显示一个矢量字体



![img](https://pic4.zhimg.com/80/v2-9fc2145ff89bd4e65b6bbd093e59a6b3_720w.webp)



我们可以参考上图位置的c程序，编写程序。

①初始化freetype库

程序文件：freetype_show_font.c

```c
4872    error = FT_Init_FreeType( &library );       /* initialize library */
```

②用freetype库中的FT_New_Face函数创建一个face字体文件对象，保存在&face中

程序文件：freetype_show_font.c

```c
4875    error = FT_New_Face( library, argv[1], 0, &face ); /* create face object */
```

③提取face对象中的glyph，即关键点集

程序文件：freetype_show_font.c

```c
4877    slot = face->glyph;
```

④设置像素点大小，24*24

程序文件：freetype_show_font.c

```c
4879    FT_Set_Pixel_Sizes(face, 24, 0);
```

⑤确定坐标

 目前我们前面所用的都是LCD的坐标系对应的x与y坐标，然后在freetype上却是使用的笛卡尔坐标系，因此我们还需要转换x与y坐标。



![img](https://pic3.zhimg.com/80/v2-f8c5226dd1249e82ce583545e534fc96_720w.webp)



我们将要显示的是‘繁’字，根据上图可知，先计算在lcd坐标系的情况下‘繁’字

的左下角的x坐标与y坐标，因为在笛卡尔坐标中左下角为字符的原点，‘A’是的左上角为整个屏幕的中心点，即（xres/2，yres/2）。

- lcd_x = var.xres/2 + 8 + 16；lcd_y = var.yres/2 + 16
- 则笛卡尔座标系:x = lcd_x = var.xres/2 + 8 + 16 ； y = var.yres - lcd_y = var.yres/2 – 16
- 单位是1/64像素，所以需要乘以64

程序文件：freetype_show_font.c

```c
4888    pen.x = (var.xres/2 + 8 + 16) * 64;
4889    pen.y = (var.yres/2 - 16) * 64;
4890
4891    /* set transformation */
4892    FT_Set_Transform( face, 0, &pen);
```

⑥找到glyph的位置，然后取出，并转换为位图

```c
4895    error = FT_Load_Char( face, chinese_str[0], FT_LOAD_RENDER );
4896    if (error)
4897    {
4898        printf("FT_Load_Char error\n");
4899        return -1;
4900    }
```



![img](https://pic1.zhimg.com/80/v2-e93d2b160daf6e0c6046fb71d886c540_720w.webp)



FT_Load_Char函数调用替代了上图这3步。

最后把转换出来的位图打印出来，也是参考example1.c编写

程序文件：freetype_show_font.c

```c
4902      draw_bitmap( &slot->bitmap,
4903                    slot->bitmap_left,
4904                    var.yres - slot->bitmap_top);
```

程序文件：example1.c



![img](https://pic2.zhimg.com/80/v2-654b1ab756a0a6cda5334a2b2555354d_720w.webp)



修改上图3处位置

- Width宽度：因为在LCD上显示，宽度自然就是x方向的像素点数，var.xres；
- Height高度：因为在LCD上显示，高度自然就是y方向的像素点数，var.yres；
- 用点阵实验中的的描点函数lcd_put_pixel替代image数组

lcd_put_pixel(i, j, bitmap->buffer[q * bitmap->width + p]);

⑥编译C程序文件freetype_show_font.c

编译命令：arm-linux-gnueabihf-gcc -finput-charset=GBK -fexec-charset=GBK -o freetype_show_font freetype_show_font.c -lfreetype -lm

⑦将编译好的freetype_show_font的文件与simsun.ttc字体文件拷贝至开发板，simsun.ttc字体文件放在freetype_show_font执行文件的上一层目录下，执行以下命令。

执行命令：./freetype_show_font ../simsun.ttc

如果实验成功，我们将看到屏幕中间会比之前实验多出一个蓝色的‘繁’字。

### 1.8 在LCD上令矢量字体旋转某个角度

在实现显示一个矢量字体后，我们可以添加让该字旋转某个角度的功能。

我们根据输入的第二个参数，判断其旋转角度，主要代码还是参照example1.c



![img](https://pic3.zhimg.com/80/v2-7f05393ea04568ce396ce313c2f3998a_720w.webp)



根据上图，增加旋转角度功能，旋转的角度由执行命令的第二个参数指定。

程序文件：freetype_show_font_angle.c

```c
/* use 25 degrees */
4894    angle = ( 1.0 * strtoul(argv[2], NULL, 0) / 360 ) * 3.14159 * 2;

4895    /* set up matrix */
4896    matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
4897    matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
4898    matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
4899    matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );
4900
4901    /* set transformation */
4902    FT_Set_Transform( face, &matrix, &pen);
```

最后编译，在开发板上运行

编译命令如下：

编译命令：arm-linux-gnueabihf-gcc -finput-charset=GBK -fexec-charset=GBK -o freetype_show_font_angle freetype_show_font_angle.c -lfreetype -lm

编译出的文件名为freetype_show_font_angle，将文件拷贝至开发板

在含有该文件的目录下执行以下命令，以下命令正确执行前提是执行文件freetype_show_font在此目录，而且字体文件simsun.ttc，在上一级目录：

执行命令：./freetype_show_font_angle ../simsun.ttc 90

如果实验成功，我们将看到屏幕中间的蓝色‘繁’字，旋转了90度。

## 2 图像处理

### 2.1 BMP图像处理

#### 2.1.1 BMP文件格式解析

 BMP是一种常见的图像格式，BMP文件可看成由4个部分组成：位图文件头(bitmap-file header)、位图信息头(bitmap-information header)、调色板(color palette)和定义位图的字节阵列。以最简单的24位真彩色BMP文件作例子讲解：

1. 位图文件头(bitmap-file header)

这部分可以理解为是一个结构体，里面的每一个成员都表示一个属性

位数文件头由以下信息组成：

![img](https://pic3.zhimg.com/80/v2-e879b6756c8b8afeec4d2aad3146b5ee_720w.webp)

我们用UltraEdit打开一个BMP文件，可以看到如下信息



![img](https://pic3.zhimg.com/80/v2-c759ac2eb63233682b5d010bf9118206_720w.webp)



这是该BMP文件前32字节的数据，可以看到，前两个字节分别为0x42,0x4D；

接着后面4个字节依次是0x36,0xF9,0x15,0x00。

 在BMP格式中，文件的存储方式是小端模式，即如果一个数据需要用几个字节来表示的话，那么，低位数据存在低位地址上，高位数据存在高位地址上。类似的，还有大端模式，即：如果一个数据需要用几个字节来表示的话，那么，低位数据存在高位地址上，高位数据存在低位地址上。

所以0x36,0xF9,0x15,0x00四个数据拼接方法应该是：0x0015F936(在数字中个位即最右边才是最低位)，它正好就是这个文件的大小：



![img](https://pic1.zhimg.com/80/v2-4c06cb112964f5203f3f432ed07b5fb8_720w.webp)



紧接着是4个保留位字节，其数据必须为0x00。

最后是4个字节的便宜位，可以看到位图文件头+位图信息头+调色板的大小应该是0x36。

1. 位图信息头(bitmap-information header)

位图信息头也可以理解为是一个结构体，其成员有：

![img](https://pic4.zhimg.com/80/v2-f04b76c7e4a9fcc6e2d6a9df385b025f_720w.webp)

对照源文件数据：



![img](https://pic2.zhimg.com/80/v2-6859eb2a8247f39109c6e9112fd7f135_720w.webp)



0E-11：00000028h = 40,表示这个结构体大小是40字节。

12-15：00000320h = 800，图像宽为800像素。

16-19：00000258h = 600，图像高为600像素，与文件属性一致。这是一个正数，说明图像是正向的，数据是以图像左下角为原点，以水平向右为X轴正方向，以垂直向上为Y轴正方向排列的。若为负，则说明图像是反向的，数据是以图像左上角角为原点，以水平向右为X轴正方向，以垂直向下为Y轴正方向排列的。

1A-1B：0001h, 该值总为1。

1C-1D：0018h = 24, 表示每个像素占24个比特，即24位真彩色

上面这几个信息跟文件属性是一致的：



![img](https://pic3.zhimg.com/80/v2-32790d7352d5ac6c271f5acf61441612_720w.webp)



1E-21：00000000h，BI_RGB， 说明本图像不压缩。

22-25：00000000h，图像的大小，因为使用BI_RGB，所以设置为0。

26-29：00000000h，水平分辨率，缺省。

2A-2D：00000000h，垂直分辨率，缺省。

2E-31：00000000h，对于24位真彩色来说，是没有调色板的，所以为0。

32-35：00000000h，对于24位真彩色来说，是没有调色板的，所以为0。

1. 调色板(color palette)

24位真彩色没有调色板，这里为了简化不赘诉。

1. 定义位图的字节阵列

这一部分就是真正的图像数据了，24位真彩色数据是按按BGR各一字节循环排列而成。

#### 2.1.2 代码实现：将BMP文件解析为RGB格式，在LCD上显示

让BMP文件在开发板的LCD上显示出来，有几个需要注意的点：

1. 开发板LCD上的显示格式是RGB格式的，而且有多种表示格式：可能用2字节表示（RGB565格式），可能用3字节表示（RGB888），而原始的24位真彩色BMP文件则是按BGR格式排列的，需要对原始的图像数据进行转化。
2. 在转化过程中，LCD上的显存地址固定是以LCD左上角为首地址，而BMP格式中正向图像是以图片的左下角为数据首地址的。因此在进行数据转化时还需要注意坐标的变换。

代码清单2.1实现了将24位真彩色的BMP图像转化为RGB格式

```c
代码清单2.1
1.  /********************************************************************** 
2.   * 函数名称： IsBmp 
3.   * 功能描述： 判断该文件是否为BMP文件 
4.   * 输入参数： ptFileMap - 内含文件信息 
5.   * 输出参数： 无 
6.   * 返 回 值： 0 - 是BMP格式, -1 -不是BMP格式 
7.   ***********************************************************************/  
8.  int IsBmp(FILE **ppFp, const char *strFileName)   
9.  {  
10.     char strCheckHeader[2];   
11.     *ppFp= fopen(strFileName, "rb+");  
12.     if (*ppFp== NULL) {  
13.         return -1;  
14.     }  
15.     if (fread(strCheckHeader, 1, 2, *ppFp) != 2)   
16.         return -1;  
17.       
18.     if (strCheckHeader[0] != 0x42 || strCheckHeader[1] != 0x4d)  
19.         return -1;  
20.     else  
21.         return 0;  
22. }  
23.   
24.   
25.   
26. /********************************************************************** 
27.  * 函数名称： MapFile 
28.  * 功能描述： 使用mmap函数映射一个文件到内存,以后就可以直接通过内存来访问文件 
29.  * 输入参数： PT_PictureData ptData 内含图像数据 
30.  * 输出参数： ptData->iFileSize     : 文件大小 
31.  *                        ptData->pucFileData : 映射内存的首地址 
32.  * 返 回 值： 0      - 成功其他值 - 失败 
33.  ***********************************************************************/  
34. int MapFile(PT_PictureData ptData)  
35. {  
36.     int iFd;  
37.     struct stat tStat;  
38.       
39.     /* 打开文件 */  
40.         iFd = fileno(ptData->ptFp);  
41.     fstat(iFd, &tStat);  
42.     ptData->iFileSize= tStat.st_size;  
43.     ptData->pucFileData= (unsigned char *)mmap(NULL , tStat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, iFd, 0);  
44.     if (ptData->pucFileData == (unsigned char *)-1)  
45.     {  
46.         printf("mmap error!\n");  
47.         return -1;  
48.     }  
49.     return 0;  
50. }  
51.   
52. /********************************************************************** 
53.  * 函数名称： DecodeBmp2Rgb 
54.  * 功能描述：把BMP文件转化为rgb格式 
55.  * 输入参数： strFileName - 文件名 
56.  *                   ptData - 内含图像信息 
57.  * 返 回 值： 0      - 成功其他值 - 失败 
58.  *                         -1     - 文件不是BMP格式 
59.  *                         -2     - 不支持的bpp 
60.  *                         -3     - 图像缓存区分配失败 
61.  ***********************************************************************/  
62. static int DecodeBmp2Rgb(const char *strFileName, PT_PictureData ptData) {  
63.     int x,y;  
64.     int iPos = 0;  
65.     int iLineWidthAlign;  
66.     BITMAPFILEHEADER *ptBITMAPFILEHEADER;  
67.     BITMAPINFOHEADER *ptBITMAPINFOHEADER;  
68.     unsigned char *aFileHead;  
69.     unsigned char *pucSrc;  
70.     unsigned char *pucDest;  
71.     int iLineBytes;  
72.   
73.     /* 判断该文件是否为BMP格式 */  
74.     if (IsBmp(&ptData->ptFp, strFileName))   
75.         return -1;  
76.   
77.     /* 将BMP文件映射到内存空间 */   
78.     MapFile(ptData);  
79.   
80.   
81.     aFileHead = ptData->pucFileData;  
82.   
83.     ptBITMAPFILEHEADER = (BITMAPFILEHEADER *)aFileHead;  
84.     ptBITMAPINFOHEADER = (BITMAPINFOHEADER *)(aFileHead + sizeof(BITMAPFILEHEADER));  
85.     /* 获取必要的图像信息 */  
86.     ptData->iWidth = ptBITMAPINFOHEADER->biWidth;  
87.     ptData->iHeight = ptBITMAPINFOHEADER->biHeight;  
88.     ptData->iBpp = ptBITMAPINFOHEADER->biBitCount;  
89.         iLineBytes    = ptData->iWidth*ptData->iBpp/8;//一行数据的字节数  
90.     ptData->iBmpDataSize= ptData->iHeight * iLineBytes;//整个BMP图像的字节数  
91.     /*暂时只支持24bpp格式*/  
92.     if (ptData->iBpp != 24)  
93.     {  
94.         printf("iBMPBpp = %d\n", ptData->iBpp);  
95.         printf("sizeof(BITMAPFILEHEADER) = %d\n", sizeof(BITMAPFILEHEADER));  
96.         return -2;  
97.     }  
98.   
99.     /* 分配空间 */  
100.        ptData->pucBmpData = malloc(ptData->iBmpDataSize);  
101.        ptData->pucRgbData = malloc(ptData->iBmpDataSize);  
102.          
103.        if (NULL == ptData->pucBmpData||NULL == ptData->pucRgbData)  
104.            return -2;  
105.      
106.        /* 从bmp文件中读取图像信息，24bpp的BMP图像为BGR格式 */  
107.        pucDest = ptData->pucBmpData;  
108.        iLineWidthAlign = (iLineBytes + 3) & ~0x3;   /* 向4取整 */  
109.        pucSrc = aFileHead + ptBITMAPFILEHEADER->bfOffBits;  
110.      
111.        pucSrc = pucSrc + (ptData->iHeight - 1) * iLineWidthAlign;  
112.      
113.        /* 对于bmp文件中的源数据，是以左下角为原点计算坐标的，因此拷贝数据时需要转换坐标 */  
114.        for (y = 0; y < ptData->iHeight; y++)  
115.        {         
116.            memcpy(pucDest, pucSrc, ptData->iWidth*3);  
117.            pucSrc  -= iLineWidthAlign;  
118.            pucDest += iLineBytes;  
119.        }  
120.      
121.          
122.        /* 将得到的BGR数据转化为RGB数据 */  
123.        for (y = 0; y < ptData->iHeight; y++){          
124.            for(x = 0;x<ptData->iWidth*3;x+=3){  
125.                ptData->pucRgbData[iPos++] = ptData->pucBmpData[y*ptData->iWidth*3+x+2];  
126.                ptData->pucRgbData[iPos++] = ptData->pucBmpData[y*ptData->iWidth*3+x+1];  
127.                ptData->pucRgbData[iPos++] = ptData->pucBmpData[y*ptData->iWidth*3+x+0];  
128.            }  
129.        }  
130.          
131.        return 0;     
132.      
133.    }
```

### 2.2 JPEG图像处理

#### 2.2.1 JPEG文件格式和libjpeg编译

 JPEG的后缀名为.jpg的图像文件。对于图像内容和信息相同的JPEG文件和BMP文件，JPEG格式的文件要比BMP格式的文件小得多，这是因为JPEG文件是经过JPEG压缩算法后得到的一种文件格式。

 相对于BMP格式的文件，JPEG由于压缩算法的关系，其文件解析较为复杂，我们可以利用Linux系统开源的优点，使用开源工具对jpeg文件进行格式的解析和转换。

 我们可以使用libjpeg库来对jpeg文件进行格式的解析和转换。libjpeg支持X86，ARM等架构。libjpeg是开源工具，所以可以在网上免费下载。

 在使用libjpeg之前，我们先要交叉编译libjpeg的库文件和头文件并存到开发板的文件系统中。以下是libjpeg的编译过程：

1. 解压并进入文件目录

```c
tar xzf libjpeg-turbo-1.2.1.tar.gz
cd libjpeg-turbo-1.2.1/
```

1. 交叉编译

```c
tar xzf libjpeg-turbo-1.2.1.tar.gz
./configure --prefix=/work/projects/libjpeg-turbo-1.2.1/tmp/ --host=arm-linux
make
make install
```

1. 将编译出来的头文件和库文件拷贝到交叉编译器的相应目录下

```c
cd /work/projects/libjpeg-turbo-1.2.1/tmp/include
cp * /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/usr/include
cd /work/projects/libjpeg-turbo-1.2.1/tmp/lib
cp *so* -d /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/armv4t/lib
```

1. 将编译出来的头文件和库文件拷贝到开发板文件系统的相应目录下

```c
cd /work/projects/libjpeg-turbo-1.2.1/tmp/lib
cp *.so* /work/nfs_root/fs_mini_mdev_new/lib/ -d
```

#### 2.2.2 libjpeg接口函数的解析和使用

libjpeg的使用方法可以参考解压包中的使用说明libjpeg.txt和例程example.c。libjpeg的使用步骤简单总结如下：

**1.** 分配和初始化一个jpeg_compress_struct结构体

```c
cinfo.err = jpeg_std_error(&jerr);
jpeg_create_decompress(&cinfo);
```

**2.** 指定源文件

```c
jpeg_stdio_src(&cinfo, infile);
```

参数1是步骤1中分配的jpeg_compress_struct类型的结构体

参数2是要解析的JPEG文件的文件句柄。

**3.** 获得jpg信息头并设置解压参数

```c
jpeg_read_header(&cinfo, TRUE);
```

当调用完这个参数之后，我们就可以通过cinfo中的image_width，image_height等成员来获得图像的信息了。此外我们还可以设置cinfo中的scale_num和scale_denom等成员变量来设置解压参数。

**4.** 启动解压

```c
jpeg_start_decompress(&cinfo);
```

调用这个函数后，就可以对cinfo所指定的源文件进行解压，并将解压后的数据存到cinfo结构体的成员变量中。

**5.** 读取解压后数据

```c
jpeg_read_scanlines(&cinfo, buffer, 1);
```

调用这个函数后，可以读取RGB数据到buffer中，参数3能指定读取多少行

**6.** 完成读取

```c
jpeg_finish_decompress(&cinfo);
```

**7.** 释放jpeg_compress_struct结构体

```c
jpeg_destroy_decompress(&cinfo);
```

完成读取后释放结构体

#### 2.2.3 使用libjpeg把JPEG文件解析为RGB格式，在LCD上显示

根据上节的解析，利用上述的库函数将JPEG文件解析为RGB格式了。

```c
代码清单2.2
1.  /********************************************************************** 
2.   * 函数名称： IsJpg 
3.   * 功能描述：判断是否为Jpg文件 
4.   * 输入参数： ptData - 内含图像信息 
5.                      strFileName - 文件名 
6.   * 返 回 值：0 - 不是JPG格式 其他-是JPG格式 
7.   ***********************************************************************/  
8.  static int IsJpg(PT_PictureData ptData, const char *strFileName)   
9.  {  
10.     int iRet;  
11.   
12.     jpeg_stdio_src(&ptData->tInfo, ptData->ptFp);  
13.   
14.     /* 用jpeg_read_header获得jpeg信息*/  
15.     iRet = jpeg_read_header(&ptData->tInfo, TRUE);  
16.       
17.         return (iRet == JPEG_HEADER_OK);  
18. }  
19.   
20. /********************************************************************** 
21.  * 函数名称： DecodeJpg2Rgb 
22.  * 功能描述：把JPG文件解析为RGB888格式 
23.  * 输入参数： ptData - 内含文件信息 
24.  *                             strFileName - 文件名 
25.  * 输出参数：PT_PictureData->pucRgbData - 内含rgb数据 
26.  * 返 回 值：0 - 成功 其他-失败 
27.  ***********************************************************************/  
28. static int DecodeJpg2Rgb(const char *strFileName, PT_PictureData ptData){  
29.     int iRowSize;  
30.     unsigned char *pucbuffer;  
31.     unsigned char *pucHelp;//辅助拷贝变量  
32.       
33.     /* 1.分配和初始化一个jpeg_compress_struct结构体 */  
34.     ptData->tInfo.err = jpeg_std_error(&ptData->tJerr);  
35.     jpeg_create_decompress(&ptData->tInfo);  
36.   
37.   
38.     /* 2.指定源文件*/  
39.     if ((ptData->ptFp= fopen(strFileName, "rb")) == NULL) {  
40.         fprintf(stderr, "can't open %s\n", strFileName);  
41.         return -1;  
42.     }  
43.   
44.     /* 3.获得jpg信息头并设置解压参数并判断是否为JPEG格式文件 */  
45.     if (!IsJpg(ptData, strFileName)) {  
46.     printf("file is not jpg ...\n");  
47.     return -1;  
48.     }   
49.   
50.       
51.   
52.     /* 默认尺寸为原尺寸 */  
53.     ptData->tInfo.scale_num = 1;  
54.     ptData->tInfo.scale_denom = 1;  
55.     /* 4. 启动解压：jpeg_start_decompress */   
56.     jpeg_start_decompress(&ptData->tInfo);  
57.   
58.   
59.     /* 解压完成后可以通过tInfo中的成员获得图像的某些信息 */  
60.     ptData->iWidth= ptData->tInfo.output_width;  
61.     ptData->iHeight = ptData->tInfo.output_height;  
62.     ptData->iBpp = ptData->tInfo.output_components*8;  
63.     /* 计算一行的数据长度 */   
64.     iRowSize = ptData->iWidth * ptData->tInfo.output_components;  
65.     pucbuffer = malloc(iRowSize);  
66.     ptData->iRgbSize= iRowSize * ptData->iHeight;  
67.     ptData->pucRgbData = malloc(ptData->iRgbSize);  
68.   
69.     /* pucHelp指向ptData->pucRgbData首地址 */  
70.     pucHelp = ptData->pucRgbData;  
71.     /*  5.循环调用jpeg_read_scanlines来一行一行地获得解压的数据 */  
72.     while (ptData->tInfo.output_scanline < ptData->tInfo.output_height)   
73.     {  
74.         /* 调用jpeg_read_scanlines得到的时候会存到pucbuffer中 */  
75.         jpeg_read_scanlines(&ptData->tInfo, &pucbuffer, 1);  
76.         /* 将数据一行行读到缓冲区中 */  
77.         memcpy(pucHelp,pucbuffer,iRowSize);  
78.         pucHelp  += iRowSize;  
79.     }  
80.     free(pucbuffer);  
81.     /* 6.完成读取 */  
82.     jpeg_finish_decompress(&ptData->tInfo);  
83.     /* 7.释放jpeg_compress_struct结构体 */  
84.     jpeg_destroy_decompress(&ptData->tInfo);  
85.     return 0;  
86. }
```

### 2.3 PNG图像处理

#### 2.3.1 PNG文件格式和libpng编译

 跟JPEG文件格式一样，PNG也是一种使用了算法压缩后的图像格式，与JPEG不同，PNG使用从LZ77派生的无损数据压缩算法。对于PNG文件格式，也有相应的开源工具libpng。

libpng库可从官网上下载最新的源代码：

[http://www.libpng.org/pub/png/libpng.html](https://link.zhihu.com/?target=http%3A//www.libpng.org/pub/png/libpng.html)

在使用libpng之前，我们先要交叉编译libpng的库文件和头文件并存到开发板的文件系统中。以下是libpng的编译过程：

1. 解压并进入文件目录

```c
tar xzf libpng-1.6.37.tar.gz
cd libpng-1.6.37/
```

1. 交叉编译

```c
./configure --prefix=/work/projects/libpng-1.6.37/tmp/ --host=arm-linux
make
make install
```

1. 将编译出来的头文件和库文件拷贝到交叉编译器的相应目录下

```c
cd /work/projects/libpng-1.6.37/tmp/include
cp * /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/usr/include
cd /work/projects/libpng-1.6.37/tmp/lib
cp *so* -d /usr/local/arm/4.3.2/arm-none-linux-gnueabi/libc/armv4t/lib
```

1. 将编译出来的头文件和库文件拷贝到开发板文件系统的相应目录下

```c
cd /work/projects/libpng-1.6.37/tmp/lib
cp *.so* /work/nfs_root/fs_mini_mdev_new/lib/ -d
```

#### 2.3.2 libpng接口函数的解析和使用

libpng的使用方法可以参考解压包中的使用说明libpng-manual.txt和例程example.c。libjpeg的使用步骤简单总结如下：

1. 分配和初始化两个与libpng相关的结构体png_ptr，info_ptr

A. png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);

 参数2，3，4分别是用户自定义的错误处理函数，若无，则填NULL。

 B. info_ptr = png_create_info_struct(png_ptr);

1. 设置错误返回点

setjmp(png_jmpbuf(png_ptr));

当出现错误时，libpng将会自动调用返回到这个点。在这个点我们可以进行一些清理工作。如果在调用png_create_read_struct时没有设置自定义的错误处理函数，这一步是必须要做的。

1. 指定源文件

png_init_io(png_ptr, fp);

参数1是步骤1中分配的png_ptr结构体，参数2是需要解析的PNG文件的文件句柄。

1. 获取PNG图像的信息

A. 解析图片数据信息

png_read_png(png_ptr, info_ptr, png_transforms, png_voidp_NULL);

该函数会把所有的图片数据解码到info_ptr数据结构中。至于转化为什么格式，由参数png_transforms决定，它是一个整型参数，可以使用libpng库中定义的宏进行传参。这个参数相关的宏有很多，具体的可以参考库中的相关文件的解析。

B.查询图像信息

此外，我们还可以通过png_get_image_width，png_get_image_height，png_get_color_type等函数获得png图像的宽度，高度，颜色类型等信息，更多的图像信息获取函数可以在文件pngget.c中找到。

1. 将info_ptr中的图像数据读取出来

有两种读取PNG图像信息的方法：

A. 一次性把所有的数据读入内存

png_read_image(png_ptr, row_pointers);

参数1是步骤1中分配的png_ptr，参数2是存放图片数据的指针。

B. 也可以逐行读取

row_pointers = png_get_rows(png_ptr, info_ptr);

参数1和参数2分别是步骤1中分配的png_ptr, info_ptr，返回值是每行数据的首地址。

参数1是步骤1中分配的png_ptr，参数2是存放图片数据的指针。

1. 销毁内存

png_destroy_read_struct(&png_ptr, &info_ptr, 0);

#### 2.3.3 使用libpng把png文件转为rgb格式，在LCD上显示

```c
代码清单2.3
1.  /********************************************************************** 
2.   * 函数名称： IsnotPng 
3.   * 功能描述：判断是否为PNG文件 
4.   * 输入参数： ppFp - 文件句柄指针 
5.                      strFileName - 文件名 
6.   * 返 回 值：0 - 是PNG格式 其他-不是PNG格式 
7.   ***********************************************************************/  
8.  int IsnotPng(FILE **ppFp, const char *strFileName)   
9.  {  
10.     char strCheckHeader[8];   
11.     *ppFp= fopen(strFileName, "rb");  
12.     if (*ppFp== NULL) {  
13.         return -1;  
14.     }  
15.     /* 读取PNG文件前8个字节，使用库函数png_sig_cmp即可判断是否为PNG格式 */  
16.     if (fread(strCheckHeader, 1, 8, *ppFp) != 8)   
17.         return -1;  
18.     return png_sig_cmp(strCheckHeader, 0, 8);   
19.   
20. }  
21.   
22. /********************************************************************** 
23.  * 函数名称： DecodePng2Rgb 
24.  * 功能描述：把PNG文件解析为RGB888格式 
25.  * 输入参数： ptData - 内含文件信息 
26.  *                             strFileName - 文件名 
27.  * 输出参数：PT_PictureData->pucRgbData - 内含rgb数据 
28.  * 返 回 值：0 - 成功 其他-失败 
29.  ***********************************************************************/  
30. static int DecodePng2Rgb(const char *strFileName, PT_PictureData ptData)   
31. {      
32.     int i, j;  
33.     int iPos = 0;  
34.     png_bytepp pucPngData;   
35.     /* 0.判断该文件是否为PNG格式 */  
36.     if (IsnotPng(&ptData->ptFp, strFileName)) {  
37.         printf("file is not png ...\n");  
38.         return -1;  
39.     }   
40.   
41.     /* 1.分配和初始化两个与libpng相关的结构体png_ptr，info_ptr */  
42.     ptData->ptPngStrPoint  = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);   
43.     ptData->ptPngInfoPoint= png_create_info_struct(ptData->ptPngStrPoint);  
44.   
45.     /* 2.设置错误的返回点 */  
46.     setjmp(png_jmpbuf(ptData->ptPngStrPoint));  
47.     rewind(ptData->ptFp); //等价fseek(fp, 0, SEEK_SET);  
48.   
49.     /* 3.指定源文件 */  
50.     png_init_io(ptData->ptPngStrPoint, ptData->ptFp);  
51.   
52.     /* 4.获取PNG图像数据信息和通道数，宽度，高度等  
53.       * 使用PNG_TRANSFORM_EXPAND宏做参数的作用是根据通道数的不同， 
54.       * 将PNG图像转换为BGR888或ABGR8888格式*/  
55.     png_read_png(ptData->ptPngStrPoint, ptData->ptPngInfoPoint, PNG_TRANSFORM_EXPAND, 0);   
56.     ptData->iChannels    = png_get_channels(ptData->ptPngStrPoint, ptData->ptPngInfoPoint);   
57.     ptData->iWidth    = png_get_image_width(ptData->ptPngStrPoint, ptData->ptPngInfoPoint);  
58.     ptData->iHeight  = png_get_image_height(ptData->ptPngStrPoint, ptData->ptPngInfoPoint);  
59.   
60.   
61.     /* 5.将info_ptr中的图像数据读取出来 */  
62.     pucPngData = png_get_rows(ptData->ptPngStrPoint, ptData->ptPngInfoPoint); //也可以分别每一行获取png_get_rowbytes();  
63.     if (ptData->iChannels == 4) { //判断是24位还是32位  
64.         ptData->iRawSize= ptData->iWidth * ptData->iHeight*4; //申请内存先计算空间    
65.         ptData->pucRawData= (unsigned char*)malloc(ptData->iRawSize);  
66.         if (NULL == ptData->pucRawData) {  
67.             printf("malloc rgba faile ...\n");  
68.             png_destroy_read_struct(&ptData->ptPngStrPoint, &ptData->ptPngInfoPoint, 0);  
69.             fclose(ptData->ptFp);  
70.             return -1;  
71.         }  
72.         /* 从pucPngData里读出实际的RGBA数据出来  
73.          * 源数据为ABGR格式*/  
74.         for (i = 0; i < ptData->iHeight; i++)   
75.             for (j = 0; j < ptData->iWidth * 4; j += 4) {  
76.                     ptData->pucRawData[iPos++] = pucPngData[i][j + 3];  
77.                     ptData->pucRawData[iPos++] = pucPngData[i][j + 2];  
78.                     ptData->pucRawData[iPos++] = pucPngData[i][j + 1];  
79.                     ptData->pucRawData[iPos++] = pucPngData[i][j + 0];  
80.                 }  
81.   
82.         /* 将得到的RGBA转换为RGB888格式 */  
83.         if(RgbaToRgb(ptData)!=0)  
84.             return -1;  
85.   
86.     }  
87.     else if (ptData->iChannels == 3 ) { //判断颜色深度是24位还是32位  
88.         ptData->iRgbSize= ptData->iWidth * ptData->iHeight*3; //申请内存先计算空间    
89.         ptData->pucRgbData = (unsigned char*)malloc(ptData->iRgbSize);  
90.         if (NULL == ptData->pucRgbData) {  
91.             printf("malloc rgba faile ...\n");  
92.             png_destroy_read_struct(&ptData->ptPngStrPoint, &ptData->ptPngInfoPoint, 0);  
93.             fclose(ptData->ptFp);  
94.             return -1;  
95.         }  
96.         /* 从pucPngData里读出实际的RGB数据 
97.           * 源数据为BGR格式*/  
98.         for (i = 0; i < ptData->iHeight; i ++) {  
99.             for (j = 0; j < ptData->iWidth*3; j += 3) {  
100.                    ptData->pucRgbData[iPos++] = pucPngData[i][j+2];  
101.                    ptData->pucRgbData[iPos++] = pucPngData[i][j+1];  
102.                    ptData->pucRgbData[iPos++] = pucPngData[i][j+0];  
103.                }  
104.            }  
105.            ptData->iBpp = 24;//转化之后的格式为RGB888格式  
106.        }   
107.        else return -1;   
108.      
109.          
110.        /* 6:销毁内存 */  
111.        png_destroy_read_struct(&ptData->ptPngStrPoint, &ptData->ptPngInfoPoint, 0);  
112.        fclose(ptData->ptFp);  
113.      
114.      
115.        return 0;  
116.    }
```

### 2.4 图像调整

#### 2.4.1 图像的缩放

##### 2.4.1.1 图像缩放算法浅析

图像缩放算法有很多种，这里参考网友"lantianyu520"所著的"图像缩放算法"。

原理浅析

 要理解这个图像缩放算法的原理，最重要的是需要理解：对于图像上的每一个像素点，它缩放前后，相对于整个图像的比例应该是一样的。

比如：

 以一个长度和宽度分别为200，100的长方形为例，将其放大两倍，那么缩放后的长度和宽度为400，200。

为方便理解，我们建立一个笛卡尔坐标系，把这个长方形左下角的顶点放到坐标(0,0)位置，四个点的坐标分别为：(0,0),(0,100),(200,0),(200,100)。

 假设此时对长方形中的坐标点(40,50)，它的x坐标相对于长的比值是40/200=0.2，y坐标相对于宽的比值是50/100=0.5，那么该点的变换后的坐标Dx,Dy则应满足：Dx/400 = 5;Dy/200 = 0.5，这样，缩放后的坐标就可以算出来了。

 根据上面的分析，设缩放前的像素点坐标为(Sx,Sy)，对应的缩放后的像素点坐标为(Dx,Dy)，缩放前的图像长宽分别为Sw,Sh，缩放后的图像长宽分别为Dw,Dh，则有：

Sx/Dx = Sw/Dw，Sy/Dy = Sh/Dh

故有Sx = Dx * Sw/Dw，Sy = Dy * Sh/Dh，

##### 2.4.1.2源码编写：图像缩放算法

有了这个上面两条等式后，图像缩放算法的代码就好理解了。

下面的函数实现了基于上述原理实现的图像缩放算法：

```c
代码清单2.4
1.  /********************************************************************** 
2.   * 函数名称： PicZoom 
3.   * 功能描述： 近邻取样插值方法缩放图片 
4.   *            注意该函数会分配内存来存放缩放后的图片,用完后要用free函数释放掉 
5.   *            "近邻取样插值"的原理请参考网友"lantianyu520"所著的"图像缩放算法" 
6.   * 输入参数： ptPicData - 内含缩放前后的图像数据 
7.   *            fSize    - 缩放倍数 
8.   * 输出参数： ptPicData->pucZoomData,内含缩放后的数据 
9.   * 返 回 值： 0 - 成功, 其他值 - 失败 
10.  ***********************************************************************/  
11. int PicZoom(PT_PictureData ptPicData,float fSize)  
12. {  
13.     ptPicData->iZoomWidth = ptPicData->iWidth * fSize;  
14.     ptPicData->iZoomHeight= ptPicData->iHeight* fSize;  
15.     unsigned long* pdwSrcXTable;  
16.     unsigned long x;  
17.     unsigned long y;  
18.     unsigned long dwSrcY;  
19.     unsigned char *pucDest;  
20.     unsigned char *pucSrc;  
21.     unsigned long dwPixelBytes = ptPicData->iBpp/8;  
22.     ptPicData->pucZoomData= malloc(sizeof(unsigned char) * ptPicData->iZoomWidth*ptPicData->iZoomHeight*ptPicData->iBpp/8);  
23.     pdwSrcXTable = malloc(sizeof(unsigned long) * ptPicData->iZoomWidth);  
24.     if (NULL == pdwSrcXTable){  
25.         printf("malloc error!\n");  
26.         return -1;  
27.     }  
28.   
29.     /* 这几个for循环的本质是Sx = Dx * Sw/Dw，Sy = Dy * Sh/Dh*/  
30.     for (x = 0; x < ptPicData->iZoomWidth; x++){//生成表 pdwSrcXTable  
31.         /* 第一个for循环对应x方向的坐标 
32.      * pdwSrcXTable[x] 对应Sx, 
33.      * x 对应Dx, 
34.      * ptPicData->iWidth 对应Sw 
35.      * ptPicData->iZoomWidth 对应 Dw*/   
36.         pdwSrcXTable[x]=(x*ptPicData->iWidth/ptPicData->iZoomWidth);  
37.     }  
38.   
39.     for (y = 0; y < ptPicData->iZoomHeight; y++){  
40.     /* 第2个循环对应y方向的坐标 
41.      * dwSrcY 对应Sy, 
42.      * y 对应Dy, 
43.      * ptPicData->iHeight 对应Sh 
44.      * ptPicData->iZoomHeight 对应 Dh*/      
45.         dwSrcY = (y * ptPicData->iHeight / ptPicData->iZoomHeight);  
46.     /* 根据这些可算得各像素点的RGB数据存放的地址 */  
47.         pucDest = ptPicData->pucZoomData + y*ptPicData->iZoomWidth*3;  
48.         pucSrc  = ptPicData->pucRgbData + dwSrcY*ptPicData->iWidth*3;  
49.   
50.     /* 最后拷贝数据 */          
51.         for (x = 0; x <ptPicData->iZoomWidth; x++){  
52.              memcpy(pucDest+x*dwPixelBytes, pucSrc+pdwSrcXTable[x]*dwPixelBytes, dwPixelBytes);  
53.         }  
54.     }  
55.   
56.     free(pdwSrcXTable);  
57.     return 0;  
58. }
```

#### 2.4.2 图像的旋转

##### 2.4.2.1 图像旋转算法浅析

这里的图像旋转算法原理参考网友"落叶的思维"所著的"图像旋转算法与实现"

原理浅析

这个旋转算法的原理的关键点有两个：

1. 原图像是以图像的左下角为原点建立笛卡尔坐标系的，而旋转一般是以图像的中心作为旋转点旋转的。

因此为了便于转换，我们先约定两个坐标系，一个是以图像左下角为原点建立的坐标系，称为坐标系A，这也是原图像的坐标系。一个是以图像中心为原点建立的坐标系，称为坐标系B。

由此，可以知道这个旋转算法的步骤：先将坐标系A下的坐标转换为坐标系B下的坐标，然后在坐标系B下进行图像的旋转。

在坐标系B下，我们假设点（x0，y0）距离原点的距离为r，点与原点之间的连线与x轴的夹角为b，旋转的角度为a，旋转后的点为（x1，y1）, 如下图所示。



![img](https://pic2.zhimg.com/80/v2-5fbec93d9a1768ff0c3a85476a110b81_720w.webp)



那么有以下结论：

x0=rcosb；y0=rsinb

x1 = rcos(b-a) = rcosbcosa+rsinbsina=x0cosa+y0sina；

y1=rsin(b-a)=rsinbcosa-rcosbsina=-x0sina+y0cosa；

最后，由于我们显示图像的RGB数据还是要在坐标系A下获取的，我们最后只需要将坐标系B下的x1,y1转换回坐标系A下的坐标就可以了。

旋转后的图像的长和宽会发生变化，因此要计算新图像的长和宽。

由几何关系可知，新图像的长和宽分别是旋转后，对角坐标相见后的最大值

##### 2.4.2.2 源码编写：图像旋转算法

```c
代码清单2.5
1.   #define PI 3.1415926535  
2.  //角度到弧度转化  
3.  #define RADIAN(angle) ((angle)*PI/180.0)  
4.    
5.    
6.    
7.    
8.    
9.  typedef struct ConcernCoor {  
10.     int iLTx;// left top x  
11.     int iLTy;//left top y  
12.     int iLBx;//left bottom x  
13.     int iLBy;//left bottom y  
14.     int iRTx;//right top x  
15.     int iRTy;//right top y  
16.     int iRBx;// right bottom x  
17.     int iRBy;// right bottom y  
18. }T_ConcernCoor, *PT_ConcernCoor;  
19.   
20.   
21. /********************************************************************** 
22.  * 函数名称： max 
23.  * 功能描述：比较两个参数，返回较大值 
24.  * 输入参数：x，y均为int型 
25.  * 输出参数： 无 
26.  * 返 回 值： x，y中的较大值 
27.  ***********************************************************************/  
28. static int max(int x,int y){  
29.     return x>y?x:y;  
30. }  
31. /********************************************************************** 
32.  * 函数名称： PicRotate 
33.  * 功能描述： 旋转图片 
34.  *            注意该函数会分配内存来存放缩放后的图片,用完后要用free函数释放掉 
35.  *              参考网友"落叶的思维"所著的"图像旋转算法与实现" 
36.  * 输入参数： ptPicData - 内含图片的象素数据 
37.  *            fAngle    - 旋转角度，0<=angle<=360 
38.  * 输出参数： ptPicData->pucRotateData,内含旋转后的rgb数据 
39.  * 返 回 值： 0 - 成功, 其他值 - 失败 
40.  ***********************************************************************/  
41. int PicRotate(PT_PictureData ptPicData,float fAngle)  
42. {  
43.     int i ,j;  
44.     T_ConcernCoor tConCor,tRonCor;  
45.     //原图像每一行去除偏移量的字节数  
46.     //int iSrcLineSize = bitCount * srcW / 8;  
47.     int iSrcLineSize = ptPicData->iBpp* ptPicData->iZoomWidth / 8;  
48.     int iDesLineSize;  
49.     int iX;//旋转后的x坐标  
50.     int iY; //旋转后的y坐标  
51.   
52.        /* 将坐标系A下的坐标转换为坐标系B下的坐标, 
53.         * 用于计算旋转后的图像的宽和高  
54.         * tConCor用于存放坐标系B下旋转前的坐标 
55.         * tRonCor用于存放坐标系B下旋转后的坐标*/  
56.        tConCor.iLTx = -ptPicData->iZoomWidth/2; tConCor.iLTy = ptPicData->iZoomHeight/2;  
57.     tConCor.iRTx = ptPicData->iZoomWidth/2; tConCor.iRTy = ptPicData->iZoomHeight/2;  
58.     tConCor.iLBx = -ptPicData->iZoomWidth/2;tConCor.iLBy = -ptPicData->iZoomHeight/2;  
59.     tConCor.iRBx = ptPicData->iZoomWidth/2;tConCor.iRBy = -ptPicData->iZoomHeight/2;  
60.   
61.   
62.     /* 计算坐标系B下旋转后的坐标 */  
63.     double sina = sin(RADIAN(fAngle));  
64.     double cosa = cos(RADIAN(fAngle));  
65.     tRonCor.iLTx =tConCor.iLTx * cosa + tConCor.iLTy * sina;  
66.     tRonCor.iLTy = -tConCor.iLTx * sina + tConCor.iLTy * cosa;  
67.     tRonCor.iRTx =tConCor.iRTx * cosa + tConCor.iRTy * sina;  
68.     tRonCor.iRTy = -tConCor.iRTx * sina + tConCor.iRTy * cosa;  
69.     tRonCor.iLBx = tConCor.iLBx * cosa + tConCor.iLBy * sina;  
70.     tRonCor.iLBy = -tConCor.iLBx * sina + tConCor.iLBy * cosa;  
71.     tRonCor.iRBx = tConCor.iRBx * cosa + tConCor.iRBy * sina;  
72.     tRonCor.iRBy = -tConCor.iRBx * sina + tConCor.iRBy * cosa;  
73.   
74.       
75.     /* 计算旋转后图像宽和高 */  
76.     ptPicData->iRotateWidth = max(abs(tRonCor.iRBx - tRonCor.iLTx),abs(tRonCor.iRTx - tRonCor.iLBx));  
77.     ptPicData->iRotateHeight = max(abs(tRonCor.iRBy - tRonCor.iLTy),abs(tRonCor.iRTy - tRonCor.iLBy));  
78.   
79.     /* 像素信息要保证3字节对齐，否则数据有可能出错*/  
80.     iDesLineSize = ((ptPicData->iRotateWidth* ptPicData->iBpp+ 23) / 24) * 3 ;  
81.     /* 分配旋转后的空间，注意这里要用旋转后的宽和高 */  
82.     ptPicData->pucRotateData = malloc(iDesLineSize * ptPicData->iRotateHeight);  
83.     if(NULL == ptPicData->pucRotateData){  
84.         printf("malloc error\n");  
85.         return -1;  
86.     }  
87.   
88.     /* 通过新图像的坐标，计算对应的原图像的坐标* 
89.       * i,j坐标就是对应的坐标系B下的x1,y1*/  
90.     for (i = 0; i < ptPicData->iRotateHeight; i++){          
91.         for (j = 0; j < ptPicData->iRotateWidth; j++){  
92.             /* 坐标系B下的x,y1坐标，经过逆运算转换得到iX,iY,这两个值对应x0,y0 */  
93.             iX = (j - ptPicData->iRotateWidth / 2)*cos(RADIAN(360 - fAngle)) + (-i + ptPicData->iRotateHeight / 2)*sin(RADIAN(360 - fAngle));  
94.             iY = -(j - ptPicData->iRotateWidth / 2)*sin(RADIAN(360 - fAngle)) + (-i + ptPicData->iRotateHeight / 2)*cos(RADIAN(360 - fAngle));  
95.             /*如果这个坐标不在原图像内，则不赋值*/  
96.             if (iX > ptPicData->iZoomWidth / 2 || iX < -ptPicData->iZoomWidth / 2 || iY > ptPicData->iZoomHeight / 2 || iY< -ptPicData->iZoomHeight / 2){  
97.                 continue;  
98.             }  
99.             /* 再将坐标系B下的x0,y0坐标，转换为坐标系A下的坐标 */  
100.                int iXN = iX + ptPicData->iZoomWidth / 2;   
101.             int iYN = abs(iY - ptPicData->iZoomHeight  / 2);  
102.                /* 值拷贝*/  
103.                memcpy(&ptPicData->pucRotateData[i * iDesLineSize + j * 3],&ptPicData->pucZoomData[iYN * iSrcLineSize + iXN * 3],3);    
104.            }  
105.        }  
106.      return 0;  
107.    }
```

## 3 输入系统

### 3.1 什么是输入系统？

 在了解输入系统之前，先来了解什么是输入设备？常见的输入设备有键盘、鼠标、遥控杆、书写板、触摸屏等等，用户通过这些输入设备与Linux系统进行数据交换，Linux系统为了统一管控和处理这些设备，于是就实现了一套固定的与硬件无关的输入系统框架，供用户空间程序使用，这就是输入系统。

### 3.2 输入系统应用框架描述

 在Linux输入系统中，主要分三层进行管理，分别是input core(输入系统核心层)、drivers(输入系统驱动层)以及event handlers(输入系统事件层)，如下图所示，这就是Linux输入系统的基本框架:



![img](https://pic3.zhimg.com/80/v2-b8ad56dc59337cecdafb4ccad9634f02_720w.webp)



 举个非常简单的例子，比如用户按下键盘里的其中一个按键，它遵循流程是这样的：

 按键按下-->输入系统驱动层-->输入系统核心层-->输入系统事件层--->用户空间

 对于应用程序软件编程的角度，我们只需要关注用户空间是怎么得到按键按下以后获取的是什么事件就可以了，例如我想知道我当前按下的按是短按还是长按？或者我想知道当前我按下键盘的是空格键还是回车键等等。

### 3.3 输入系统事件的读取与分析

 用户空间的设备节点那么多，怎么知道当前是哪个设备上报的呢？例如想知道键盘是由哪个设备节点上报的，就可以通过以下这条指令来获取：

```c
cat /proc/bus/input/devices
```

 这条指令的含义就是获取与event对应的相关设备信息，在ubuntu系统上，我们输入这个指令可以看到以下结果：



![img](https://pic2.zhimg.com/80/v2-1d4108d29bf793410256bc264ddf6cd9_720w.webp)



 那么这里的I、N、P、S、U、H、B对应的每一行是什么含义呢？

**I:id of the device(设备ID)**

该参数由结构体struct input_id来进行描述

```c
41 struct input_id {
42  //总线类型
43  __u16 bustype;
44  //与厂商相关ID
45  __u16 vendor;
46  //与产品相关ID
47  __u16 product;
48  //版本ID
49  __u16 version;
50 };
```

**N:name of the device**

设备名称

**P:physical path to the device in the system hierarchy**

系统层次结构中设备的物理路径。

**S:sysfs path**

位于sys文件系统的路径

**U:unique identification code for the device(if device has it)**

设备的唯一标识码

**H:list of input handles associated with the device.**

与设备关联的输入句柄列表。

**B:bitmaps(位图)**

PROP:device properties and quirks.

EV:types of events supported by the device.

KEY:keys/buttons this device has.

MSC:miscellaneous events supported by the device.

LED:leds present on the device.

PROP:设备属性和怪癖。

EV:设备支持的事件类型。

KEY:此设备具有的键/按钮。

MSC:设备支持的其他事件。

LED:设备上的指示灯。

通过了解以上参数的含义，结合以下指令

```c
cat /proc/bus/input/devices
```

显示出来的信息很容易可以知道event1即是键盘上报的事件设备节点，通过读取这个event1即可获得当前用户按下的按键具体是哪个事件。

**使用cat命令来测试键盘事件**



![img](https://pic3.zhimg.com/80/v2-48f0b39dfd84d14f949505147db740ea_720w.webp)



当我们在终端输入

```c
cat /dev/input/event1
```

 这条指令并按回车键后可以看到一堆乱码数据，这些数据我们看不懂，但是我们可以知道如果按下了按键，终端有反馈消息，这时候就知道这个事件就是我们当前操作的这个设备上报的事件，那么如何能让这些数据看得懂呢？这时候可以使用hexdump命令来读取键盘事件。

**使用hexdump命令来测试键盘事件**



![img](https://pic1.zhimg.com/80/v2-844029aeb64d4cb8c6f58c9043b2544c_720w.webp)



这些数值是通过input_event结构体来上报的，它位于/usr/include/linux/input.h这个头文件，input_event结构体描述如下：

```c
24 struct input_event {
25  //事件发生的事件
26  struct timeval time;
27  //事件类型
28  __u16 type;
29  //事件值
30  __u16 code;
31  //该事件上报的数值
32  __s32 value;
33 };
```

而input_event结构体中的time即是：

```c
1 struct timeval
2 {
3   __time_t tv_sec;        /* Seconds. */
4   __suseconds_t tv_usec;    /*Microseconds. */
5 };
```

 其中tv_sec为Epoch到创建struct timeval时的秒数，tv_usec为微秒数，即秒后面的零头，Epoch的意思是指定为1970年一月一日凌晨零点零分零秒，格林威治时间。

 回到input_event结构体，事件类型type主要有以下三种，分别是：相对事件、绝对事件、键盘事件

 例如：鼠标就是一个相对事件，有些情况下也有可能是绝对事件，当移动鼠标的时候，type类型也就是底层上报给用户的事件类型，那么code表示的就是相对于鼠标当前的位置的X或者Y的坐标，value则表示相对于当前的位置偏移了多少。

**事件类型(type)**

文件头文件路径：

```c
/usr/include/linux/input-event-codes.h
```

当然Linux内核版本较低的有可能在以下路径的这个头文件：

```c
/usr/include/linux/input.h
34 /*
35  * Event types
36  */
37 
38 #define EV_SYN           0x00    //同步事件
39 #define EV_KEY           0x01    //按键事件
40 #define EV_REL           0x02    //相对事件
41 #define EV_ABS           0x03    //绝对事件
42 #define EV_MSC           0x04
43 #define EV_SW            0x05
44 #define EV_LED           0x11
45 #define EV_SND           0x12
46 #define EV_REP           0x14
47 #define EV_FF            0x15
48 #define EV_PWR           0x16
49 #define EV_FF_STATUS     0x17
50 #define EV_MAX           0x1f
51 #define EV_CNT           (EV_MAX+1)
```

**事件值(code)**

由于事件值种类繁多，这里就不一一列举出来，这里举例键盘的部分事件值:

文件头文件路径：

```c
/usr/include/linux/input-event-codes.h
```

当然Linux内核版本较低的有可能在以下路径的这个头文件：

```c
/usr/include/linux/input.h
64 /*
65  * Keys and buttons
66  *
67  * Most of the keys/buttons are modeled after USB HUT 1.12
68  * (see http://www.usb.org/developers/hidpage).
69  * Abbreviations in the comments:
70  * AC - Application Control
71  * AL - Application Launch Button
72  * SC - System Control
73  */
74 
75 #define KEY_RESERVED     0
76 #define KEY_ESC          1
77 #define KEY_1            2
78 #define KEY_2            3
79 #define KEY_3            4
80 #define KEY_4            5
81 #define KEY_5            6
82 #define KEY_6            7
83 #define KEY_7            8
84 #define KEY_8            9
85 #define KEY_9            10
86 #define KEY_0            11
87 #define KEY_MINUS        12
88 #define KEY_EQUAL        13
89 #define KEY_BACKSPACE        14
90 #define KEY_TAB          15
91 #define KEY_Q            16
92 #define KEY_W            17
...
```

当然还有鼠标事件值、摇杆事件值、触摸屏事件值等等。

**该事件上报的数值(value)**

 这部分上面已经举了鼠标的案例进行了介绍，接下来我们就通过应用程序来获取事件，后面章节将会通过鼠标、键盘以及触摸屏三个案例，进一步的了解输入系统的应用编程。

### 3.4 输入系统应用编程实战一：通用USB鼠标事件读取

 根据前面章节的讲解，如果我们需要获取USB鼠标的事件，首先我们要先通过cat /proc/bus/input/devices这个指令查询与USB鼠标事件对应的相关设备信息，通过实际测试得知，event2为USB鼠标上报的事件节点。



![img](https://pic2.zhimg.com/80/v2-b4d7522dd58b2ee8f4c9ab2069191f35_720w.webp)



接下来，通过hexdump命令测试一下鼠标事件的输出:



![img](https://pic3.zhimg.com/80/v2-ec4805a5de733ea36bbd8cedd06afad2_720w.webp)



 具体上报的数值是什么含义可以结合3.3章节进行分析，这里就不再进行阐述，本节的目的是编写一个获取通用USB鼠标的事件的应用程序，要获取一个事件，我们需要了解以下几个部分。

**1** **设备上报事件类型(type)**

通过3.3章节，我们知道找到对应的事件类型的定义：

文件头文件路径：

```c
/usr/include/linux/input-event-codes.h
```

当然Linux内核版本较低的有可能在以下路径的这个头文件：

```c
/usr/include/linux/input.h
34 /*
35  * Event types
36  */
37 
38 #define EV_SYN           0x00    //同步事件
39 #define EV_KEY           0x01    //按键事件
40 #define EV_REL           0x02    //相对事件
41 #define EV_ABS           0x03    //绝对事件
42 #define EV_MSC           0x04
43 #define EV_SW            0x05
44 #define EV_LED           0x11
45 #define EV_SND           0x12
46 #define EV_REP           0x14
47 #define EV_FF            0x15
48 #define EV_PWR           0x16
49 #define EV_FF_STATUS     0x17
50 #define EV_MAX           0x1f
51 #define EV_CNT           (EV_MAX+1)
```

**2** **设备上报的事件值(code)**

由于本节我们写的是通用USB鼠标的应用程序，所以我们找到鼠标相关的code,如下：

文件头文件路径：

```c
/usr/include/linux/input-event-codes.h
```

当然Linux内核版本较低的有可能在以下路径的这个头文件：

```c
/usr/include/linux/input.h
696 /*
697  * Relative axes
698  */
699 
700 #define REL_X           0x00    //相对X坐标
701 #define REL_Y           0x01    //相对Y坐标
702 #define REL_Z           0x02
703 #define REL_RX          0x03
704 #define REL_RY          0x04
705 #define REL_RZ          0x05
706 #define REL_HWHEEL      0x06
707 #define REL_DIAL        0x07
708 #define REL_WHEEL       0x08
709 #define REL_MISC        0x09
710 #define REL_MAX         0x0f
711 #define REL_CNT         (REL_MAX+1)
```

在这里，我们暂时只会用来REL_X和REL_Y这两个参数。

 那么所谓的value,就是选择具体的事件类型(type)和具体的事件值(code)以后所反应出来的值，鼠标就是相对于当前X或者相对于当前Y的值，接下来，我们来看一下如何来读取鼠标事件。

在编写input应用程序之前，在程序中需要包含以下头文件：

```c
#include <linux/input.h>
```

程序编写步骤：

1 定义一个结构体变量input_event用于描述input事件

```c
struct input_event event_mouse ;
```

2 打开input设备的事件节点，这里我们获取的通用USB鼠标是event2

```c
open("/dev/input/event2",O_RDONLY);
```

3 读取事件

```c
read(fd ,&event_mouse ,sizeof(event_mouse));
```

4 根据上报的事件进行处理

```c
//判断鼠标上报的类型，可能为绝对事件，也有可能是相对事件
if(EV_ABS == event_mouse.type || EV_REL == event_mouse.type)
{
   //code表示相对位移X或者Y，当判断是X时，打印X的相对位移value
   //当判断是Y时，打印Y的相对位移value
   if(event_mouse.code == REL_X)
   {
      printf("event_mouse.code_X:%d\n", event_mouse.code);
      printf("event_mouse.value_X:%d\n", event_mouse.value);
   }
   else if(event_mouse.code == REL_Y)
   {
      printf("event_mouse.code_Y:%d\n", event_mouse.code);
      printf("event_mouse.value_Y:%d\n", event_mouse.value);
   }
}
```

5 关闭文件描述符

```c
close(fd);
```

不难发现，获取一个输入系统事件，也是标准的文件操作，这体现了Linux一切皆文件的思想。

完整的程序案例如下：

```c
01 #include <stdio.h>
02 #include <unistd.h>
03 #include <stdlib.h>
04 #include <fcntl.h>
05 #include <linux/input.h>
06 
07 int main(void)
08 {
09     //1、定义一个结构体变量用来描述input事件
10     struct input_event event_mouse ;
11     //2、打开input设备的事件节点  我的通用USB鼠标事件的节点是event2
12     int fd    = -1 ;
13     fd = open("/dev/input/event2", O_RDONLY);
14     if(-1 == fd)
15     {
16         printf("open mouse event fair!\n");
17         return -1 ;
18     }
19     while(1)
20     {
21         //3、读事件
22         read(fd, &event_mouse, sizeof(event_mouse));
23         if(EV_ABS == event_mouse.type || EV_REL == event_mouse.type)
24         {
25             //code表示相对位移X或者Y，当判断是X时，打印X的相对位移value
26             //当判断是Y时，打印Y的相对位移value
27             if(event_mouse.code == REL_X)
28             {
29                 printf("event_mouse.code_X:%d\n", event_mouse.code);
30                 printf("event_mouse.value_X:%d\n", event_mouse.value);
31             }
32             else if(event_mouse.code == REL_Y)
33             {
34                 printf("event_mouse.code_Y:%d\n", event_mouse.code);
35                 printf("event_mouse.value_Y:%d\n", event_mouse.value);
36             }
37      }
38     }
39     close(fd);
40     return 0 ;
41 }
```

代码编写完毕后，然后执行

```c
gcc test_mouse.c -o test_mouse
```

编译程序：



![img](https://pic3.zhimg.com/80/v2-ccf05f4f38248accd3777013c5ff9dde_720w.webp)



编译成功后会生成test_mouse，接下来执行test_mouse这个程序。

当鼠标左右移动的时候上报的事件：



![img](https://pic2.zhimg.com/80/v2-e1ee95ff1283dc56e7698411fd6f9259_720w.webp)



这时候可以看到，只有相对于X的事件值在发生，这时候打印的value是X方向相对于原点坐标的偏移值。

当鼠标上下移动的时候上报的事件：



![img](https://pic1.zhimg.com/80/v2-8fb2f24e6fa169295f542df4b8ffd7bc_720w.webp)



这时候可以看到，只有相对于Y的事件值在发生，这时候打印的value是Y方向相对于原点坐标的偏移值。

### 3.5 输入系统应用编程实战二：通用键盘事件读取

 如何获取键盘事件在3.3章节已经有了相应的介绍，这里就不再写出来，本节实现的是通用键盘事件的获取，结合3.4章节获取鼠标事件的方式，这里通用键盘事件的节点为event1,通过结合3.3章节与3.4章节，编写步骤如下：

在编写input应用程序之前，在程序中需要包含以下头文件：

```c
#include <linux/input.h>
```

程序编写步骤：

1 定义一个结构体变量input_event用于描述input事件

```c
struct input_event event_keyboard ;
```

2 打开input设备的事件节点，我的通用键盘事件的节点是event1

```c
open("/dev/input/event1",O_RDONLY);
```

3 读取事件

```c
read(fd ,&event_keyboard ,sizeof(event_keyboard));
```

4 根据上报的事件进行处理

```c
//判断键盘事件上报的类型
if(EV_KEY == event_keyboard.type)
{
    if(1 == event_keyboard.value)
      printf("事件类型:%d  事件值:%d 按下\n", event_keyboard.type,                        event_keyboard.code);
    else if(0 == event_keyboard.value)
      printf("事件类型:%d  事件值:%d 释放\n", event_keyboard.type, event_keyboard.code);
}
```

5 关闭文件描述符

```c
close(fd);
```

完整程序案例实现如下：

```c
01 #include <stdio.h>
02 #include <unistd.h>
03 #include <stdlib.h>
04 #include <fcntl.h>
05 #include <linux/input.h>
06 
07 int main(void)
08 {
09     //1、定义一个结构体变量用来描述input事件
10     struct input_event event_keyboard ;
11     //2、打开input设备的事件节点  我的通用键盘事件的节点是event1
12     int fd    = -1 ;
13     fd = open("/dev/input/event1", O_RDONLY);
14     if(-1 == fd)
15     {
16         printf("open mouse event fair!\n");
17         return -1 ;
18     }
19     while(1)
20     {
21         //3、读事件
22         read(fd, &event_keyboard, sizeof(event_keyboard));
23         if(EV_KEY == event_keyboard.type)
24         {
25              if(1 == event_keyboard.value)
26                  printf("事件类型:%d  事件值:%d 按下\n",event_keyboard.type,event_keyboard.code);
27              else if(0 == event_keyboard.value)
28                  printf("事件类型:%d  事件值:%d 释放\n",event_keyboard.type,event_keyboard.code);
29      }
30     }
31     close(fd);
32     return 0 ;
33 }
```

 不难发现，通用USB键盘程序编写步骤与通用USB鼠标程序编写步骤几乎一样，区别只是读取的事件类型以及后面处理的数据value不同。

代码编写完毕后，然后执行

```c
gcc test_keyboard.c -o test_keyboard
```

编译程序：



![img](https://pic1.zhimg.com/80/v2-e789fd6057fdffec2e2860dd2a67e0d8_720w.webp)



编译成功后会生成test_keyboard，接下来执行test_keyboard这个程序。



![img](https://pic4.zhimg.com/80/v2-6b53e0b02e564f3c5a040186ff60e2ff_720w.webp)



当按下按键时候，可以观察到按键的按下和释放的过程，这其实就是同一个事件下的两个不同的状态。

### 3.6 输入系统应用编程实战三：百问网imx6ul开发板触摸屏事件读取

 在前面，我们已经熟悉了鼠标、键盘的基本操作，但发现一个规律，那就是编程方法类似，唯一不同的地方就是获取的事件类型以及事件值不同，那么触摸屏在input系统中是一类什么事件呢？

 一般情况下，触摸屏在input系统中属于绝对事件，也就是触摸的坐标点X和Y会在屏幕的分辨率范围内上报一个绝对的坐标。

绝对事件对应的值为：EV_ABS

相应X和Y分量的值分别为：

ABS_MT_POSITION_X、ABS_MT_POSITION_Y

通过结合前面的章节内容，很容易编写如下程序：

```c
01 #include <stdio.h>
02 #include <unistd.h>
03 #include <fcntl.h>
04 #include <stdlib.h>
05 #include <linux/input.h>
06 
07 int main(int argc, char **argv)
08 {
09     int tp_fd  = -1 ;
10     int tp_ret = -1 ;
11     int touch_x,touch_y ;
12     struct input_event imx6ull_ts ;  
13     //1、打开触摸屏事件节点
14     tp_fd = open("/dev/input/event1",O_RDONLY);
15     if(tp_fd < 0)
16     {
17        printf("open /dev/input/event1 fail!\n");
18        return -1 ;
19     }
20     while(1)
21     {  
22          //2、获取触摸屏相应的事件，并打印出当前触摸的坐标
23          read(tp_fd ,&imx6ull_ts ,sizeof(imx6ull_ts));  
24          switch(imx6ull_ts.type)
25          {  
26              case EV_ABS:  
27              if(imx6ull_ts.code == ABS_MT_POSITION_X)  
28                  touch_x = imx6ull_ts.value ;
29              if(imx6ull_ts.code == ABS_MT_POSITION_Y) 
30                  touch_y = imx6ull_ts.value ;
31              break ;
32              defalut:  
33              break ;  
34          }       
35          printf("touch_x:%d touch_y:%d\n",touch_x,touch_y);
36          usleep(100);
37     }    
38     close(tp_fd);
39     return 0;
40 }
```

代码编写完毕后，然后执行

```c
gcc test_touchscreen.c -o test_touchscreen
```

交叉编译程序：(注意这里是要在开发板运行，不是在PC端)



![img](https://pic3.zhimg.com/80/v2-bd7e29a80b1bf9132e8ec057507b46ce_720w.webp)



接下来启动开发板，然后串口终端输出rz命令，等待接收PC端的文件，这里我们将test_touchscreen这个文件传输到开发板。



![img](https://pic4.zhimg.com/80/v2-ae776c57bad70afc6de634f74d3b3543_720w.webp)



具体操作步骤可参考第11章：PC和开发板之间传输文件

接下来给test_touchscreen添加可执行权限:



![img](https://pic4.zhimg.com/80/v2-fd5a5a23c103451443a3baf8b564223f_720w.webp)



执行test_touchscreen，然后用手触摸屏，可以看到有相应的坐标值打印：



![img](https://pic1.zhimg.com/80/v2-216448fb912f6eb1110d525e2756ad60_720w.webp)

## 4 Linux进程间通信

### 4.1 初识进程

 在日常工作/学习中，读者可能会经常听到如下一些词：“作业”，“任务”，“开了几个线程”，“创建了几个进程”，“多线程”，“多进程”等等。如果系统学习过《操作系统》这门课程，相信大家对这些概念都十分了解。但对很多电子、电气工程专业（或是其他非计算机专业）的同学来说，由于这门课程不是必修课程，我们脑海中可能就不会有这些概念，听到这些概念的时候就会不知所云，不过没有关系，先让我们克服对这些概念的恐惧。比如小时候刚开始学习数学的时候，先从正整数/自然数开始学习，然后逐步接触到分数、小数、负数、有理数、无理数、实数，再到复数等等。这些操作系统中的概念也是这样，让我们从初级阶段开始学起，逐步攻克这些新概念背后的真正含义。

 本篇主要讨论linux进程间通信方式，这个主题拆分开始来看，分为三个部分：linux(操作系统)、进程、进程间通信。Linux操作系统本篇暂且不谈，我们主要来关注后两个部分：进程，以及进程间通信。在探讨进程间通信之前，让我们先关注一个知识点概念----进程。

#### 4.1.1 进程的概念

##### 4.1.1.1 程序

 在探讨进程之前，先思考一个问题：什么是程序？

 嵌入式软件工程师每天的工作/学习内容就是看C/C++源代码、分析C/C++源代码、编写C/C++源代码（有人会说，应该还有最重要的调试程序，我每天的工作日常是三分写程序，七分调试程序，调试程序去哪里了，大家别着急，这里先卖一个关子）。这些独立的源代码就是一个个程序。它们有一个共同特点，在我们阅读、分析、编写的过程中，此刻都是静态的，它们存储在我们的硬盘上、公司的服务器上。

 程序：存储在磁盘上的指令和数据的有序集合。如下就是一个程序，此刻它正安静地躺在硬盘上。

```c
01 #include <stdio.h>
02
03 int main(int argc, char *argv[])
04{
05  printf("hello world!\n");
06  return 0;
07}
```

##### 4.1.1.2 进程

 有了上面程序的概念，先直接给出进程的定义。

 进程：**具有一定独立功能的程序在一个数据集合上的一次动态执行过程**。它是动态的，包括创建、调度、执行和消亡（由操作系统完成的）。

 定义中的每个词分开来我们都能理解，但是组合到一起成为一个句子时，我们又不知道什么意思了。图灵奖得主Pascal之父尼古拉斯·沃斯，提出过一个著名的公式：程序=算法+数据结构。所谓算法就是解决一个问题的方法，程序就是使用算法对特定数据进行处理，这些数据是一个广义上的概念，不单单指像1,2,3,…等等这样的数据。因此用更直白的语言来说，程序开始运行，对数据进行分析处理的过程就是一个进程。

##### 4.1.1.3 进程和程序的联系

1. 程序是产生进程的基础。
2. 程序的每次执行构成不同的进程。
3. 进程是程序功能的体现（还记得之前提到的程序员日常工作中的一个重要事项----调试程序吗？调试的过程实际上就是程序的执行，就是本次程序功能的体现，因此这个时候它就是一个进程）。
4. 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包含多个程序。

##### 4.1.1.4 进程和程序的区别

![img](https://pic4.zhimg.com/80/v2-b05aa3a1e515fce1ea4f2326d556fcbb_720w.webp)



下图反应了从程序到进程的变化过程。



![img](https://pic2.zhimg.com/80/v2-20624778c855cf37e97898886913ac5d_720w.webp)



我们以一个生活中的例子来加深对进程和程序的理解：

```c
1.有一位计算机科学家，他的女儿要过生日了，他准备给女儿做一个生日蛋糕，于是他去找了一本菜谱，跟着菜谱学习做蛋糕。

菜谱=程序  科学家=CPU  做蛋糕的原材料=数据  做蛋糕的过程=进程

2.科学家正在做蛋糕的时候，突然他的小儿子跑过来，说他的手被扎破了，于是科学家又去找了一本医疗手册，给小儿子处理伤口，处理完伤口之后，继续做生日蛋糕

医疗手册=新程序  给小儿子处理伤口=新进程

从做蛋糕切换到优先包扎伤口=进程切换  处理完伤口继续做生日蛋糕=进程恢复
```

 介绍到这里，希望读者对进程已经建立起一些基础概念了，有关进程的深入部分，我们在这里暂且先不介绍，比如进程的组成包括哪些（代码段，用户数据段，系统数据段）？进程的类型有哪些？进程的状态有哪些等等？这些深入内容，在我们掌握了进程的基础知识之后，读者有兴趣的话，可以查阅相关书籍资料。

#### 4.1.2 进程的操作（创建、结束、回收）

##### 4.1.2.1 创建进程

```c
使用fork函数来创建一个进程
头文件: #include <unistd.h>
函数原型: pid_t fork(void);
返回值: 成功时，父进程返回子进程的进程号(>0的非零整数)，子进程中返回0;通过fork函数的返回值区分父子进程。
父进程: 执行fork函数的进程。
子进程: 父进程调用fork函数之后，生成的新进程。
```

 请重点注意：这个函数的返回值和我们接触的绝大部分函数的返回值不一样。

 一般地，一个函数的返回值只有一个值，但是该函数的返回值却有两个。实际上关于这个函数的返回值究竟有几个，可以换一种方式来理解，因为这个函数执行之后，系统中会存在两个进程----父进程和子进程，在每个进程中都返回了一个值，所以给用户的感觉就是返回了两个值。

进程的特点：

1. 在linux中，一个进程必须是另外一个进程的子进程，或者说一个进程必须有父进程，但是可以没有子进程。
2. 子进程继承了父进程的内容，包括父进程的代码，变量，pcb，甚至包括当前PC值。在父进程中，PC值指向当前fork函数的下一条指令地址，因此子进程也是从fork函数的下一条指令开始执行。父子进程的执行顺序是不确定的，可能子进程先执行，也可能父进程先执行，取决于当前系统的调度。
3. 父子进程有独立的地址空间、独立的代码空间，互不影响，就算父子进程有同名的全局变量，但是由于它们处在不同的地址空间，因此不能共享。
4. 子进程结束之后，必须由它的父进程回收它的一切资源，否则就会成为僵尸进程。
5. 如果父进程先结束，子进程会成为孤儿进程，它会被INIT进程收养，INIT进程是内核启动之后，首先被创建的进程。

**Tips：**

 在linux下，当我们不熟悉某个系统接口API函数时（比如不知道调用这个函数需要包含的头文件，不知道这个函数的每个参数的意义等等），我们可以在ubuntu下使用man命令来查看这个函数的说明。



![img](https://pic3.zhimg.com/80/v2-1cc9ab70e75962430e2a56ca7a28184e_720w.webp)





![img](https://pic1.zhimg.com/80/v2-2f81f0ae31b59726a0c27c392f6e5304_720w.webp)



示例程序（参考：jz2440\process\1th_create_process\create_process.c）

```c
01 /**********************************************************************
02  * 功能描述： 创建一个子进程
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 
16 int main(int argc, char *argv[])
17 {
18     pid_t pid;
19 
20     pid = fork();  // 创建子进程
21 
22     if (pid == 0) {  // 子进程
23         int i = 0;
24         for (i = 0; i < 5; i++) {
25             usleep(100);
26             printf("this is child process i=%d\n", i);
27         }
28     }
29     
30     if (pid > 0) {  // 父进程
31         int i = 0;
32         for (i = 0; i < 5; i++) {
33             usleep(100);
34             printf("this is parent process i=%d\n", i);
35         }
36     }
37 
38     while(1);   //不让进程结束，以便我们查看进程的一些状态信息
39     return 0;
40 }
```

**JZ2440实验**

 在jz2440开发板上实验，读者首先需要创建好NFS文件系统，jz2440开发板从网络文件系统启动，以便运行在ubuntu上编译好的可执行文件，关于如何搭建NFS文件系统请参考视频教程《u-boot_内核_根文件系统(ARM裸机1期加强版与2期驱动大全间的衔接)》。读者也可以在ubuntu上执行，将编译器从“arm-linux-gcc”换成“gcc”即可。

- 编译程序

```c
arm-linux-gcc create_process.c -o create_process
```

- 将可执行文件test拷贝到NFS文件系统对应的目录下

```c
cp create_process /work/nfs_root/first_fs
```

- 在jz2440开发板的串口下此时能看到该可执行文件



![img](https://pic3.zhimg.com/80/v2-9bc799f02627f60e1636f548d2f6bd06_720w.webp)



- 执行可执行文件

 ”&”表示在后台执行，这样我们可以继续在串口控制台下敲入命令，控制台能够接收到输入字符并作出响应；如果不加”&”，表示在前台执行，控制台不能对输入字符作出响应。

```c
./create_process &
```



![img](https://pic2.zhimg.com/80/v2-9de8c6aac50e4052e8466fb15e1cb45d_720w.webp)



- top命令查看进程状态

```c
top
```



![img](https://pic1.zhimg.com/80/v2-ffc4055487e516a54ec726b32a25c9fc_720w.webp)



 发现此时确实存在两个进程create_process，其中一个进程PID是777(它的父进程PID是776)，另外一个进程PID是776(它的父进程PID是770)。

##### 4.1.2.2 结束进程

```c
使用exit函数来结束一个进程
头文件: #include <stdlib.h>
函数原型: void exit (int status)
使用_exit函数来结束一个进程
头文件: #include <unistd.h>
函数原型: void _exit(int status);
```

 两个函数的区别是：exit结束进程时会刷新缓冲区，_exit不会；

 这两个退出函数和return函数又有什么区别呢？exit和 _ exit函数是返回给操作系统的，return函数是当前函数返回，返回到调用它的函数中，如果正好是在main函数中，return函数也返回给了操作系统，这个时候return和exit、_exit起到了类似的作用。

程序实验：验证exit和_exit的区别

示例1：使用exit退出（参考：jz2440\process\2th_exit_process\exit_process.c）

```c
01 /**********************************************************************
02  * 功能描述： 使用exit退出当前进程
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 #include <stdio.h>
11 #include <stdlib.h>
12 
13 int main(int argc, char *argv[])
14 {
15     printf("hello world\n");
16     printf("will exit");
17     exit(0);    //使用_exit退出
18 }
```

示例2：使用_exit退出（参考：jz2440\process\3th_exit_process\exit_process.c）

```c
01 /**********************************************************************
02  * 功能描述： 使用_exit退出当前进程
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 #include <stdio.h>
11 #include <stdlib.h>
12 
13 int main(int argc, char *argv[])
14 {
15     printf("hello world\n");
16     printf("will exit");
17     _exit(0);    //使用_exit退出
18 }
```

 在两个示例程序中，第15行比第16行的打印语句多了一个“\n”，它会强制将待打印的字符刷新到缓冲区，为了对比exit和_exit的区别，在第16行中就没有加上“\n”，按照上面两个退出函数的区别，示例1应该会同时打印“hello world”和“will exit”，示例2程序只会打印“hello world”，不会打印“will exit”，那么到底是不是这样呢？我们在jz2440下验证一下。

**JZ2440实验**

**示例1**

- 编译

```c
arm-linux-gcc exit_process.c -o exit_process
```

- 拷贝到NFS

```c
cp exit_process /work/nfs_root/first_fs
```

- 运行

```c
./exit_process
```

运行结果，确实同时打印了“hello world”和“will exit”



![img](https://pic3.zhimg.com/80/v2-f4d1d49d2dcd7af56267b00fd2393882_720w.webp)



##### 4.1.2.3 回收进程

```c
使用wait函数来回收一个进程
头文件: #include <sys/types.h>
       #include <sys/wait.h>
函数原型: pid_t wait(int *status);
返回值:  成功返回子进程的进程号，失败返回-1
使用waitpid函数来回收一个进程
头文件: #include <sys/types.h>
       #include <sys/wait.h>
函数原型: pid_t waitpid(pid_t pid, int *status, int options);
返回值:  成功返回子进程的进程号，失败返回-1
```

程序示例：子进程退出，父进程回收子进程（参考：jz2440\process\4th_exit_wait\exit_wait.c）

```c
1 /**********************************************************************
02  * 功能描述： 使用exit退出子进程，父进程使用waitpid回收子进程的资源
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 #include <unistd.h>
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <sys/types.h>
14 #include <sys/wait.h>
15 
16 int main(int argc, char *argv[])
17 {
18  int status = -1;
19  pid_t pid;
20 
21  pid = fork();
22  if (pid == 0){ //子进程
23      printf("fork\n");
24      exit(1);
25  } else if (pid > 0) { //父进程
26      pid = waitpid(pid, &status, 0);
27      printf("status=0x%x\n", status);
28  } else {
29      perror("fork\n");
30  }
31 
32  return 0;
33 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc exit_wait.c -o exit_wait
```

- 拷贝到NFS

```c
cp exit_wait /work/nfs_root/first_fs
```

- 运行

```c
./exit_wait
```

运行结果



![img](https://pic2.zhimg.com/80/v2-64a481596f9c6390de3ac3f9108a94cd_720w.webp)



### 4.2 进程为什么需要通信

 先让我们看如下两个简单的程序，这两个程序中都有一个同名全局变量“global”，唯一的区别是这个全局变量的初始值不同。**说明：以下两个示例程序是为了让我们理解进程的一个特点，因此实验环境是Ubuntu虚拟机**。

程序1：

```c
01 #include <stdio.h>
02 int global = 1;
03
04 void delay(void)
05 {
06  unsigned int a = 1000000;
07  while(a--);
08 }
09
10 int main(int argc, char *argv[])
11 {
12  while (1) {
13      printf("global=%d\n", global);
14      delay();
15  }
16  return 0;
17 }
```

程序2：

```c
01 #include <stdio.h>
02 int global = 2;
03
04 void delay(void)
05 {
06  unsigned int a = 1000000;
07  while(a--);
08 }
09
10 int main(int argc, char *argv[])
11 {
12  while (1) {
13      printf("global=%d\n", global);
14      delay();
15  }
16  return 0;
17 }
```

两个程序的唯一区别如下红框所示：



![img](https://pic4.zhimg.com/80/v2-3ac6dbc7951bbcc11c511e0a03c1c28f_720w.webp)



- 编译程序

```c
gcc test1.c -o test1
gcc test2.c -o test2
```

- 运行程序

```c
./test1
./test2
```



![img](https://pic1.zhimg.com/80/v2-9e8539cbb29f41c43f82f55faeae0cc8_720w.webp)





程序1运行结果





![img](https://pic2.zhimg.com/80/v2-ea3ebe7c9c273395d90b39a05df40c2d_720w.webp)





程序2运行结果



 我们发现，两个程序运行之后，当前进程中的全局变量global的值并不会改变，它不会被改变成另外一个进程中的值，由此引出的进程的一个特点：**进程资源的唯一性，不共享性，它不能访问别的进程中的数据(地址空间)，也不能被别的进程访问本身的数据(地址空间)。**每个进程对其他进程而言，就是一个黑盒(后面读者学习到线程的时候，会发现在这个特性上，线程是有别于进程的)。

 那么为什么会这样呢？这是因为操作系统为了保证系统的安全（进程A奔溃不会影响进程B，进程B仍然会继续运行），它会为每个进程分配特定的地址空间，每个进程只能在这个特定的地址空间执行指令、访问数据，如下图所示。程序需要访问某个变量时，都是通过变量地址去访问该变量的，在不同的进程中，同名变量对应不同的地址(处在当前进程地址空间范围内)，进程无法访问分配给它的地址范围之外的地址空间，自然就无法获得其他进程中的变量值。



![img](https://pic4.zhimg.com/80/v2-6c3b84ba9741f9df36d398b382b041f3_720w.webp)



 进程间为何需要通信呢？从上面的两个示例程序中，可以得知：**不同进程之间无法互相访问对方的地址空间**。但是在我们实际的项目开发中，为了实现各种各样的功能，不同进程之间一定需要数据交互，那么我们应该如何实现进程间数据交互呢？这就是进程间通信的目的：**实现不同进程之间的数据交互**。

 在linux下，内存空间被划分为用户空间和内核空间，应用程序开发人员开发的应用程序都存在于用户空间，绝大部分进程都处在用户空间；驱动程序开发人员开发的驱动程序都存在于内核空间。

 在用户空间，不同进程不能互相访问对方的资源，因此，在用户空间是无法实现进程间通信的。为了实现进程间通信，必须在内核空间，由内核提供相应的接口来实现，linux系统提供了如下四种进程通信方式。



![img](https://pic3.zhimg.com/80/v2-c419059f325b8ed4c07754b843820b2e_720w.webp)

 linux有一个最基本的思想----“**一切皆文件**”，内核中实现进程间通信也是基于文件读写思想。不同进程通过操作内核里的同一个内核对象来实现进程间通信，如下图所示，这个内核对象可以是管道、共享内存、消息队列、信号灯、信号，以及socket。



![img](https://pic1.zhimg.com/80/v2-0d50f5448bacd04c4a8583c26b2f585c_720w.webp)



### 4.3 进程通信之管道通信

管道分为无名管道和有名管道，其特点如下

![img](https://pic1.zhimg.com/80/v2-7aaccc6b498973d1e0d162f3276438bc_720w.webp)



#### 4.3.1 无名管道

##### 4.3.1.1 特点

 无名管道实际上就是一个单向队列，**在一端进行读操作，在另一端进行写操作**，所以需要两个文件描述符，描述符fd[0]指向读端，fd[1]指向写端。它是一个特殊的文件，所以无法使用简单open函数创建，我们需要pipe函数来创建。它只能用于具有亲缘关系的两个进程间通信。



![img](https://pic3.zhimg.com/80/v2-83dc52a375c372e3725a06862293479e_720w.webp)



##### 4.3.1.2 创建无名管道

```c
1.头文件#include <unistd.h>

2.函数原型: int pipe(int fd[2])

3.参数: 管道文件描述符，有两个文件描述符，分别是fd[0]和fd[1]，管道有一个读端fd[0]和一个写端fd[1]

4.返回值： 0表示成功；1表示失败
```

##### 4.3.1.3 读、写、关闭管道

```c
1.读管道 read，读管道对应的文件描述符是fd[0]

2.写管道 write，写管道对应的文件描述符是fd[1]

3.关闭管道 close，因为创建管道时，会同时创建两个管道文件描述符，分别是读管道文件描述符fd[0]和写管道文件描述符fd[1]，因此需要关闭两个文件描述符
```

##### 4.3.1.4 无名管道实现进程间通信

**程序示例1**

（参考：jz2440\process_pipe\1th_write_pipe\my_pipe_write.c）

```c
01 /**********************************************************************
02  * 功能描述： 创建一个管道，并向管道中写入字符串，然后从管道中读取，验证
03               能否读取之前写入的字符串
04  * 输入参数： 无
05  * 输出参数： 无
06  * 返 回 值： 无
07  * 修改日期        版本号     修改人          修改内容
08  * -----------------------------------------------
09  * 2020/05/16       V1.0      zh(ryan)        创建
10  ***********************************************************************/
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 
15 int main(int argc, char *argv[])
16 {
17     int fd[2];
18     int ret = 0;
19     char write_buf[] = "Hello linux";
20     char read_buf[128] = {0};
21     
22     ret = pipe(fd);
23     if (ret < 0) {
24         printf("create pipe fail\n");
25         return -1;
26     }
27     printf("create pipe sucess fd[0]=%d fd[1]=%d\n", fd[0], fd[1]);
28     
29     //向文件描述符fd[1]写管道
30     write(fd[1], write_buf, sizeof(write_buf));
31     
32     //从文件描述符fd[0]读管道
33     read(fd[0], read_buf, sizeof(read_buf));
34     printf("read_buf=%s\n", read_buf);
35     
36     close(fd[0]);
37     close(fd[1]);
38     return 0;
39 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc my_pipe_write.c -o my_pipe_write
```

- 拷贝到NFS文件系统

```c
cp my_pipe_write /work/nfs_root/first_fs
```

- 运行

```c
./my_pipe_write
```

运行结果，发现能够正确读到管道中的字符串” Hello linux”。

**程序示例2**

 在利用无名管道实现进程间通信之前，先让我们看一下如下的程序：我们知道父子进程的执行顺序是不确定的，是受系统调度的。我们在父进程中创建一个子进程，我们想让父进程控制子进程的运行，父进程设置“process_inter=1”，当“process_inter=1”时，子进程才会执行打印操作，否则子进程不执行打印操作。我们看如下的程序能够实现我们的目的吗？

（参考：jz2440\process_pipe\2th_comm\test.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.在父进程中创建一个子进程，
03             2.父进程执行完后，将变量process_inter赋值为1；
04             3.子进程判断process_inter为1则执行后面的打印语句，否则不执行。
05  * 输入参数： 无
06  * 输出参数： 无
07  * 返 回 值： 无
08  * 修改日期        版本号     修改人          修改内容
09  * -----------------------------------------------
10  * 2020/05/16       V1.0      zh(ryan)        创建
11  ***********************************************************************/
12 #include <stdio.h>
13 #include <stdlib.h>
14 #include <unistd.h>
15 #include <sys/types.h>
16 
17 int main(int argc, char *argv[])
18 {
19     pid_t pid;
20     int process_inter = 0;
21 
22     pid = fork();  // 创建子进程
23 
24     if (pid == 0) {  // 子进程
25         int i = 0;
26         while (process_inter == 0); //
27         for (i = 0; i < 5; i++) {
28             usleep(100);
29             printf("this is child process i=%d\n", i);
30         }
31     }
32     
33     if (pid > 0) {  // 父进程
34         int i = 0;
35         for (i = 0; i < 5; i++) {
36             usleep(100);
37             printf("this is parent process i=%d\n", i);
38         }
39         process_inter == 1;
40     }
41 
42     while(1);
43     return 0;
44 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc test.c -o test
```

- 拷贝到NFS文件系统

```c
cp test /work/nfs_root/first_fs
```

- 运行

```c
./test
```

运行结果，发现第29行打印语句一直没有，子进程中process_inter一直为0。



![img](https://pic2.zhimg.com/80/v2-7475d5452ad59d2aede62ca17fc5933d_720w.webp)



**程序示例3**

（参考：jz2440\process_pipe\3th_pipe_comm\comm_fork.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.使用无名管道实现父子进程通信
03             2.父进程向管道中写入一个值
04             3.子进程从管道中读取该值，如果非零，则执行后面的打印，否则不执行
05  * 输入参数： 无
06  * 输出参数： 无
07  * 返 回 值： 无
08  * 修改日期        版本号     修改人          修改内容
09  * -----------------------------------------------
10  * 2020/05/16       V1.0      zh(ryan)        创建
11  ***********************************************************************/
12 
13 #include <stdio.h>
14 #include <stdlib.h>
15 #include <unistd.h>
16 #include <sys/types.h>
17 
18 int main(int argc, char *argv[])
19 {
20     pid_t pid;
21     char process_inter = 0;
22     int fd[2], ret = 0;
23 
24     ret = pipe(fd);   //创建一个无名管道，必须在创建子进程之前
25     if (ret < 0) {
26         printf("create pipe fail\n");
27         return -1;
28     }
29     printf("create pipe sucess\n");
30     
31     pid = fork();  //创建子进程
32 
33     if (pid == 0) {  // 子进程
34         int i = 0;
35         read(fd[0], &process_inter, sizeof(process_inter));  // 如果管道为空，则休眠等待
36         while (process_inter == 0);
37         for (i = 0; i < 5; i++) {
38             usleep(100);
39             printf("this is child process i=%d\n", i);
40         }
41     } else if (pid > 0) {  // 父进程
42         int i = 0;
43         for (i = 0; i < 5; i++) {
44             usleep(100);
45             printf("this is parent process i=%d\n", i);
46         }
47         process_inter = 1;
48         sleep(2);
49         write(fd[1], &process_inter, sizeof(process_inter));
50     }
51 
52     while(1);
53     return 0;
54 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc comm_fork.c -o comm_fork
```

- 拷贝到NFS文件系统

```c
cp comm_fork /work/nfs_root/first_fs
```

- 运行

```c
./comm_fork
```

运行结果，因为第38行2s延时，父进程打印结束后大约2s左右的时间，子进程中的打印也正确输出了，如下所示。



![img](https://pic3.zhimg.com/80/v2-c2573795ffbcf358481cfdea65a821ca_720w.webp)



#### 4.3.2 有名管道

##### 4.3.2.1 特点

所谓有名管道，顾名思义，就是在内核中存在一个文件名，表明这是一个管道文件。Linux中存在7种文件类型，分别如下。



![img](https://pic2.zhimg.com/80/v2-649506e781567fc92088e45a37e44045_720w.webp)

 有名管道既可以用于具有亲缘关系的进程间通信，又可以用于非亲缘关系的进程间通信，在我们的实际项目中，很多进程之间是不具有亲缘关系的，因此有名管道使用的情况会更普遍一些。

##### 4.3.2.2 创建有名管道

```c
函数原型 ： int mkfifo(const char * filename, mode_t mode)

参数 ：管道文件文件名，权限，创建的文件权限仍然和umask有关系

返回值 ： 成功返回0，失败返回-1
```

注意：mkfifo并没有在内核中生成一个管道，只是在用户空间生成了一个有名管道文件

##### 4.3.2.3 有名管道实现进程间通信

**示例程序1**

创建一个有名管道文件(参考：jz2440\process_pipe\4th_create_myfifo\create_myfifo.c)

```c
01 /**********************************************************************
02  * 功能描述： 1.创建一个有名管道
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 
16 int main(int argc, char *argv[])
17 {
18     int ret;
19 
20     ret = mkfifo("./myfifo", 0777);   //创建有名管道，文件权限为777
21     if (ret < 0) {
22         printf("create myfifo fail\n");
23         return -1;
24     }
25     printf("create myfifo sucess\n");
26     
27     return 0;
28 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc create_myfifo.c -o create_myfifo
```

- 拷贝到NFS文件系统

```c
cp create_myfifo /work/nfs_root/first_fs
```

- 运行

```c
./create_myfifo
```

运行结果，发现在当前目录下生成一个有名管道文件myfifo（文件类型是“-p”）。





**示例程序2**

进程1源码(参考：jz2440\process_pipe\5th_myfifo_comm\5nd_named_pipe.c)

```c
01 /**********************************************************************
02  * 功能描述： 1.进程1中创建一个有名管道3rd_fifo，权限是0777
03             2.以写方式打开这个有名管道文件，并向其中写入一个值
04  * 输入参数： 无
05  * 输出参数： 无
06  * 返 回 值： 无
07  * 修改日期        版本号     修改人          修改内容
08  * -----------------------------------------------
09  * 2020/05/16       V1.0      zh(ryan)        创建
10  ***********************************************************************/
11 
12 #include <stdio.h>
13 #include <stdlib.h>
14 #include <unistd.h>
15 #include <sys/types.h>
16 #include <fcntl.h>
17 
18 int main(int argc, char *argv[])
19 {
20     int i, ret, fd;
21     char p_flag = 0;
22 
23     /* 创建有名管道 */
24     if (access("./3rd_fifo", 0) < 0) {   //先判断有名管道文件是否存在,不存在需要先创建
25         ret = mkfifo("./3rd_fifo", 0777);
26         if (ret < 0) {
27             printf("create named pipe fail\n");
28             return -1;
29         }
30         printf("create named pipe sucess\n");
31     }
32     
33     /* 打开有名管道，以写方式打开 */
34     fd=open("./3rd_fifo", O_WRONLY);
35     if (fd < 0) {
36         printf("open 3rd_fifo fail\n");
37         return -1;
38     }
39     printf("open 3rd_fifo sucess\n");
40 
41     for (i = 0; i < 5; i++) {
42         printf("this is first process i=%d\n", i);
43         usleep(100);
44     }
45     p_flag = 1;
46     sleep(5);
47     write(fd, &p_flag, sizeof(p_flag));
48 
49     while(1);
50     return 0;
51 }
```

进程2源码(参考：jz2440\process_pipe\5th_myfifo_comm\5nd_named_pipe_2.c)

```c
01 /**********************************************************************
02  * 功能描述： 1.只读方式打开这个有名管道文件，并读取这个值
03             2.当这个值非零时，继续执行后面的打印输出语句
04  * 输入参数： 无
05  * 输出参数： 无
06  * 返 回 值： 无
07  * 修改日期        版本号     修改人          修改内容
08  * -----------------------------------------------
09  * 2020/05/16       V1.0      zh(ryan)        创建
10  ***********************************************************************/
11 
12 #include <stdio.h>
13 #include <stdlib.h>
14 #include <unistd.h>
15 #include <sys/types.h>
16 #include <fcntl.h>
17 
18 int main(int argc, char *argv[])
19 {
20     int i;
21     int fd=open("./3rd_fifo", O_RDONLY);
22     char p_flag = 0;
23     
24     if (fd < 0) {
25         printf("open 3rd_fifo fail\n");
26         return -1;
27     }
28     
29     printf("open 3rd_fifo sucess\n");
30     read(fd, &p_flag, sizeof(p_flag));
31     while(!p_flag);
32     for (i = 0; i < 5; i++) {
33         printf("this is second process i=%d\n", i);
34         usleep(100);
35     }
36 
37     while(1);
38     return 0;
39 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc 5nd_named_pipe.c -o 5nd_named_pipe

arm-linux-gcc 5nd_named_pipe_2.c -o 5nd_named_pipe_2
```

- 拷贝到NFS文件系统

```c
cp 5nd_named_pipe /work/nfs_root/first_fs

cp 5nd_named_pipe_2 /work/nfs_root/first_fs
```

- 运行

注意我们这里都在后台运行可执行程序，方便我们在串口中断下多次输入。

```c
./5nd_named_pipe &

./5nd_named_pipe_2 &
```



![img](https://pic3.zhimg.com/80/v2-07b4555dc058e1489e12c36f32b96fe2_720w.webp)



### 4.4 进程通信之IPC通信

 IPC通信分为共享内存、消息队列以及信号灯。这些IPC对象（共享内存、消息队列、信号灯）都存在于内核空间中。

应用程序使用IPC通信的一般步骤如下：

- 首先生成一个key值。有两种生成key的方式，一种是使用宏IPC_PRIVATE表示一个key，它表示一个私有对象，只能用于当前进程或者具有亲缘关系的进程访问。另一种是使用ftok函数来生成一个key值，这种方式创建的IPC对象可以被不同的进程访问。
- 使用生成的key值，创建一个IPC对象（如果是已经创建好的IPC对象，则打开该IPC对象），这个时候每个IPC对象都有一个唯一的ID号（IPC_id，可以是shm_id，msg_id，sem_id，每个id代表一个IPC对象）。
- 进程通过IPC_id，调用访问IPC通道的读写函数来操作IPC对象。调用shmctrl，shmat，shmdt来访问共享内存；调用msgctrl，msgsnd，msgrecv访问消息队列；调用semctrl，semop访问信号灯。



![img](https://pic3.zhimg.com/80/v2-80e2416bb398204a1e21c296da854f46_720w.webp)



 如何理解key和IPC_id（shm_id/msg_id/sem_id）

 回答这个问题，请先思考一个问题，应用程序如何访问一个IPC对象（共享内存，消息队列、信号量灯）？

 显然，我们需要一个唯一表示该IPC对象的身份ID（IPC_id，该IPC_id是由操作系统来管理的），但是由于这个ID只在当前创建该IPC对象的进程中可以获取到，在别的IPC进程中都没法获取，那么如何得到IPC对象的ID呢？这个时候就需要key值了，它相当于IPC_id的一个别名，或者叫做外部名，因此key值必须也是唯一的，这样才能得到唯一的IPC对象id。不同进程通过同一个key值得到同一个IPC对象id，来访问同一个IPC对象。如下图所示





ftok函数

```c
函数原型 : char ftok(const char *path, char key)

参数 ： path，存在并且可以访问的文件路径

       key，一个字符

返回值 ： 正确返回一个key值，出错返回-1
```

 为何需要ftok函数先生成key，然后再创建IPC对象？

 这就类似于无名管道和有名管道的区别，使用IPC_PRIVATE宏创建的共享内存就类似于无名管道，只能实现有亲缘关系的进程间通信。

 那么为什么又需要使用ftok生成一个key值呢？是否可以直接指定一个非零值呢？直接指定一个非零的key值做法是不建议的，因为读者自己指定的key值很有可能于系统中已经存在的key值一样。

 ftok函数创建了一个key值之后，就类似于有名管道，既可以实现具有亲缘关系的进程间通信，又能够实现非亲缘关系的进程间通信。

#### 4.4.1 共享内存

##### 4.4.1.1 特点

 所谓共享内存是指多个进程都可以访问的同一块地址空间，但是我们知道Linux操作系统为了保证系统执行的安全，为每个进程划分了各自独立的地址空间，每个进程不能访问别的进程的地址空间，那么共享内存实现的原理是什么呢？

 内核开辟一块物理内存区域，进程本身将这片内存空间映射到自己的地址空间进行读写。





 从图中可以看到，进程可以直接访问这片内存，数据不需要在两进程间复制，所以速度较快。共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步。

 当需要使用共享内存进行通信时，一般步骤如下：

- 先创建一片共享内存，该内存存在于内核空间中。
- 进程通过key值找到这片共享内存的唯一ID，然后将这片共享内存映射到自己的地址空间。
- 每个进程通过读写映射后的地址，来访问内核中的共享内存。

##### 4.4.1.2创建共享内存

```c
函数原型 : int shmget(key_t key, int size, int shmflg)

头文件: #include <sys/shm.h>

函数参数 : key: IPC_PRIVATE 或 ftok的返回值

         IPC_PRIVATE返回的key值都是一样的,都是0

         size : 共享内存区大小

         shmflg : 同open函数的权限位，也可以用八进制表示法

返回值  ： 成功，共享内存段标识符ID； -1 出错
```

**程序示例1（参考jz2440\process_ipc\1st_shm\1st_shm.c）**

```c
01 /**********************************************************************
02  * 功能描述： 1.使用IPC_PRIVATE创建共享内存
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 #include <sys/shm.h>
16 #include <signal.h>
17 
18 int main(int argc, char *argv[])
19 {
20     int shmid;
21     
22     shmid = shmget(IPC_PRIVATE, 128, 0777);
23     if (shmid < 0) {
24         printf("create shared memory fail\n");
25         return -1;
26     }
27     printf("create shared memory sucess, shmid = %d\n", shmid);
28     system("ipcs -m");
29     return 0;
30 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc 1st_shm.c -o 1st_shm
```

- 拷贝到NFS文件系统

```c
cp 1st_shm /work/nfs_root/first_fs
```

- 运行

执行第18行程序后，会在串口打印如下信息，这行语句的作用和我们直接在串口console下面输入“ipcs -m”是一样的。我们发现此时共享内存的key值为0。

```c
./1st_shm
```



![img](https://pic4.zhimg.com/80/v2-c790de3a01b240428bddbff3b6668077_720w.webp)



**程序示例2**（参考jz2440\process_ipc\1st_shm\2nd_shm.c）

程序源码，使用fotk函数生成一个key值

```c
01 /**********************************************************************
02  * 功能描述： 1.使用ftok函数生成的key创建共享内存
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 #include <sys/shm.h>
16 #include <signal.h>
17 
18 int main(int argc, char *argv[])
19 {
20     int shmid;
21     int key;
22 
23     key = ftok("./a.c", 'a');  //先创建一个key值
24     if (key < 0) {
25         printf("create key fail\n");
26         return -1;
27     }
28     printf("create key sucess key = 0x%X\n",key);
29     
30     shmid = shmget(key, 128, IPC_CREAT | 0777);
31     if (shmid < 0) {
32         printf("create shared memory fail\n");
33         return -1;
34     }
35     printf("create shared memory sucess, shmid = %d\n", shmid);
36     system("ipcs -m");
37     return 0;
38 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc 2nd_shm.c -o 2nd_shm
```

- 拷贝到NFS文件系统

```c
cp 2nd_shm /work/nfs_root/first_fs
```

- 运行

我们需要在2nd_shm所在的同级目录下创建一个文件a.c（在jz2440开发板上）

```c
touch a.c
```

我们发现此时共享内存的key值为非零值0x610d0169.

```c
./2nd_shm
```



![img](https://pic3.zhimg.com/80/v2-7ed3cbff80efa7990dc3d44e4249d37e_720w.webp)



##### 4.4.1.3 应用程序如何访问共享内存

 我们知道创建的共享内存还是处于内核空间中，用户程序不能直接访问内核地址空间，那么用户程序如何访问这个共享内存呢？

**shmat函数**

```c
将共享内存映射到用户空间，这样应用程序就可以直接访问共享内存了

函数原型 ： void *shmat(int shmid, const void *shmaddr, int shmflg)

参数 ： shmid ID号

       shmaddr 映射地址， NULL为系统自动完成的映射

       shmflg SHM_RDONLY共享内存只读

       默认是0，可读可写

返回值：成功，映射后的地址；失败，返回NULL
```

程序示例（参考jz2440\process_ipc\1st_shm\3nd_shm.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.创建共享内存，将该共享内存地址通过shmat映射到用户地址空间
03             2.用户通过标准输入向这个共享内存中输入一行字符串
04             3.然后从该共享内存中读取内容，验证是否能够读取到
05  * 输入参数： 无
06  * 输出参数： 无
07  * 返 回 值： 无
08  * 修改日期        版本号     修改人          修改内容
09  * -----------------------------------------------
10  * 2020/05/16       V1.0      zh(ryan)        创建
11  ***********************************************************************/
12 #include <stdio.h>
13 #include <stdlib.h>
14 #include <unistd.h>
15 #include <sys/types.h>
16 #include <sys/shm.h>
17 #include <signal.h>
18 
19 int main(int argc, char *argv[])
20 {
21     int shmid;
22     int key;
23     char *p;
24     
25     key = ftok("./a.c", 'b');
26     if (key < 0) {
27         printf("create key fail\n");
28         return -1;
29     }
30     printf("create key sucess key = 0x%X\n",key);
31     
32     shmid = shmget(key, 128, IPC_CREAT | 0777);
33     if (shmid < 0) {
34         printf("create shared memory fail\n");
35         return -1;
36     }
37     printf("create shared memory sucess, shmid = %d\n", shmid);
38     system("ipcs -m");
39     
40     p = (char *)shmat(shmid, NULL, 0);
41     if (p == NULL) {
42         printf("shmat fail\n");
43         return -1;
44     }
45     printf("shmat sucess\n");
46     
47     //等待console输入，然后向共享内存写入数据
48     fgets(p, 128, stdin);
49     
50     //读共享内存
51     printf("share memory data:%s\n", p);
52     
53     //再次读共享内存
54     printf("share memory data:%s\n", p);
55     return 0;
56 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc 3nd_shm.c -o 3nd_shm
```

- 拷贝到NFS文件系统

```c
cp 3nd_shm /work/nfs_root/first_fs
```

- 运行

我们需要在3nd_shm所在的同级目录下创建一个文件a.c（在jz2440开发板上）

```c
touch a.c
```

此时会提示用户输入信息

```c
./3nd_shm
```



![img](https://pic4.zhimg.com/80/v2-616b3150cbea87c556ac10e2695c174f_720w.webp)



我们在console下输入任意字符，比如“hello linux”，然后按下回车，发现打印如下



![img](https://pic1.zhimg.com/80/v2-42d860f4c7c7b2cdab5c11eb1d3d8054_720w.webp)



 问题：代码中第51行读了一遍共享内存，然后第54行又读了一遍共享内存，发现两次都能读到共享内存的内容，说明共享内存被读了之后，内容仍然存在。而在管道中，读了一遍管道内容之后，如果紧接着读取第二遍（在没有新写入的前提下），我们是不能读到管道中的内容的，说明管道只要读取一次之后，内容就消失了，读者可以通过实验自行验证一下。

**shmdt函数**

```c
函数原型：int shmdt(const void *shmaddr)

参数 ； shmat的返回值

返回值 : 成功0，出错-1
```

程序示例（参考jz2440\process_ipc\1st_shm\4th_shm.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.创建共享内存，将该共享内存地址通过shmat映射到用户地址空间
03             2.用户通过标准输入向这个共享内存中输入一行字符串
04             3.然后从该共享内存中读取内容
05             4.调用shmdt解除地址映射，此时应用程序继续访问会出错
06  * 输入参数： 无
07  * 输出参数： 无
08  * 返 回 值： 无
09  * 修改日期        版本号     修改人          修改内容
10  * -----------------------------------------------
11  * 2020/05/16       V1.0      zh(ryan)        创建
12  ***********************************************************************/
13 #include <stdio.h>
14 #include <stdlib.h>
15 #include <unistd.h>
16 #include <sys/types.h>
17 #include <sys/shm.h>
18 #include <signal.h>
19 #include <string.h>
20 
21 int main(int argc, char *argv[])
22 {
23     int shmid;
24     int key;
25     char *p;
26     
27     key = ftok("./a.c", 'b');
28     if (key < 0) {
29         printf("create key fail\n");
30         return -1;
31     }
32     printf("create key sucess key = 0x%X\n",key);
33     
34     shmid = shmget(key, 128, IPC_CREAT | 0777);
35     if (shmid < 0) {
36         printf("create shared memory fail\n");
37         return -1;
38     }
39     printf("create shared memory sucess, shmid = %d\n", shmid);
40     system("ipcs -m");
41     
42     p = (char *)shmat(shmid, NULL, 0);
43     if (p == NULL) {
44         printf("shmat fail\n");
45         return -1;
46     }
47     printf("shmat sucess\n");
48     
49     //write share memory
50     fgets(p, 128, stdin);
51     
52     //start read share memory
53     printf("share memory data:%s\n", p);
54     
55     //start read share memory again
56     printf("share memory data:%s\n", p);
57 
58     //在用户空间删除共享内存的地址
59     shmdt(p);
60     
61     memcpy(p, "abcd", 4);  //执行这个语句会出现segment fault，因为解除了共享内存地址映射
62     return 0;
63 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc 4th_shm.c -o 4th_shm
```

- 拷贝到NFS文件系统

```c
cp 4th_shm /work/nfs_root/first_fs
```

- 运行

我们需要在4th_shm.c所在的同级目录下创建一个文件a.c（在jz2440开发板上）

```c
touch a.c
```

运行，此时会提示用户输入信息,输入完之后，执行第61行语句会出现Segmentation fault，这是程序期待的现象。

```c
./4th_shm
```



![img](https://pic1.zhimg.com/80/v2-0d6072fdd6be1bea1dec8210621a2928_720w.webp)



**shmctl函数**

```c
函数原型：int shmctl(int shmid, int cmd, struct shmid_ds *buf)

参数: shmid : 共享内存标识符

     cmd : IPC_START (获取对象属性)   --- 实现了命令 ipcs -m

     IPC_SET(设置对象属性)

     IPC_RMID (删除对象属性)    --- 实现了命令 ipcrm -m

     buf : 指定IPC_START/IPC_SET时用以保存/设置属性

返回值 : 成功0，出错-1
```

程序示例（参考jz2440\process_ipc\1st_shm\5th_shm.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.创建共享内存，将该共享内存地址通过shmat映射到用户地址空间
03               2.用户通过标准输入向这个共享内存中输入一行字符串
04               3.然后从该共享内存中读取内容
05               4.调用shmdt解除地址映射，此时应用程序继续访问会出错
06               5.最后调用shmctl函数删除内核中的共享内存
07  * 输入参数： 无
08  * 输出参数： 无
09  * 返 回 值： 无
10  * 修改日期        版本号     修改人          修改内容
11  * -----------------------------------------------
12  * 2020/05/16       V1.0      zh(ryan)        创建
13  ***********************************************************************/
14 
15 #include <stdio.h>
16 #include <stdlib.h>
17 #include <unistd.h>
18 #include <sys/types.h>
19 #include <sys/shm.h>
20 #include <signal.h>
21 #include <string.h>
22 
23 int main(int argc, char *argv[])
24 {
25     int shmid;
26     int key;
27     char *p;
28     
29     key = ftok("./a.c", 'b');
30     if (key < 0) {
31         printf("create key fail\n");
32         return -1;
33     }
34     printf("create key sucess key = 0x%X\n",key);
35     
36     shmid = shmget(key, 128, IPC_CREAT | 0777);
37     if (shmid < 0) {
38         printf("create shared memory fail\n");
39         return -1;
40     }
41     printf("create shared memory sucess, shmid = %d\n", shmid);
42     system("ipcs -m");
43     
44     p = (char *)shmat(shmid, NULL, 0);
45     if (p == NULL) {
46         printf("shmat fail\n");
47         return -1;
48     }
49     printf("shmat sucess\n");
50     
51     //write share memory
52     fgets(p, 128, stdin);
53     
54     //start read share memory
55     printf("share memory data:%s\n", p);
56     
57     //start read share memory again
58     printf("share memory data:%s\n", p);
59 
60     //在用户空间删除共享内存的地址
61     shmdt(p);
62     
63     //memcpy(p, "abcd", 4);  //执行这个语句会出现segment fault
64     
65     shmctl(shmid, IPC_RMID, NULL);
66     system("ipcs -m");
67     return 0;
68 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc 5th_shm.c -o 5th_shm
```

- 拷贝到NFS文件系统

```c
cp 5th_shm /work/nfs_root/first_fs
```

- 运行

```c
touch a.c
```

 运行。此时会提示用户输入信息，第一次执行第42行语句时，读者可以看到共享内存，第二次执行第66行语句时，读者就看不到共享内存了，因为此时共享内存已经被删除了。

```c
./4th_shm
```



![img](https://pic3.zhimg.com/80/v2-431f94a1cb616c5554584e69bfe5a39e_720w.webp)



##### 4.4.1.4 共享内存实现进程间通信

步骤：

```c
1. 创建/打开共享内存

2. 映射共享内存，即把指定的共享内存映射到进程的地址空间用于访问

3. 读写共享内存

4. 撤销共享内存映射

5. 删除共享内存对象
```

使用共享内存时的一些注意点或是限制条件

```c
1. 共享内存的数量是有限制的，通过ipcs -l命令查看，当然如果我们具有管理员权限，可以通过 cat /proc/sys/kernel/shmmax来查看

2. 共享内存删除的时间点，shmctl添加删除标记，只有当所有进程都取消共享内存映射时(即所有进程调用shmdt之后)，才会删除共享内存。
```

示例源码（参考jz2440\process_ipc\1st_shm\6th_shm.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.在父进程中创建使用key值为IPC_PRIVATE创建一个共享内存
03             2.然后在父进程中创建一个子进程
04             3.通过标准输入，父进程向共享内存中写入字符串
05             4.父进程调用发送信号函数通知子进程可以读取共享内存了
06             5.子进程收到父进程发送过来的信号，开始读取共享内存
07             6.子进程读完共享内存后，发送信号通知父进程读取完成
08  * 输入参数： 无
09  * 输出参数： 无
10  * 返 回 值： 无
11  * 修改日期        版本号     修改人          修改内容
12  * -----------------------------------------------
13  * 2020/05/16       V1.0      zh(ryan)        创建
14  ***********************************************************************/
15 
16 #include <stdio.h>
17 #include <stdlib.h>
18 #include <unistd.h>
19 #include <sys/types.h>
20 #include <sys/shm.h>
21 #include <signal.h>
22 #include <string.h>
23 
24 void myfun(int signum)
25 {
26     return;
27 }
28 
29 int main(int argc, char *argv[])
30 {
31     int shmid;
32     int key;
33     char *p;
34     int pid;
35 
36 
37     shmid = shmget(IPC_PRIVATE, 128, IPC_CREAT | 0777);
38     if (shmid < 0) {
39         printf("create shared memory fail\n");
40         return -1;
41     }
42     printf("create shared memory sucess, shmid = %d\n", shmid);
43 
44     pid = fork();
45     if (pid > 0) {    // 父进程
46         signal(SIGUSR2, myfun);
47         p = (char *)shmat(shmid, NULL, 0);
48         if (p == NULL) {
49             printf("shmat fail\n");
50             return -1;
51         }
52         printf("parent process shmat sucess\n");
53         while (1) {
54             //从标准输入获取字符串，将其写入到共享内存
55             printf("parent process begin to write memory data:");
56             fgets(p, 128, stdin);
57             kill(pid, SIGUSR1);   // 发信号通知子进程读共享内存
58             pause();              // 等待子进程读完共享内存的信号
59         }
60     }
61     if (pid == 0) { // 子进程
62         signal(SIGUSR1, myfun);
63         p = (char *)shmat(shmid, NULL, 0);
64         if (p == NULL) {
65             printf("shmat fail\n");
66             return -1;
67         }
68         printf("child process shmat sucess\n");
69         while (1) {
70             pause(); // 等待父进程发信号，准备读取共享内存
71             //子进程开始读共享内存，并发信号给父进程告知读完成
72             printf("child process read share memory data:%s\n", p);
73             kill(getppid(), SIGUSR2);
74         }
75     }
76 
77     //在用户空间删除共享内存的地址
78     shmdt(p);
79     
80     //memcpy(p, "abcd", 4);  //执行这个语句会出现segment fault
81     
82     shmctl(shmid, IPC_RMID, NULL);
83     system("ipcs -m");
84     return 0;
85 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc 6th_shm.c -o 6th_shm
```

- 拷贝到NFS文件系统

```c
cp 6th_shm /work/nfs_root/first_fs
```

- 运行

父进程从标准输入获取用户输入的字符串，然后子进程会打印出该字符串。

```c
./6th_shm
```



![img](https://pic2.zhimg.com/80/v2-79e5090c99089e66c23675e7fa634575_720w.webp)



server进程源码（参考jz2440\process_ipc\1st_shm\7th_shm_1.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.server进程使用ftok生成一个key值，利用这个key值创建一个共享内存
03             2.通过标准输入，向共享内存中写入字符串
04             3.server进程调用发送信号函数通知client进程
05  * 输入参数： 无
06  * 输出参数： 无
07  * 返 回 值： 无
08  * 修改日期        版本号     修改人          修改内容
09  * -----------------------------------------------
10  * 2020/05/16       V1.0      zh(ryan)        创建
11  ***********************************************************************/
12 
13 #include <stdio.h>
14 #include <stdlib.h>
15 #include <unistd.h>
16 #include <sys/types.h>
17 #include <sys/shm.h>
18 #include <signal.h>
19 #include <string.h>
20 
21 struct mybuf
22 {
23     int pid;
24     char buf[124];
25 };
26 
27 void myfun(int signum)
28 {
29     return;
30 }
31 
32 int main(int argc, char *argv[])
33 {
34     int shmid;
35     int key;
36     struct mybuf *p;
37     int pid;
38 
39     key = ftok("./a.c", 'a');
40     if (key < 0) {
41         printf("create key fail\n");
42         return -1;
43     }
44     printf("create key sucess\n");
45 
46     shmid = shmget(key, 128, IPC_CREAT | 0777);
47     if (shmid < 0) {
48         printf("create shared memory fail\n");
49         return -1;
50     }
51     printf("create shared memory sucess, shmid = %d\n", shmid);
52 
53     signal(SIGUSR2, myfun);
54     p = (struct mybuf *)shmat(shmid, NULL, 0);
55     if (p == NULL) {
56         printf("shmat fail\n");
57         return -1;
58     }
59     printf("parent process shmat sucess\n");
60 
61     p->pid = getpid(); // 将server进程的pid号写入到共享内存
62     pause();           // 等待client读取到server pid号
63     pid=p->pid;        // 获取client的进程号
64 
65     while (1) {
66         //write share memory
67         printf("parent process begin to write memory data\n");
68         fgets(p->buf, 124, stdin);
69         kill(pid, SIGUSR1);   // 向client发送信号通知client读取共享内存数据
70         pause();              // 等待client读取完共享内存数据
71     }
72 
73     //在用户空间删除共享内存的地址
74     shmdt(p);
75 
76     shmctl(shmid, IPC_RMID, NULL);
77     system("ipcs -m");
78     return 0;
79 }
```

client进程源码（参考jz2440\process_ipc\1st_shm\7th_shm_2.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.client进程使用ftok生成一个key值，利用这个key值打开一个共享内存
03             2.client进程收到server进程发送过来的信号之后，开始读取共享内存
04             3.子进程读完共享内存后，发送信号通知父进程读取完成
05  * 输入参数： 无
06  * 输出参数： 无
07  * 返 回 值： 无
08  * 修改日期        版本号     修改人          修改内容
09  * -----------------------------------------------
10  * 2020/05/16       V1.0      zh(ryan)        创建
11  ***********************************************************************/
12 
13 #include <stdio.h>
14 #include <stdlib.h>
15 #include <unistd.h>
16 #include <sys/types.h>
17 #include <sys/shm.h>
18 #include <signal.h>
19 #include <string.h>
20 
21 struct mybuf
22 {
23     int pid;
24     char buf[124];
25 };
26 
27 void myfun(int signum)
28 {
29     return;
30 }
31 
32 int main(int argc, char *argv[])
33 {
34     int shmid;
35     int key;
36     struct mybuf *p;
37     int pid;
38     
39     key = ftok("./a.c", 'a');
40     if (key < 0) {
41         printf("create key fail\n");
42         return -1;
43     }
44     printf("create key sucess\n");
45 
46     shmid = shmget(key, 128, IPC_CREAT | 0777);
47     if (shmid < 0) {
48         printf("create shared memory fail\n");
49         return -1;
50     }
51     printf("create shared memory sucess, shmid = %d\n", shmid);
52 
53     signal(SIGUSR1, myfun);
54     p = (struct mybuf *)shmat(shmid, NULL, 0);
55     if (p == NULL) {
56         printf("shmat fail\n");
57         return -1;
58     }
59     printf("client process shmat sucess\n");
60     
61     // get server pid
62     //read share memory
63     pid = p->pid;
64     // write client pid to share memory
65     p->pid = getpid();
66     kill(pid, SIGUSR2);   // tell server process to read data
67     
68     //client start to read share memory
69 
70     while (1) {
71         pause();              // wait server process write share memory
72         printf("client process read data:%s\n", p->buf); // read data
73         kill(pid, SIGUSR2);   // server can  write share memory
74     }
75 
76     //在用户空间删除共享内存的地址
77     shmdt(p);
78     
79     shmctl(shmid, IPC_RMID, NULL);
80     system("ipcs -m");
81     return 0;
82 }
```

 该源码留给读者自行实验，需要注意的是，因为这个时候需要运行两个console，分别运行server进程和client进程，可以采用一个串口console，一个telnet console。我们也可以在ubuntu下开启两个terminal验证。

#### 4.4.2 消息队列

##### 4.4.2.1 什么是消息队列

 消息队列是消息的链表，它是一个链式队列，和管道类似，每个消息多有最大长度限制，可用cat/proc/sys/kernel/msgmax查看。

 内核为每个消息队列对象维护了一个数据结构msgqid_ds，用于标识消息队列，以便让进程知道当前操作的是哪一个消息队列，每一个msqid_ds表示一个消息队列，并通过msqid_ds.msg_first、msg_last维护一个先进先出的msg链表队列，当发送一个消息到该消息队列时，把发送的消息构造成一个msg的结构对象，并添加到msqid_ds.msg_first、msg_last维护的链表队列。在内核中的表示如下：



![img](https://pic2.zhimg.com/80/v2-dc3f3ee9cf6549b7939f90ff99d7b21d_720w.webp)



##### 4.4.2.2 特点

1. 生命周期跟随内核，消息队列一直存在，需要用户显示调用接口删除或者使用命令删除。
2. 消息队列可以实现双向通信
3. 克服了管道只能承载无格式字节流的缺点

##### 4.4.2.3 消息队列函数

**msgget函数**

```c
创建或者打开消息队列的函数
头文件：#include <sys/types.h>
        #include <sys/ipc.h>
       #include <sys/msg.h>
原型： int msgget(key_t key, int flag)
参数： key 和消息队列关联的key值
       flag 消息队列的访问权限
返回值： 成功，消息队列ID，出错 -1
```

**msgctl函数**

```c
消息队列控制函数
原型： int msgctl(int msgqid, int cmd, struct msqid_ds *buf)
参数： msgqid 消息队列ID
           cmd IPC_STAT 读取消息队列的属性，并将其保存在buf指向的缓冲区中
               IPC_SET  设置消息队列的属性，这个值取自buf参数
               IPC_RMID 从系统中删除消息队列
           buf 消息缓冲区
返回值： 成功 0，出错 -1
```

**msgsnd函数**

```c
把一条消息添加到消息队列中
头文件#include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/msg.h>
原型： int msgsnd(int msgqid, const void *msgp, size_t size, int flag)
参数： msgqid 消息队列ID
           msgp 指向消息的指针，常用消息结构msgbuf如下
           struct msgbuf {
               long mtype;        //消息类型
               char mtext[N];     //消息正文
           };
           size 消息正文的字节数
           flag IPC_NOWAIT 消息没有发送完成也会立即返回
                0： 直到发送完成函数才会返回
    返回值： 成功 0，出错 -1
```

**msgrcv函数**

```c
从一个消息队列接受消息
原型： int msgrcv(int msgqid, void *msgp, size_t size, long msgtype, int flag)
参数： msgqid 消息队列ID
       msgp 接收消息的缓冲区
       size 要接收消息的字节数
       msgtype  0 接收消息队列中第一个消息
                大于0 接收消息队列中第一个类型为msgtype的消息
                小于0 接收消息队列中类型值不大于msgtype的绝对值且类型值又最小的消息
           flag IPC_NOWAIT 没有消息，会立即返回
                0： 若无消息则会一直阻塞

返回值： 成功 接收消息的长度，出错 -1
```

##### 4.4.2.4 消息队列实现进程间通信

server源码（参考jz2440\process_ipc\2nd_shm\write_msg.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.server进程向消息队列中写数据
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 #include <sys/msg.h>
16 #include <signal.h>
17 #include <string.h>
18 
19 struct msgbuf {
20     long type;        //消息类型
21     char voltage[124];     //消息正文
22     char ID[4];
23 };
24 
25 int main(int argc, char *argv[])
26 {
27     int msgid, readret, key;
28     struct msgbuf sendbuf;
29 
30     key = ftok("./a.c", 'a');
31     if (key < 0){
32         printf("create key fail\n");
33         return -1;
34     }
35     msgid = msgget(key, IPC_CREAT|0777);
36     if (msgid < 0) {
37         printf("create msg queue fail\n");
38         return -1;
39     }
40     printf("create msg queue sucess, msgid = %d\n", msgid);
41     system("ipcs -q");
42 
43     // write message queue
44     sendbuf.type = 100;
45     while(1) {
46         memset(sendbuf.voltage, 0, 124);  //clear send buffer
47         printf("please input message:");
48         fgets(sendbuf.voltage, 124, stdin);
49         //start write msg to msg queue
50         msgsnd(msgid, (void *)&sendbuf, strlen(sendbuf.voltage), 0);
51     }
52 
53     return 0;
54 }
```

client源码（参考jz2440\process_ipc\2nd_shm\read_msg.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.client进程从消息队列中读数据
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 #include <sys/msg.h>
16 #include <signal.h>
17 #include <string.h>
18 
19 struct msgbuf {
20     long type;        //消息类型
21     char voltage[124];     //消息正文
22     char ID[4];
23 };
24 
25 int main(int argc, char *argv[])
26 {
27     int msgid, key;
28     struct msgbuf readbuf;
29 
30     key = ftok("./a.c", 'a');
31     if (key < 0){
32         printf("create key fail\n");
33         return -1;
34     }
35     msgid = msgget(key, IPC_CREAT|0777);
36     if (msgid < 0) {
37         printf("create msg queue fail\n");
38         return -1;
39     }
40     printf("create msg queue sucess, msgid = %d\n", msgid);
41     system("ipcs -q");
42 
43     // read message queue
44     while(1) {
45         memset(readbuf.voltage, 0, 124);  //clear recv buffer
46         //start read msg to msg queue
47         msgrcv(msgid, (void *)&readbuf, 124, 100, 0);
48         printf("recv data from message queue:%s", readbuf.voltage);
49     }
50 
51     return 0;
52 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc write_msg.c -o write_msg
arm-linux-gcc read_msg.c -o read_msg
```

- 拷贝到NFS文件系统

```c
cp write_msg /work/nfs_root/first_fs
cp read_msg /work/nfs_root/first_fs
```

- 运行

先在后台执行read_msg，然后在前台运行write_msg，此时在console下输入字符串，可以看到client进程能读到消息队列中的字符串 。

```c
./read_msg &
./ write_msg
```



![img](https://pic1.zhimg.com/80/v2-2ce187573f89f9e7c9a2869129966474_720w.webp)



#### 4.4.3 信号量灯

##### 4.4.3.1 什么是P、V操作

 当不同进程需要访问同一个资源时，由于不同进程的执行次序是未知的，有可能某个进程正在写该资源，而另一个进程正在读该资源，这样会造成进程执行的不确定性。这样的同一个资源，我们称为共享资源，共享资源一次只允许一个进程访问。因此进程在访问共享资源时，需要加上同步、互斥操作。

 一般地，P操作表示申请该共享资源，V操作表示释放该共享资源。

##### 4.4.3.2 什么是信号量灯

 它是信号量的集合，包含多个信号量，可对多个信号灯同时进行P/V操作，主要用来实现进程、线程间同步/互斥。内核为每个信号量灯维护了一个数据结构semid_ds，用于标识信号量灯，以便进程知道当前操作的是哪个信号量灯，在内核中的表示如下所示。



![img](https://pic1.zhimg.com/80/v2-2c2d0e90aa6e1d91b7ba82c04e6c64c0_720w.webp)



 它和POSIX规范中的信号量有什么区别呢？POSIX规范中的信号量只作用于一个信号量，而IPC对象中的信号量灯会作用于一组信号量。

![img](https://pic3.zhimg.com/80/v2-4cb284c4ef4ef31ecf0928d29156444e_720w.webp)



 为什么需要IPC对象中的信号量灯呢？有POSIX规范中的信号量不够吗？

考虑如下场景：

1. 线程A和线程B都需要访问共享资源1和共享资源2，在线程A中会需要先申请共享资源1，然后再申请共享资源2。
2. 但是在线程B中，会先申请贡献资源2，然后再申请共享资源1。
3. 当线程A中开始申请共享资源1时，紧接着会申请共享资源2；而此时线程B中开始申请共享资源2时，紧接着会申请共享资源1。
4. 线程B正在占用着共享资源2，线程A正在占着共享资源1，导致线程B申请不到共享资源1，它就不会释放共享资源2；线程A申请不到共享资源2，它就不会释放共享资源1；这样就造成了死锁。

##### 4.4.3.3 信号量灯函数

**semget函数**

```c
创建或者打开函数
头文件#includde <sys/types.h>
#includde <sys/ipc.h>
#includde <sys/sem.h>
原型: int semget(key_t key, int nsems, int semflag)
参数： key 和信号灯集关联的key值
      nsems 信号灯集包含的信号灯数目
      semflag 信号灯集的访问权限
返回值： 成功，信号灯ID，出错 -1
```

**semctl函数**

```c
信号量灯控制函数
头文件#includde <sys/types.h>
#includde <sys/ipc.h>
#includde <sys/sem.h>
原型: int semctl(int semid, int semnum, int cmd, ...union semun arg)
          注意最后一个参数不是地址，可以有，可以没有
参数： semid 信号灯集id
      semnum 要修改的信号灯集编号,删除操作时，这个值可以设置为任意值
      cmd GETVAL 获取信号灯的值
           SETVAL 设置信号灯的值
           IPC_RMID 删除信号灯
      union semun arg: union semun {
                     int              val;    /* Value for SETVAL */
                     struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
                     unsigned short  *array;  /* Array for GETALL, SETALL */
                     struct seminfo  *__buf;  /* Buffer for IPC_INFO (Linux-specific) */
                 };
返回值： 成功，消息队列ID，出错 -1
```

**semop函数**

```c
p/v操作函数
头文件#includde <sys/types.h>
#includde <sys/ipc.h>
#includde <sys/sem.h>
原型: int semop(int semid, struct sembuf *opsptr, size_t nops)
参数： semid 信号灯集id
      opsptr struct sembuf{
                  short sem_num;   //要操作信号灯的编号
                  short sem_op;    //0: 等待，直到信号灯的值变为0，1:资源释放，V操作，-1:分配资源，P操作
                  short sem_flg;   //0: IPC_NOWAIT, SEM_UNDO
              }
       nops 要操作信号灯个数
返回值： 成功，消息队列ID，出错 -1
```

##### 4.4.3.4 信号量灯实现进程间同步/互斥

程序源码（参考jz2440\process_ipc\3rd_shm\share_sysv.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.父进程从键盘输入字符串到共享内存.
03             2.子进程删除字符串中的空格并打印.
04             3.父进程输入quit后删除共享内存和信号灯集，程序结束.
05  * 输入参数： 无
06  * 输出参数： 无
07  * 返 回 值： 无
08  * 修改日期        版本号     修改人          修改内容
09  * -----------------------------------------------
10  * 2020/05/16       V1.0      zh(ryan)        创建
11  ***********************************************************************/
12 
13 #include <stdio.h>
14 #include <stdlib.h>
15 #include <string.h>
16 #include <sys/ipc.h>
17 #include <sys/sem.h>
18 #include <sys/types.h>
19 #include <sys/shm.h>
20 #include <signal.h>
21 #include <unistd.h>
22 
23 #define N 64
24 #define READ 0
25 #define WRITE 1
26 
27 union semun {
28  int val;
29         struct semid_ds *buf;
30         unsigned short *array;
31         struct seminfo *__buf;
32 };
33 
34 void init_sem(int semid, int s[], int n)
35 {
36  int i;
37  union semun myun;
38 
39  for (i = 0; i < n; i++){
40      myun.val = s[i];
41      semctl(semid, i, SETVAL, myun);
42  }
43 }
44 
45 void pv(int semid, int num, int op)
46 {
47  struct sembuf buf;
48 
49  buf.sem_num = num;
50  buf.sem_op = op;
51  buf.sem_flg = 0;
52  semop(semid, &buf, 1);
53 }
54 
55 int main(int argc, char *argv[])
56 {
57  int shmid, semid, s[] = {0, 1};
58  pid_t pid;
59  key_t key;
60  char *shmaddr;
61 
62  key = ftok(".", 's');
63  if (key == -1){
64      perror("ftok");
65      exit(-1);
66  }
67 
68  shmid = shmget(key, N, IPC_CREAT|0666);
69  if (shmid < 0) {
70      perror("shmid");
71      exit(-1);
72  }
73 
74  semid = semget(key, 2, IPC_CREAT|0666);
75  if (semid < 0) {
76      perror("semget");
77      goto __ERROR1;
78  }
79  init_sem(semid, s, 2);
80 
81  shmaddr = shmat(shmid, NULL, 0);
82  if (shmaddr == NULL) {
83      perror("shmaddr");
84      goto __ERROR2;
85  }
86 
87  pid = fork();
88  if(pid < 0) {
89      perror("fork");
90      goto __ERROR2;
91  } else if (pid == 0) {
92      char *p, *q;
93      while(1) {
94          pv(semid, READ, -1);
95          p = q = shmaddr;
96          while (*q) {
97              if (*q != ' ') {
98                  *p++ = *q;
99              }
100                 q++;
101             }
102             *p = '\0';
103             printf("%s", shmaddr);
104             pv(semid, WRITE, 1);
105         }
106     } else {
107         while (1) {
108             pv(semid, WRITE, -1);
109             printf("input > ");
110             fgets(shmaddr, N, stdin);
111             if (strcmp(shmaddr, "quit\n") == 0) break;
112                 pv(semid, READ, 1);
113             }
114             kill(pid, SIGUSR1);
115         }
116 
117     __ERROR2:
118         semctl(semid, 0, IPC_RMID);
119     __ERROR1:
120         shmctl(shmid, IPC_RMID, NULL);
121         return 0;
122 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc share_sysv.c -o share_sysv
```

- 拷贝到NFS文件系统

```c
cp share_sysv /work/nfs_root/first_fs
```

- 运行

在父进程的console下输入字符串，此时子进程会读取到这个字符串。

```c
./share_sysv
```





### 4.5 进程通信之信号通信

#### 4.5.1 信号机制

1. 一般地，中断主要是指硬件中断，比如GPIO中断、定时器中断，这些硬件中断时外设模块工作时，发送给CPU的，也是一种异步方式。
2. 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式。
3. Linux内核通过信号通知用户进程，不同的信号类型代表不同的事件。
4. Linux对早期的unix信号机制进行了扩展。

#### 4.5.2 常见信号类型



![img](https://pic1.zhimg.com/80/v2-0128dc38ca557ae1bbed043b8877715c_720w.webp)



#### 4.5.3 信号发送函数

**kill函数**

```c
头文件  #include <unistd.h>

       #include <signal.h>

函数原型int kill(pid_t pid, int sig);

参数  pid ： 指定接收进程的进程号

            0代表同组进程；-1代表所有除了INIT进程和当前进程之外的进程

     sig ： 信号类型

返回值 成功返回0，失败返回EOF
```

**raise函数**

```c
头文件  #include <unistd.h>

       #include <signal.h>

函数原型int raise(int sig);

参数  sig ： 信号类型

返回值 成功返回0，失败返回EOF
```

**alarm函数**

```c
头文件  #include <unistd.h>

       #include <signal.h>

函数原型 int alarm(unsigned int seconds);

参数  seconds 定时器的时间

返回值 成功返回上个定时器的剩余时间，失败返回EOF
```

**pause函数**

```c
进程调用这个函数后会一直阻塞，直到而被信号中断，功能和sleep类似。

头文件  #include <unistd.h>

       #include <signal.h>

函数原型 int pause(void);

返回值  成功返回0，失败返回EOF
```

**signal函数**

```c
设置信号响应方式，请注意这个函数和kill、killall的区别，我们中文使用者会理解为发信号，实际上它并不是发信号。

头文件  #include <unistd.h>

       #include <signal.h>

函数原型 void (*signal(int signo, void(*handler)(int)))(int)

参数  signo 要设置的信号类型

     handler 指定的信号处理函数；

返回值 成功返回0，失败返回EOF
```

#### 4.5.4 进程捕捉信号

程序源码（参考jz2440\process_single\send_single.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.捕捉终端发送过来的信号
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 #include <signal.h>
16 
17 void handler(int signo)
18 {
19      switch (signo) {
20      case SIGINT:
21          printf("I have got SIGINT\n");
22          break;
23          
24      case SIGQUIT:
25          printf("I have got SIGQUIT\n");
26          break;
27          
28      default:
29          printf("don't respond to this signal[%d]\n", signo);
30          exit(0);
31  }
32 }
33 
34 int main(int argc, char *argv[])
35 {
36  signal(SIGINT, handler);
37  signal(SIGQUIT, handler);
38  while (1)
39      pause();
40  return 0;
41 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc send_single.c -o send_single
```

- 拷贝到NFS文件系统

```c
cp send_single /work/nfs_root/first_fs
```

- 运行

```c
./send_single
```

 实际上在利用共享内存实现进程间通信时，我们已经使用到了信号通信，父进程写完共享内存后发送信号通知子进程，子进程收到信号后开始读共享内存，这里就不在给出两个进程之间使用信号通信的例子了，请读者参考共享内存中实现两个进程通信的代码。

### 4.6 进程通信之socket通信

#### 4.6.1 什么是socket

 先思考一个问题：网络环境中的进程如何实现通信？比如当我们使用QQ和好友聊天的时候，QQ进程是如何与服务器以及你好友所在的QQ进程之间通信的？这些靠的就是socket来实现的。

 Socket起源于UNIX，Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。在《有名管道》那一节中，我们知道socket也是一种文件类型，只不过socket是一种伪文件，存在于内核缓冲区中，大小不变，一直是0。

 socket文件一定是成对出现的，server端有一个套接字文件，client端也有一个套接字文件，每个进程需要和对应的套接字文件绑定，每个进程通过读写它的套接字文件，交由内核实现，如下所示。



![img](https://pic4.zhimg.com/80/v2-607a27456ad7bc6d9c2e32be81085237_720w.webp)



 一般地，socket用来实现网络环境中，不同主机上的进程通信，但是也可以用来在同一个主机上的不同进程之间通信，本小节主要探讨socket用在同一个主机上的不同进程间通信。

#### 4.6.2 相关函数

**socket函数**

```c
创建socket文件描述符函数

头文件#include <sys/types.h>

     #include <sys/socket.h>

  原型: int socket(int domain, int type, int protocol)

  返回值： 成功，消息队列ID，出错 -1
```

**bind函数**

```c
将socket文件描述符和某个socket文件绑定

头文件#include <sys/types.h>

     #include <sys/socket.h>

原型: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

参数： sockfd：利用系统调用socket()建立的套接字描述符

      addr：代表需要绑定的本地地址信息

      addrlen: 本地地址信息长度

返回值： 成功，消息队列ID，出错 -1
```

**listen函数**

```c
设置监听某个socket文件描述符，设置能够同时和服务端连接的客户端数量，一般只有server会调用

头文件#include <sys/types.h>

     #include <sys/socket.h>

原型: int listen(int sockfd, int backlog);

参数： sockfd：利用系统调用socket()建立的套接字描述符

      backlog：server可以接受连接的最大client数量

返回值： 成功，消息队列ID，出错 -1
```

**accept函数**

```c
等待client建立连接的函数，一般只有server会调用

头文件#include <sys/types.h>

     #include <sys/socket.h>

原型: int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);

参数： sockfd：利用系统调用socket()建立的套接字描述符

      addr：指向已经建立连接的对端client地址信息的指针

      addrlen: 对端client地址信息长度

返回值： 成功，消息队列ID，出错 -1
```

**connet函数**

```c
client主动连接server函数，一般只有client才会调用

头文件#include <sys/types.h>

     #include <sys/socket.h>

原型: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

参数： sockfd：利用系统调用socket()建立的套接字描述符

      addr：指向已经建立连接的对端server地址信息的指针

      addrlen: 对端server地址信息长度

返回值： 成功，消息队列ID，出错 -1
```

**send函数**

```c
发送数据函数

头文件#include <sys/types.h>

     #include <sys/socket.h>

原型: ssize_t send(int sockfd, const void *buf, size_t len, int flags);

参数： sockfd：指向要发送数据的socket文件描述符，已经建立连接的文件描述符

      buf: 存放要发送数据的缓冲区

      len: 实际要发送数据的字节数

      flags: 一般为0或者如下的宏

            MSG_DONTROUTE  绕过路由表查找

            MSG_DONTWAIT   仅本操作非阻塞

            MSG_OOB　　　　  发送或接收带外数据

            MSG_PEEK　　    窥看外来消息

            MSG_WAITALL　　  等待所有数据

返回值： 成功，消息队列ID，出错 -1
```

**recv函数**

```c
接收数据函数

头文件#include <sys/types.h>

     #include <sys/socket.h>

原型: ssize_t recv(int sockfd, void *buf, size_t len, int flags);

参数： sockfd：已经建立连接的文件描述符

      buf: 存放要接收数据的缓冲区

      len: 实际要接收数据的字节数

      flags:一般为0或者如下的宏

          MSG_DONTROUTE  绕过路由表查找

          MSG_DONTWAIT   仅本操作非阻塞

          MSG_OOB　　　　  发送或接收带外数据

          MSG_PEEK　　    窥看外来消息

          MSG_WAITALL　　  等待所有数据

返回值： 成功，消息队列ID，出错 -1
```

#### 4.6.3 socket实现进程间通信

程序实现一般步骤

```c
Server端

1.创建socket

2.绑定socket

3.设置监听

4.等待客户端连接

5.发送/接收数据
```

Client端

```text
1.创建socket

2.绑定socket

3.连接

4.发送/接收数据
```

server源码（参考jz2440\process_socket\server.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.server打印client发送过来的字符串，并将该字符串回发给client
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 #include <sys/stat.h>
16 #include <string.h>
17 #include <arpa/inet.h>
18 #include <sys/un.h>
19 
20 int main(int argc, char *argv[])
21 {
22     int lfd ,ret, cfd;
23     struct sockaddr_un serv, client;
24     socklen_t len = sizeof(client);
25     char buf[1024] = {0};
26     int recvlen;
27 
28     //创建socket
29     lfd = socket(AF_LOCAL, SOCK_STREAM, 0);
30     if (lfd == -1) {
31         perror("socket error");
32         return -1;
33     }
34 
35     //如果套接字文件存在，删除套接字文件
36     unlink("server.sock");
37 
38     //初始化server信息
39     serv.sun_family = AF_LOCAL;
40     strcpy(serv.sun_path, "server.sock");
41 
42     //绑定
43     ret = bind(lfd, (struct sockaddr *)&serv, sizeof(serv));
44     if (ret == -1) {
45         perror("bind error");
46         return -1;
47     }
48 
49     //设置监听，设置能够同时和服务端连接的客户端数量
50     ret = listen(lfd, 36);
51     if (ret == -1) {
52         perror("listen error");
53         return -1;
54     }
55 
56     //等待客户端连接
57     cfd = accept(lfd, (struct sockaddr *)&client, &len);
58     if (cfd == -1) {
59         perror("accept error");
60         return -1;
61     }
62     printf("=====client bind file:%s\n", client.sun_path);
63     
64     while (1) {
65         recvlen = recv(cfd, buf, sizeof(buf), 0);
66         if (recvlen == -1) {
67             perror("recv error");
68             return -1;
69         } else if (recvlen == 0) {
70             printf("client disconnet...\n");
71             close(cfd);
72             break;
73         } else {
74             printf("server recv buf: %s\n", buf);
75             send(cfd, buf, recvlen, 0);
76         }
77     }
78     
79     close(cfd);
80     close(lfd);
81     return 0;
82 }
```

client源码（参考jz2440\process_socket\client.c）

```c
01 /**********************************************************************
02  * 功能描述： 1.client从标准输入获取到一个字符串，然后将这个字符串发送给server
03  * 输入参数： 无
04  * 输出参数： 无
05  * 返 回 值： 无
06  * 修改日期        版本号     修改人          修改内容
07  * -----------------------------------------------
08  * 2020/05/16       V1.0      zh(ryan)        创建
09  ***********************************************************************/
10 
11 #include <stdio.h>
12 #include <stdlib.h>
13 #include <unistd.h>
14 #include <sys/types.h>
15 #include <sys/stat.h>
16 #include <string.h>
17 #include <arpa/inet.h>
18 #include <sys/un.h>
19 
20 int main(int argc, char *argv[])
21 {
22     int lfd ,ret;
23     struct sockaddr_un serv, client;
24     socklen_t len = sizeof(client);
25     char buf[1024] = {0};
26     int recvlen;
27 
28     //创建socket
29     lfd = socket(AF_LOCAL, SOCK_STREAM, 0);
30     if (lfd == -1) {
31         perror("socket error");
32         return -1;
33     }
34 
35     //如果套接字文件存在，删除套接字文件
36     unlink("client.sock");
37 
38     //给客户端绑定一个套接字文件
39     client.sun_family = AF_LOCAL;
40     strcpy(client.sun_path, "client.sock");
41     ret = bind(lfd, (struct sockaddr *)&client, sizeof(client));
42     if (ret == -1) {
43         perror("bind error");
44         return -1;
45     }
46 
47     //初始化server信息
48     serv.sun_family = AF_LOCAL;
49     strcpy(serv.sun_path, "server.sock");
50     //连接
51     connect(lfd, (struct sockaddr *)&serv, sizeof(serv));
52 
53     while (1) {
54         fgets(buf, sizeof(buf), stdin);
55         send(lfd, buf, strlen(buf)+1, 0);
56 
57         recv(lfd, buf, sizeof(buf), 0);
58         printf("client recv buf: %s\n", buf);
59     }
60 
61     close(lfd);
62     return 0;
63 }
```

**JZ2440实验**

- 编译

```c
arm-linux-gcc server.c -o server

arm-linux-gcc client.c -o client
```

- 拷贝到NFS文件系统

```c
cp server /work/nfs_root/first_fs

cp client /work/nfs_root/first_fs
```

- 运行

为方便看程序运行结果，server在后台执行；client在前台运行，client能够接收来自终端的输入。

```c
./server &

./client
```



![img](https://pic3.zhimg.com/80/v2-f7657db997ff282b5e8bd5fffd102e3a_720w.webp)



#### 4.6.4 一个server和多个client之间的通信

 在实际项目开发中， 更常见的一种场景是：一个server要和多个client之间通信，这部分实现方式交给读者自行实现，实现的方式有很多，比如如下两种方式，当然还要其他方法。

1. 多进程实现，一个主进程用来实现检测client的连接，每检测一次client连接，则为这个client创建一个专门的进程，用于实现两者间通信。
2. 也可以使用多线程实现，一个主线程用来检测client的连接，每检测一次client连接，则为这个client创建一个专门的线程，用于实现两者间通信。

##  5 线程编程

### 5.1 线程的使用

#### 5.1.1 为什么要使用多线程

 在编写代码时，是否会遇到以下的场景会感觉到难以下手？

**场景一**：写程序在拷贝文件时，需要一边去拷贝文件，一边去向用户展示拷贝文件的进度时，传统做法是通过每次拷贝完成结束后去更新变量，再将变量转化为进度显示出来。其中经历了拷贝->计算->显示->拷贝->计算->显示...直至拷贝结束。这样的程序架构及其的低效，必须在单次拷贝结束后才可以刷新当前拷贝进度，若可以将进程分支，一支单独的解决拷贝问题，一支单独的解决计算刷新问题，则程序效率会提升很多。

**场景二**：用阻塞方式去读取数据，实时需要发送数据的时候。例如在进行串口数据传输或者网络数据传输的时候，我们往往需要双向通信，当设置读取数据为阻塞模式时候，传统的单线程只能等到数据接收来临后才能冲过阻塞，再根据逻辑进行发送。当我们要实现随时发送、随时接收时，无法满足我们的业务需求。若可以将进程分支，一支单纯的处理接收数据逻辑，一支单纯的解决发送数据逻辑，就可以完美的实现功能。

 基于以上场景描述，多线程编程可以完美的解决上述问题。

#### 5.1.2 线程概念

 所谓线程，就是操作系统所能调度的最小单位。普通的进程，只有一个线程在执行对应的逻辑。我们可以通过多线程编程，使一个进程可以去执行多个不同的任务。相比多进程编程而言，线程享有共享资源，即在进程中出现的全局变量，每个线程都可以去访问它，与进程共享“4G”内存空间，使得系统资源消耗减少。本章节来讨论Linux下POSIX线程。

#### 5.1.3 线程的标识pthread_t

 对于进程而言，每一个进程都有一个唯一对应的PID号来表示该进程，而对于线程而言，也有一个“类似于进程的PID号”，名为tid，其本质是一个pthread_t类型的变量。线程号与进程号是表示线程和进程的唯一标识，但是对于线程号而言，其仅仅在其所属的进程上下文中才有意义。

```c
获取线程号
#include <pthread.h>
pthread_t pthread_self(void);
成功：返回线程号
```

在程序中，可以通过函数pthread_self，来返回当前线程的线程号，例程1给出了打印线程tid号。

测试例程1：（Phtread_txex1.c）

```c
1   #include <pthread.h>
2   #include <stdio.h>
3
4   int main()
5   {
6       pthread_t tid = pthread_self();//获取主线程的tid号
7       printf("tid = %lu\n",(unsigned long)tid);
8       return 0;
9   }
```

注意：因采用POSIX线程接口，故在要编译的时候包含pthread库，使用gcc编译应gcc xxx.c -lpthread 方可编译多线程程序。

编译结果：



![img](https://pic2.zhimg.com/80/v2-a8e8b859539e2a7952542bd9be668bf1_720w.webp)



#### 5.1.4 线程的创建

```c
创建线程
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);
成功：返回0
```

 在传统的程序中，一个进程只有一个线程，可以通过函数pthread_create来创建线程。

 该函数第一个参数为pthread_t类型的线程号地址，当函数执行成功后会指向新建线程的线程号；第二个参数表示了线程的属性，一般传入NULL表示默认属性；第三个参数代表返回值为void *，形参为void* 的函数指针，当线程创建成功后，会自动的执行该回调函数；第四个参数则表示为向线程处理函数传入的参数，若不传入，可用NULL填充，有关线程传参后续小节会有详细的说明，接下来通过一个简单例程来使用该函数创建出一个线程。

测试例程2：（Phtread_txex2.c）

```c
1   #include <pthread.h>
2   #include <stdio.h>
3   #include <unistd.h>
4   #include <errno.h>
5 
6   void *fun(void *arg)
7   {
8       printf("pthread_New = %lu\n",(unsigned long)pthread_self());//打印线程的tid号
9   }
10
11  int main()
12  {
13      
14      pthread_t tid1;
15      int ret = pthread_create(&tid1,NULL,fun,NULL);//创建线程
16      if(ret != 0){
17          perror("pthread_create");
18          return -1;
19      }
20      
21      /*tid_main 为通过pthread_self获取的线程ID，tid_new通过执行pthread_create成功后tid指向的空间*/
22      printf("tid_main = %lu tid_new = %lu \n",(unsigned long)pthread_self(),(unsigned long)tid1);
23      
24      /*因线程执行顺序随机，不加sleep可能导致主线程先执行，导致进程结束，无法执行到子线程*/
25      sleep(1);
26      
27      return 0;
28  }
29
```

运行结果：



![img](https://pic1.zhimg.com/80/v2-1c82ad416c74cb625ad478750ddc82d4_720w.webp)



 通过pthread_create确实可以创建出来线程，主线程中执行pthread_create后的tid指向了线程号空间，与子线程通过函数pthread_self打印出来的线程号一致。

 特别说明的是，当主线程伴随进程结束时，所创建出来的线程也会立即结束，不会继续执行。并且创建出来的线程的执行顺序是随机竞争的，并不能保证哪一个线程会先运行。可以将上述代码中sleep函数进行注释，观察实验现象。

去掉上述代码25行后运行结果：



![img](https://pic2.zhimg.com/80/v2-9d84f7d527542001ae83e1e59475eb55_720w.webp)



 上述运行代码3次，其中有2次被进程结束，无法执行到子线程的逻辑，最后一次则执行到了子线程逻辑后结束的进程。如此可以说明，线程的执行顺序不受控制，且整个进程结束后所产生的线程也随之被释放，在后续内容中将会描述如何控制线程执行。

#### 5.1.5 向线程传入参数

 pthread_create()的最后一个参数的为void *类型的数据，表示可以向线程传递一个void* 数据类型的参数，线程的回调函数中可以获取该参数，例程3举例了如何向线程传入变量地址与变量值。

测试例程3：（Phtread_txex3.c）

```c
1   #include <pthread.h>
2   #include <stdio.h>
3   #include <unistd.h>
4   #include <errno.h>
5 
6   void *fun1(void *arg)
7   {
8       printf("%s:arg = %d Addr = %p\n",__FUNCTION__,*(int *)arg,arg);
9   }
10
11  void *fun2(void *arg)
12  {
13      printf("%s:arg = %d Addr = %p\n",__FUNCTION__,(int)(long)arg,arg);
14  }
15
16  int main()
17  {
18
19      pthread_t tid1,tid2;
20      int a = 50;
21      int ret = pthread_create(&tid1,NULL,fun1,(void *)&a);//创建线程传入变量a的地址
22      if(ret != 0){
23          perror("pthread_create");
24          return -1;
25      }
27      ret = pthread_create(&tid2,NULL,fun2,(void *)(long)a);//创建线程传入变量a的值
28      if(ret != 0){
29          perror("pthread_create");
30          return -1;
31      }
32      sleep(1);
33      printf("%s:a = %d Add = %p \n",__FUNCTION__,a,&a);
34      return 0;
35  }
36
```

运行结果：



![img](https://pic2.zhimg.com/80/v2-197529e99fd390dfe7d049a65c43f651_720w.webp)



 本例程展示了如何利用线程创建函数的第四个参数向线程传入数据，举例了如何以地址的方式传入值、以变量的方式传入值，例程代码的21行，是将变量a先行取地址后，再次强制类型转化为void后传入线程，线程处理的回调函数中，先将万能指针void *转化为int* ，再次取地址就可以获得该地址变量的值，其本质在于地址的传递。例程代码的27行，直接将int类型的变量强制转化为void *进行传递（针对不同位数机器，指针对其字数不同，需要int转化为long在转指针，否则可能会发生警告），在线程处理回调函数中，直接将void* 数据转化为int类型即可，本质上是在传递变量a的值。

 上述两种方法均可得到所要的值，但是要注意其本质，一个为地址传递，一个为值的传递。当变量发生改变时候，传递地址后，该地址所对应的变量也会发生改变，但传入变量值的时候，即使地址指针所指的变量发生变化，但传入的为变量值，不会受到指针的指向的影响，实际项目中切记两者之间的区别。具体说明见例程4.

测试例程4：（Phtread_txex4.c）

```c
1   #include <pthread.h>
2   #include <stdio.h>
3   #include <unistd.h>
4   #include <errno.h>
5 
6   void *fun1(void *arg)
7   {
8       while(1){
9       
10          printf("%s:arg = %d Addr = %p\n",__FUNCTION__,*(int *)arg,arg);
11          sleep(1);
12      }
13  }
14
15  void *fun2(void *arg)
16  {
17      while(1){
18      
19          printf("%s:arg = %d Addr = %p\n",__FUNCTION__,(int)(long)arg,arg);
20          sleep(1);
21      }
22  }
23
24  int main()
25  {
26
27      pthread_t tid1,tid2;
28      int a = 50;
29      int ret = pthread_create(&tid1,NULL,fun1,(void *)&a);
30      if(ret != 0){
31          perror("pthread_create");
32          return -1;
33      }
34      sleep(1);
35      ret = pthread_create(&tid2,NULL,fun2,(void *)(long)a);
36      if(ret != 0){
37          perror("pthread_create");
38          return -1;
39      }
40      while(1){
41          a++;
42          sleep(1);
43          printf("%s:a = %d Add = %p \n",__FUNCTION__,a,&a);
44      }
45      return 0;
46  }
47
```

运行结果：



![img](https://pic3.zhimg.com/80/v2-d2e3fc77ae3f16226f8acb47927a285a_720w.webp)



 上述例程讲述了如何向线程传递一个参数，在处理实际项目中，往往会遇到传递多个参数的问题，我们可以通过结构体来进行传递，解决此问题。

测试例程5：（Phtread_txex5.c）

```c
1   #include <pthread.h>
2   #include <stdio.h>
3   #include <unistd.h>
4   #include <string.h>
5   #include <errno.h>
6 
7   struct Stu{
8       int Id;
9       char Name[32];
10      float Mark;
11  };
12
13  void *fun1(void *arg)
14  {
15      struct Stu *tmp = (struct Stu *)arg;
16      printf("%s:Id = %d Name = %s Mark = %.2f\n",__FUNCTION__,tmp->Id,tmp->Name,tmp->Mark);
17      
18  }
19
20  int main()
21  {
22
23      pthread_t tid1,tid2;
24      struct Stu stu;
25      stu.Id = 10000;
26      strcpy(stu.Name,"ZhangSan");
27      stu.Mark = 94.6;
28
29      int ret = pthread_create(&tid1,NULL,fun1,(void *)&stu);
30      if(ret != 0){
31          perror("pthread_create");
32          return -1;
33      }
34      printf("%s:Id = %d Name = %s Mark = %.2f\n",__FUNCTION__,stu.Id,stu.Name,stu.Mark);
35      sleep(1);
36      return 0;
37  }
38
```

运行结果：



![img](https://pic3.zhimg.com/80/v2-556cee7a87d9e5092861b3020ab0b8a2_720w.webp)



#### 5.1.6 线程的退出与回收

 线程的退出情况有三种：第一种是进程结束，进程中所有的线程也会随之结束。第二种是通过函数pthread_exit来主动的退出线程。第三种通过函数pthread_cancel被其他线程被动结束。当线程结束后，主线程可以通过函数pthread_join/pthread_tryjoin_np来回收线程的资源，并且获得线程结束后需要返回的数据。

```c
线程退出
#include <pthread.h>
void pthread_exit(void *retval);
```

 该函数为线程退出函数，在退出时候可以传递一个void*类型的数据带给主线程，若选择不传出数据，可将参数填充为NULL。

```c
线程资源回收（阻塞）
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
成功：返回0
```

 该函数为线程回收函数，默认状态为阻塞状态，直到成功回收线程后被冲开阻塞。第一个参数为要回收线程的tid号，第二个参数为线程回收后接受线程传出的数据。

```c
线程资源回收（非阻塞）
#define _GNU_SOURCE            
#include <pthread.h>
int pthread_tryjoin_np(pthread_t thread, void **retval);
成功：返回0
```

 该函数为非阻塞模式回收函数，通过返回值判断是否回收掉线程，成功回收则返回0，其余参数与pthread_join一致。

```c
线程退出（指定线程号）
#include <pthread.h>
int pthread_cancel(pthread_t thread);
成功：返回0
```

 该函数传入一个tid号，会强制退出该tid所指向的线程，若成功执行会返回0。

 上述描述简单的介绍了有关线程回收的API，下面通过例程来说明上述API。

测试例程6：（Phtread_txex6.c）

```c
1   #include <pthread.h>
2   #include <stdio.h>
3   #include <unistd.h>
4   #include <errno.h>
5 
6   void *fun1(void *arg)
7   {
8       static int tmp = 0;//必须要static修饰，否则pthread_join无法获取到正确值
9       //int tmp = 0;
10      tmp = *(int *)arg;
11      tmp+=100;
12      printf("%s:Addr = %p tmp = %d\n",__FUNCTION__,&tmp,tmp);
13      pthread_exit((void *)&tmp);//将变量tmp取地址转化为void*类型传出
14  }
15
16
17  int main()
18  {
19
20      pthread_t tid1;
21      int a = 50;
22      void *Tmp = NULL;//因pthread_join第二个参数为void**类型
23      int ret = pthread_create(&tid1,NULL,fun1,(void *)&a);
24      if(ret != 0){
25          perror("pthread_create");
26          return -1;
27      }
28      pthread_join(tid1,&Tmp);
29      printf("%s:Addr = %p Val = %d\n",__FUNCTION__,Tmp,*(int *)Tmp);
30      return 0;
31  }
32
```

运行结果：



![img](https://pic1.zhimg.com/80/v2-772650aa87764899a21f23cb27604e98_720w.webp)



 上述例程先通过23行将变量以地址的形式传入线程，在线程中做出了自加100的操作，当线程退出的时候通过线程传参，用void*类型的数据通过pthread_join接受。此例程去掉了之前加入的sleep函数，原因是pthread_join函数具备阻塞的特性，直至成功收回掉线程后才会冲破阻塞，因此不需要靠考虑主线程会执行到30行结束进程的情况。特别要说明的是例程第8行，当变量从线程传出的时候，需要加static修饰，对生命周期做出延续，否则无法传出正确的变量值。

测试例程7：（Phtread_txex7.c）

```c
1   #define _GNU_SOURCE 
2   #include <pthread.h>
3   #include <stdio.h>
4   #include <unistd.h>
5   #include <errno.h>
6 
7   void *fun(void *arg)
8   {
9       printf("Pthread:%d Come !\n",(int )(long)arg+1);
10      pthread_exit(arg);
11  }
12
13
14  int main()
15  {
16      int ret,i,flag = 0;
17      void *Tmp = NULL;
18      pthread_t tid[3];
19      for(i = 0;i < 3;i++){
20          ret = pthread_create(&tid[i],NULL,fun,(void *)(long)i);
21          if(ret != 0){
22              perror("pthread_create");
23              return -1;
24          }
25      }
26      while(1){//通过非阻塞方式收回线程，每次成功回收一个线程变量自增，直至3个线程全数回收
27          for(i = 0;i <3;i++){
28              if(pthread_tryjoin_np(tid[i],&Tmp) == 0){
29                  printf("Pthread : %d exit !\n",(int )(long )Tmp+1);
30                  flag++; 
31              }
32          }
33          if(flag >= 3) break;
34      }
35      return 0;
36  }
37
```

运行结果：



![img](https://pic2.zhimg.com/80/v2-da5b7e20b18305075ce74b6f3205c845_720w.webp)



 例程7展示了如何使用非阻塞方式来回收线程，此外也展示了多个线程可以指向同一个回调函数的情况。例程6通过阻塞方式回收线程几乎规定了线程回收的顺序，若最先回收的线程未退出，则一直会被阻塞，导致后续先退出的线程无法及时的回收。

 通过函数pthread_tryjoin_np，使用非阻塞回收，线程可以根据退出先后顺序自由的进行资源的回收。

测试例程8：（Phtread_txex8.c）

```c
1   #define _GNU_SOURCE 
2   #include <pthread.h>
3   #include <stdio.h>
4   #include <unistd.h>
5   #include <errno.h>
6 
7   void *fun1(void *arg)
8   {
9       printf("Pthread:1 come!\n");
10      while(1){
11          sleep(1);
12      }
13  }
14
15  void *fun2(void *arg)
16  {
17      printf("Pthread:2 come!\n");
18      pthread_cancel((pthread_t )(long)arg);//杀死线程1，使之强制退出
19      pthread_exit(NULL);
20  }
21
22  int main()
23  {
24      int ret,i,flag = 0;
25      void *Tmp = NULL;
26      pthread_t tid[2];
27      ret = pthread_create(&tid[0],NULL,fun1,NULL);
28      if(ret != 0){
29          perror("pthread_create");
30          return -1;
31      }
32      sleep(1);
33      ret = pthread_create(&tid[1],NULL,fun2,(void *)tid[0]);//传输线程1的线程号
34      if(ret != 0){
35          perror("pthread_create");
36          return -1;
37      }
38      while(1){//通过非阻塞方式收回线程，每次成功回收一个线程变量自增，直至2个线程全数回收

39          for(i = 0;i <2;i++){
40              if(pthread_tryjoin_np(tid[i],NULL) == 0){
41                  printf("Pthread : %d exit !\n",i+1);
42                  flag++; 
43              }
44          }
45          if(flag >= 2) break;
46      }
47      return 0;
48  }
49
```

运行结果：



![img](https://pic2.zhimg.com/80/v2-4ee8da412fc664a9689ad335317c27e5_720w.webp)



 例程8展示了如何利用pthread_cancel函数主动的将某个线程结束。27行与33行创建了线程，将第一个线程的线程号传参形式传入了第二个线程。第一个的线程执行死循环睡眠逻辑，理论上除非进程结束，其永远不会结束，但在第二个线程中调用了pthread_cancel函数，相当于向该线程发送一个退出的指令，导致线程被退出，最终资源被非阻塞回收掉。此例程要注意第32行的sleep函数，一定要确保线程1先执行，因线程是无序执行，故加入该睡眠函数控制顺序，在本章后续，会讲解通过加锁、信号量等手段来合理的控制线程的临界资源访问与线程执行顺序控制。

### 5.2 线程的控制

#### 5.2.1 多线程编临界资源访问

 当线程在运行过程中，去操作公共资源，如全局变量的时候，可能会发生彼此“矛盾”现象。例如线程1企图想让变量自增，而线程2企图想要变量自减，两个线程存在互相竞争的关系导致变量永远处于一个“平衡状态”，两个线程互相竞争，线程1得到执行权后将变量自加，当线程2得到执行权后将变量自减，变量似乎永远在某个范围内浮动，无法到达期望数值，如例程9所示。

测试例程9：（Phtread_txex9.c）

```c
1   #define _GNU_SOURCE 
2   #include <pthread.h>
3   #include <stdio.h>
4   #include <unistd.h>
5   #include <errno.h>
6 
7 
8   int Num = 0;
9 
10  void *fun1(void *arg)
11  {
12      while(Num < 3){
13          Num++;
14          printf("%s:Num = %d\n",__FUNCTION__,Num);
15          sleep(1);
16      }
17      pthread_exit(NULL);
18  }
19
20  void *fun2(void *arg)
21  {
22      while(Num > -3){
23          Num--;
24          printf("%s:Num = %d\n",__FUNCTION__,Num);
25          sleep(1);
26      }
27      pthread_exit(NULL);
28  }
29
30  int main()
31  {
32      int ret;
33      pthread_t tid1,tid2;
34      ret = pthread_create(&tid1,NULL,fun1,NULL);
35      if(ret != 0){
36          perror("pthread_create");
37          return -1;
38      }
39      ret = pthread_create(&tid2,NULL,fun2,NULL);
40      if(ret != 0){
41          perror("pthread_create");
42          return -1;
43      }
44      pthread_join(tid1,NULL);
45      pthread_join(tid2,NULL);
46      return 0;
47  }
48
```

运行结果：



![img](https://pic2.zhimg.com/80/v2-2a74ee1002dcf14191cee19ff0d5f561_720w.webp)



 为了解决上述对临界资源的竞争问题，pthread线程引出了互斥锁来解决临界资源访问。通过对临界资源加锁来保护资源只被单个线程操作，待操作结束后解锁，其余线程才可获得操作权。

#### 5.2.2 互斥锁API简述

```c
初始化互斥锁
#include <pthread.h>
int pthread_mutex_init(phtread_mutex_t *mutex,
const pthread_mutexattr_t *restrict attr);
成功：返回0
```

 该函数作用为初始化一个互斥锁，一般情况申请一个全局的pthread_mutex_t类型的互斥锁变量，通过此函数完成锁内的初始化，第一个函数将该变量的地址传入，第二个参数为控制互斥锁的属性，一般为NULL。当函数成功后会返回0，代表初始化互斥锁成功。当然初始化互斥锁也可以调用宏来快速初始化：

pthread_mutex_t mutex = PTHREAD_MUTEX_INITALIZER;

```c
互斥锁加锁（阻塞）/解锁 
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

 lock函数与unlock函数分别为加锁解锁函数，只需要传入已经初始化好的pthread_mutex_t互斥锁变量，成功后会返回0。当某一个线程获得了执行权后，执行lock函数，一旦加锁成功后，其余线程遇到lock函数时候会发生阻塞，直至获取资源的线程执行unlock函数后，获得第二执行权的线程的阻塞模式被从开，同时也获取了lock，导致其余线程同样在阻塞，直至执行unlock被解锁。

 特别注意的是，当获取lock之后，必须在逻辑处理结束后执行unlock，否则会发生死锁现象！导致其余线程一直处于阻塞状态，无法执行下去。在使用互斥锁的时候，尤其要注意使用pthread_cancel函数，防止发生死锁现象！

```c
互斥锁加锁（非阻塞）
#include <pthread.h>
 int pthread_mutex_trylock(pthread_mutex_t *mutex);
成功：返回0
```

 该函数同样也是一个线程加锁函数，但该函数是非阻塞模式通过返回值来判断是否加锁成功，用法与上述阻塞加速函数一致。

```c
互斥锁销毁
#include <pthread.h>
int pthread_mutex_destory(pthread_mutex_t *mutex);
成功：返回0
```

 该函数是用于销毁互斥锁的，传入互斥锁的地址，就可以完成互斥锁的销毁，成功返回0。

测试例程10：（Phtread_txex10.c）

```c
1   #define _GNU_SOURCE 
2   #include <pthread.h>
3   #include <stdio.h>
4   #include <unistd.h>
5   #include <errno.h>
6 
7   pthread_mutex_t mutex;//互斥锁变量 一般申请全局变量
8 
9   int Num = 0;//公共临界变量
10
11  void *fun1(void *arg)
12  {
13      pthread_mutex_lock(&mutex);//加锁 若有线程获得锁，则会阻塞
14      while(Num < 3){
15          Num++;
16          printf("%s:Num = %d\n",__FUNCTION__,Num);
17          sleep(1);
18      }
19      pthread_mutex_unlock(&mutex);//解锁
20      pthread_exit(NULL);//线程退出 pthread_join会回收资源
21  }
22
23  void *fun2(void *arg)
24  {
25      pthread_mutex_lock(&mutex);//加锁 若有线程获得锁，则会阻塞
26      while(Num > -3){
27          Num--;
28          printf("%s:Num = %d\n",__FUNCTION__,Num);
29          sleep(1);
30      }
31      pthread_mutex_unlock(&mutex);//解锁
32      pthread_exit(NULL);//线程退出 pthread_join会回收资源
33  }
34
35  int main()
36  {
37      int ret;
38      pthread_t tid1,tid2;
39      ret = pthread_mutex_init(&mutex,NULL);//初始化互斥锁
40      if(ret != 0){
41          perror("pthread_mutex_init");
42          return -1;
43      }
44      ret = pthread_create(&tid1,NULL,fun1,NULL);//创建线程1
45      if(ret != 0){
46          perror("pthread_create");
47          return -1;
48      }
49      ret = pthread_create(&tid2,NULL,fun2,NULL);//创建线程2
50      if(ret != 0){
51          perror("pthread_create");
52          return -1;
53      }
54      pthread_join(tid1,NULL);//阻塞回收线程1
55      pthread_join(tid2,NULL);//阻塞回收线程2
56      pthread_mutex_destroy(&mutex);//销毁互斥锁
57      return 0;
58  }
59
```

运行结果：



![img](https://pic2.zhimg.com/80/v2-440e7c064c2823fda9fc6c9e0594dc39_720w.webp)



 上述例程通过加入互斥锁，保证了临界变量某一时刻只被某一线程控制，实现了临界资源的控制。需要说明的是，线程加锁在循环内与循环外的情况。本历程在进入while循环前进行了加锁操作，在循环结束后进行的解锁操作，如果将加锁解锁全部放入while循环内，作为单核的机器，执行结果无异，当有多核机器执行代码时，可能会发生“抢锁”现象，这取决于操作系统底层的实现。

#### 5.2.3 多线程编执行顺序控制

 解决了临界资源的访问，但似乎对线程的执行顺序无法得到控制，因线程都是无序执行，之前采用sleep强行延时的方法勉强可以控制执行顺序，但此方法在实际项目情况往往是不可取的，其仅仅可解决线程创建的顺序，当创建之后执行的顺序又不会受到控制，于是便引入了信号量的概念，解决线程执行顺序。

 例程11将展示线程的执行的随机性。

测试例程11：（Phtread_txex11.c）

```c
1   #define _GNU_SOURCE 
2   #include <pthread.h>
3   #include <stdio.h>
4   #include <unistd.h>
5   #include <errno.h>
6 
7   void *fun1(void *arg)
8   {
9       printf("%s:Pthread Come!\n",__FUNCTION__);
10      pthread_exit(NULL);
11  }
12
13  void *fun2(void *arg)
14  {
15      printf("%s:Pthread Come!\n",__FUNCTION__);
16      pthread_exit(NULL);
17  }
18
19  void *fun3(void *arg)
20  {
21      printf("%s:Pthread Come!\n",__FUNCTION__);
22      pthread_exit(NULL);
23  }
24
25  int main()
26  {
27      int ret;
28      pthread_t tid1,tid2,tid3;
29      ret = pthread_create(&tid1,NULL,fun1,NULL);
30      if(ret != 0){
31          perror("pthread_create");
32          return -1;
33      }
34      ret = pthread_create(&tid2,NULL,fun2,NULL);
35      if(ret != 0){
36          perror("pthread_create");
37          return -1;
38      }
39      ret = pthread_create(&tid3,NULL,fun3,NULL);
40      if(ret != 0){
41          perror("pthread_create");
42          return -1;
43      }
44      pthread_join(tid1,NULL);
45      pthread_join(tid2,NULL);
46      pthread_join(tid3,NULL);
47      return 0;
48  }
49
```

运行结果：



![img](https://pic3.zhimg.com/80/v2-5ff19830ba7bf3dd20e5f0b8a0ee6c12_720w.webp)



 通过上述例程可以发现，多次执行该函数其次序是无序的，线程之间的竞争无法控制，通过使用信号量来使得线程顺序为可控的。

#### 5.2.4 信号量API简述

```c
初始化信号量
#include <semaphore.h>
int sem_init(sem_t *sem,int pshared,unsigned int value);
成功：返回0
```

 该函数可以初始化一个信号量，第一个参数传入sem_t类型的地址，第二个参数传入0代表线程控制，否则为进程控制，第三个参数表示信号量的初始值，0代表阻塞，1代表运行。待初始化结束信号量后，若执行成功会返回0。

```c
信号量PV操作（阻塞）
#include <pthread.h>
int sem_wait(sem_t *sem);
int sem_post(sem_t *sem);
成功：返回0
```

 sem_wait函数作用为检测指定信号量是否有资源可用，若无资源可用会阻塞等待，若有资源可用会自动的执行“sem-1”的操作。所谓的“sem-1”是与上述初始化函数中第三个参数值一致，成功执行会返回0.

 sem_post函数会释放指定信号量的资源，执行“sem+1”操作。

 通过以上2个函数可以完成所谓的PV操作，即信号量的申请与释放，完成对线程执行顺序的控制。

```c
信号量申请资源（非阻塞）
#include <pthread.h>
int sem_trywait(sem_t *sem);
成功：返回0
```

 与互斥锁一样，此函数是控制信号量申请资源的非阻塞函数，功能与sem_wait一致，唯一区别在于此函数为非阻塞。

```c
信号量销毁
#include <pthread.h>
int sem_destory(sem_t *sem);
成功：返回0
```

 该函数为信号量销毁函数，执行过后可将申请的信号量进行销毁。

测试例程12：（Phtread_txex12.c）

```c
1   #define _GNU_SOURCE 
2   #include <pthread.h>
3   #include <stdio.h>
4   #include <unistd.h>
5   #include <errno.h>
6   #include <semaphore.h>
7 
8   sem_t sem1,sem2,sem3;//申请的三个信号量变量
9 
10  void *fun1(void *arg)
11  {
12      sem_wait(&sem1);//因sem1本身有资源，所以不被阻塞 获取后sem1-1 下次会会阻塞
13      printf("%s:Pthread Come!\n",__FUNCTION__);
14      sem_post(&sem2);// 使得sem2获取到资源
15      pthread_exit(NULL);
16  }
17
18  void *fun2(void *arg)
19  {
20      sem_wait(&sem2);//因sem2在初始化时无资源会被阻塞，直至14行代码执行 不被阻塞 sem2-1 下次会阻塞
21      printf("%s:Pthread Come!\n",__FUNCTION__);
22      sem_post(&sem3);// 使得sem3获取到资源
23      pthread_exit(NULL);
24  }
25
26  void *fun3(void *arg)
27  {
28      sem_wait(&sem3);//因sem3在初始化时无资源会被阻塞，直至22行代码执行 不被阻塞 sem3-1 下次会阻塞
29      printf("%s:Pthread Come!\n",__FUNCTION__);
30      sem_post(&sem1);// 使得sem1获取到资源
31      pthread_exit(NULL);
32  }
33
34  int main()
35  {
36      int ret;
37      pthread_t tid1,tid2,tid3;
38      ret = sem_init(&sem1,0,1);  //初始化信号量1 并且赋予其资源
39      if(ret < 0){
40          perror("sem_init");
41          return -1;
42      }
43      ret = sem_init(&sem2,0,0); //初始化信号量2 让其阻塞
44      if(ret < 0){
45          perror("sem_init");
46          return -1;
47      }
48      ret = sem_init(&sem3,0,0); //初始化信号3 让其阻塞
49      if(ret < 0){
50          perror("sem_init");
51          return -1;
52      }
53      ret = pthread_create(&tid1,NULL,fun1,NULL);//创建线程1
54      if(ret != 0){
55          perror("pthread_create");
56          return -1;
57      }
58      ret = pthread_create(&tid2,NULL,fun2,NULL);//创建线程2
59      if(ret != 0){
60          perror("pthread_create");
61          return -1;
62      }
63      ret = pthread_create(&tid3,NULL,fun3,NULL);//创建线程3
64      if(ret != 0){
65          perror("pthread_create");
66          return -1;
67      }
68      /*回收线程资源*/
69      pthread_join(tid1,NULL);
70      pthread_join(tid2,NULL);
71      pthread_join(tid3,NULL);
72
73      /*销毁信号量*/
74      sem_destroy(&sem1);
75      sem_destroy(&sem2);
76      sem_destroy(&sem3);
77
78      return 0;
79  }
80
```

运行结果：



![img](https://pic3.zhimg.com/80/v2-3638b3ea54a8fbf5b781317cd9db3e0e_720w.webp)



 该例程加入了信号量的控制使得线程的执行顺序变为可控的，在初始化信号量时，将信号量1填入资源，使之不被sem_wait函数阻塞，在执行完逻辑后使用sem_pos函数来填入即将要执行的资源。当执行函数sem_wait后，会执行sem自减操作，使下一次竞争被阻塞，直至通过sem_pos被释放。

 上述例程因38行初始化信号量1时候，使其默认获取到资源，43、48行初始化信号量2、3时候，使之没有资源。于是在线程处理函数中，每个线程通过sem_wait函数来等待资源，发送阻塞现象。因信号量1初始值为有资源，故可以先执行线程1的逻辑。待执行完第12行sem_wait函数，会导致sem1-1，使得下一次此线程会被阻塞。继而执行至14行，通过sem_post函数使sem2信号量获取资源，从而冲破阻塞执行线程2的逻辑...以此类推完成线程的有序控制。

### 5.3 总结

 有关多线程的创建流程下图所示，首先需要创建线程，一旦线程创建完成后，线程与线程之间会发生竞争执行，抢占时间片来执行线程逻辑。在创建线程时候，可以通过创建线程的第四个参数传入参数，在线程退出时亦可传出参数被线程回收函数所回收，获取到传出的参数。



![img](https://pic3.zhimg.com/80/v2-416508ee981bc471cd002d631c65438e_720w.webp)





线程编程流程



 当多个线程出现后，会遇到同时操作临界公共资源的问题，当线程操作公共资源时需要对线程进行保护加锁，防止其与线程在此线程更改变量时同时更改变量，待逻辑执行完毕后再次解锁，使其余线程再度开始竞争。互斥锁创建流程下图所示。



![img](https://pic3.zhimg.com/80/v2-d39a9d93f2132759974e3a2ff5cf0f66_720w.webp)





互斥锁编程流程



 当多个线程出现后，同时会遇到无序执行的问题。有时候需要对线程的执行顺序做出限定，变引入了信号量，通过PV操作来控制线程的执行顺序，下图所示。



![img](https://pic1.zhimg.com/80/v2-83beff95d7df347040ac8fe86fb0b1c0_720w.webp)





信号量编程流程



## 6 网络编程

### **6.1** **网络编程简介**

 要编写通过计算机网络通信的程序，首先要确定这些程序同通信的协议（protocol），在设计一个协议的细节之前，首先要分清程序是由哪个程序发起以及响应何时产生。

 举例来说，一般认为WEB服务器程序是一个长时间运行的程序（守护进程deamon），它只在响应来自网络的请求时才发送网络消息。协议的另一端是web客户程序，如某种浏览器，与服务器进程的通信总是由客户进程发起。大多数网络应用就是按照划分为客户（clinet）和服务器（server）来组织的。

#### **6.1.1** **五层因特网协议栈**

 为了给网络协议的设计提供一个结构，网络设计者以分层（layer）的方式组织协议以及实现这些协议的网络硬件和软件。

分层提供了一种结构化方式来讨论系统组件。模块化使更新系统组件更为容易。

协议栈是各层所有协议的总和。



![img](https://pic3.zhimg.com/80/v2-67bb1f566c603ebbf5ba84db7e89f212_720w.webp)





五层因特网协议栈



应用层：应用层是网络应用程序及它们的应用层协议存留的地方。

运输层：因特网的运输层在应用程序端点之间传从应用层报文。

网络层：因特网呃网络层负责将称为数据包（datagram）的网络层分组从一台主机移动到另一台主机。

链路层：因特网的网络层通过源和目的地之间的一系列路由器路由数据报。

物理层：虽然链路层的任务是将整个帧从一个网络元素移动到临近的网络元素，而物理层的任务是将该帧的一个一个比特从一个节点移动到下一个节点。

#### 6.1.2 传输层和应用层的常见协议

 我们重点介绍和应用层编程关系密切的应用层和运输层。

 应用层：

 因特网的应用层包含很多协议，例如HTTP，SMTP，和 FTP。我们看到的某些网络功能，比如将[http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com)这样对人友好的端系统名字转换为32比特网络地址，也是借助于特定的应用层协议即域名系统（DNS）完成的。

 应用层的协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。

 运输层：

 在英特网中有两个运输协议，即TCP和UDP，利用其中的任何一个都能运输应用层报文。我们写应用程序的时候具体选择哪个运输层协议应该根据实际情况来确定（后面会具体讲解）。

### **6.2** **网络编程之TCP/UDP比较**

#### 6.2.1 TCP和UDP 原理上的区别

 TCP向它的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配）。这种服务包括了应用层报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时源抑制其传输速率。

 UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。

#### 6.2.2 为何存在UDP协议

 既然TCP提供了可靠数据传输服务，而UDP不能提供，那么TCP是否总是首选呢？答案是否定的，因为有许多应用更适合用UDP，原因有以下几点：

a. 关于何时发送什么数据控制的更为精细。

 采用UDP时只要应用进程将数据传递给UDP，UDP就会立即将其传递给网络层。而TCP有重传机制，而不管可靠交付需要多长时间。但是实时应用通常不希望过分的延迟报文段的传送，且能容忍一部分数据丢失。

b. 无需建立连接，不会引入建立连接时的延迟。

c. 无连接状态，能支持更多的活跃客户。

d. 分组首部开销较小。

#### 6.2.3 TCP/UDP网络通信大概交互图

 下面我们分别画出运用TCP协议和运用UDP协议的客户端和服务器大概交互图。



![img](https://pic3.zhimg.com/80/v2-046bf0dc824572c1c07d6a8424acb2aa_720w.webp)





面向连接的TCP流模式





![img](https://pic1.zhimg.com/80/v2-c804455a01d790803ea4ae17c8b58ce0_720w.webp)





UDP用户数据包模式



### **6.3** **网络编程主要函数介绍**

#### 6.3.1 socket函数

```c
int socket(int domain, int type,int protocol);
```

此函数用于创建一个套接字。

**domain**是网络程序所在的主机采用的通讯协族(AF_UNIX和AF_INET等)。

AF_UNIX只能够用于单一的Unix 系统进程间通信，而AF_INET是针对Internet的，因而可以允许远程通信使用。

**type**是网络程序所采用的通讯协议(SOCK_STREAM,SOCK_DGRAM等)。

SOCK_STREAM表明用的是TCP 协议，这样会提供按顺序的，可靠，双向，面向连接的比特流。

SOCK_DGRAM 表明用的是UDP协议，这样只会提不可靠，无连接的通信。

关于**protocol**，由于指定了type，所以这个地方一般只要用0来代替就可以了。

此函数执行成功时返回文件描述符，失败时返回-1,看errno可知道出错的详细情况。

#### 6.3.2 bind函数

```c
int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
```

从函数用于将地址绑定到一个套接字。

**sockfd**是由socket函数调用返回的文件描述符。

**my_addr**是一个指向sockaddr的指针。

**addrlen**是sockaddr结构的长度。

sockaddr的定义：

```c
struct sockaddr{
unisgned short  as_family;
char sa_data[14];
};
```

不过由于系统的兼容性,我们一般使用另外一个结构(struct sockaddr_in) 来代替。

sockaddr_in的定义：

```c
struct sockaddr_in{
unsigned short          sin_family;     
unsigned short int      sin_port;
struct in_addr          sin_addr;
unsigned char           sin_zero[8];
}
```

如果使用Internet所以sin_family一般为AF_INET。

sin_addr设置为INADDR_ANY表示可以和任何的主机通信。

sin_port是要监听的端口号。

bind将本地的端口同socket返回的文件描述符捆绑在一起.成功是返回0,失败的情况和socket一样。

#### 6.3.3 listen函数

```c
int listen(int sockfd,int backlog);
```

此函数宣告服务器可以接受连接请求。

**sockfd**是bind后的文件描述符。

**backlog**设置请求排队的最大长度。当有多个客户端程序和服务端相连时，使用这个表示可以介绍的排队长度。

listen函数将bind的文件描述符变为监听套接字，返回的情况和bind一样。

#### 6.3.4 accept函数

```c
int accept(int sockfd, struct sockaddr *addr,int *addrlen);
```

服务器使用此函数获得连接请求，并且建立连接。

**sockfd**是listen后的文件描述符。

**addr**，**addrlen**是用来给客户端的程序填写的,服务器端只要传递指针就可以了， bind,listen和accept是服务器端用的函数。

accept调用时，服务器端的程序会一直阻塞到有一个客户程序发出了连接。 accept成功时返回最后的服务器端的文件描述符，这个时候服务器端可以向该描述符写信息了，失败时返回-1 。

#### 6.3.5 connect函数

```c
int connect(int sockfd, struct sockaddr \* serv_addr,int addrlen);
```

可以用connect建立一个连接，在connect中所指定的地址是想与之通信的服务器的地址。

**sockfd**是socket函数返回的文件描述符。

**serv_addr**储存了服务器端的连接信息，其中sin_add是服务端的地址。

**addrlen**是serv_addr的长度

connect函数是客户端用来同服务端连接的.成功时返回0，sockfd是同服务端通讯的文件描述符，失败时返回-1。

#### 6.3.6 send函数

```c
ssize_t send(int sockfd, const void \*buf, size_t len, int flags);
```

**sockfd** 指定发送端套接字描述符；

**buf** 指明一个存放应用程序要发送数据的缓冲区；

**len** 指明实际要发送的数据的字节数；

**flags** 一般置0。

客户或者服务器应用程序都用send函数来向TCP连接的另一端发送数据

#### 6.3.7 recv函数

```c
ssize_t recv(int sockfd, void \*buf, size_t len, int flags);
```

**sockfd** 指定接收端套接字描述符；

**buf** 指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；

**len** 指明buf的长度；

**flags** 一般置0。

客户或者服务器应用程序都用recv函数从TCP连接的另一端接收数据。

#### 6.3.8 recvfrom函数

```c
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,

                struct sockaddr *src_addr, socklen_t *addrlen);
```

recvfrom通常用于无连接套接字，因为此函数可以获得发送者的地址。

**src_addr** 是一个struct sockaddr类型的变量，该变量保存源机的IP地址及端口号。

**addrlen** 常置为sizeof （struct sockaddr）。

#### 6.3.9 sendto函数

```c
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,

               const struct sockaddr *dest_addr, socklen_t addrlen);
```

sendto和send相似，区别在于sendto允许在无连接的套接字上指定一个目标地址。

**dest_addr** 表示目地机的IP地址和端口号信息，

**addrlen** 常常被赋值为sizeof （struct sockaddr）。

**sendto** 函数也返回实际发送的数据字节长度或在出现发送错误时返回－1。

### 6.4 TCP编程简单示例

 服务器首先进行初始化操作：调用函数socket创建一个套接字，函数bind将这个套接字与服务器的公认地址绑定在一起，函数listen将这个套接字换成倾听套接字，然后调用函数accept来等待客户机的请求。过了一段时间后，客户机启动，调用socket创建一个套接字，然后调用函数connect来与服务器建立连接。连接建立之后，客户机和服务器通过读、写套接字来进行通信。

#### 6.**4.1** 服务器端代码

参考：TCP/server_line.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4#include <sys/types.h>
5#include <sys/socket.h>
6#include <netinet/in.h>
7#include <arpa/inet.h>
8#include <unistd.h>
9#include <signal.h>
10
11#define SERVER_PORT 8180
12#define C_QUEUE     10 
13
14/************************************************************
15*函数功能描述：从8180端口接收客户端数据
16*输入参数：无
17*输出参数：打印客户IP以及发来的信息
18*返回值：无
19*修改日期     版本号     修改人     修改内容
20*2020/05/13       v1.0.0      zonghzha    reat
21*************************************************************/
22
23int main(int argc, char **argv)
24{
25    char buf[512];
26    int len;
27    int duty_socket;
28    int customer_socket;
29    struct sockaddr_in socket_server_addr;
30    struct sockaddr_in socket_client_addr;
31    int ret;
32    int addr_len;
33
34    signal(SIGCHLD, SIG_IGN);
35  
36    /* 服务器端开始建立socket描述符 */
37    duty_socket = socket(AF_INET, SOCK_STREAM, 0);
38    if (duty_socket == -1)
39    {
40        printf("socket error");
41        return -1;
42    }
43    
44    /* 服务器端填充 sockaddr_in结构 */
45    socket_server_addr.sin_family   = AF_INET;
46    /* 端口号转换为网络字节序 */
47    socket_server_addr.sin_port     = htons(SERVER_PORT);
48    /* 接收本机所有网口的数据 */
49    socket_server_addr.sin_addr.s_addr  = INADDR_ANY;
50    memset(socket_server_addr.sin_zero, 0, 8);
51    
52    /* 捆绑sockfd描述符 */
53    ret = bind(duty_socket, (const struct sockaddr *)&socket_server_addr, sizeof(struct sockaddr));
54    if (ret == -1)
55    {
56        printf("bind error!\n");
57        return -1;
58    }
59    ret = listen(duty_socket, C_QUEUE);
60    if (ret == -1)
61    {
62        printf("listen error!\n");
63        return -1;
64    }
65    
66    while (1)
67    {
68        addr_len = sizeof(struct sockaddr);
69        /* 服务器阻塞,直到客户程序建立连接 */
70        customer_socket = accept(duty_socket, (struct sockaddr *)&socket_client_addr, &addr_len);
71        if (customer_socket != -1)
72        {
73            /*inet_ntoa的作用是将一个32位Ipv4地址转换为相应的点分十进制数串*/
74            printf("Get connect from %s\n", inet_ntoa(socket_client_addr.sin_addr));
75        }
76        if (!fork())
77        {
78            while (1)
79            {
80                memset(buf, 512, 0);
81                /*接收数据*/
82                len = recv(customer_socket, buf, sizeof(buf), 0);
83                buf[len] = '\0';
84                if (len <= 0)
85                {
86                    close(customer_socket);
87                    return -1;
88                }
89                else
90                {
91                    printf("Get connect from %s, Msg is %s\n", inet_ntoa(socket_client_addr.sin_addr), buf);
92                }
93            }
94        }
95    }
96    
97    close(duty_socket);
98    return 0;
99}
```

#### 6.4.2 客户端代码

参考：TCP/client_line.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4#include <sys/types.h>
5#include <sys/socket.h>
6#include <netinet/in.h>
7#include <arpa/inet.h>
8#include <unistd.h>
9
10#define SERVER_PORT 8180
11/************************************************************
12*函数功能描述：向指定IP的8180端口发送数据
13*输入参数：点分十进制服务器IP
14*输出参数：无
15*返回值：无
16*修改日期     版本号     修改人     修改内容
17*2020/05/13       v1.0.0      zonghzha    creat
18*************************************************************/
19
20int main(int argc, char **argv)
21{
22    unsigned char buf[512];
23    int len;
24    struct sockaddr_in socket_server_addr;
25    int ret;
26    int addr_len;
27    int client_socket;
28
29    
30    if (argc != 2)
31    {
32        printf("Usage:\n");
33        printf("%s <server_ip>\n", argv[0]);
34        return -1;
35    }
36    
37    /* 客户程序开始建立 sockfd描述符 */
38    client_socket = socket(AF_INET, SOCK_STREAM, 0);
39    if (client_socket == -1)
40    {
41        printf("socket error");
42        return -1;
43    }
44    
45    /* 客户程序填充服务端的资料 */
46    socket_server_addr.sin_family   = AF_INET;
47    /*主机字节序转换为网络字节序*/
48    socket_server_addr.sin_port     = htons(SERVER_PORT);
49    if (inet_aton(argv[1], &socket_server_addr.sin_addr) == 0)
50    {
51        printf("invalid server ip\n");
52        return -1;
53    }
54    memset(socket_server_addr.sin_zero, 0, 8);
55    /* 客户程序发起连接请求 */
56    ret = connect(client_socket, (const struct sockaddr *)&socket_server_addr, sizeof(struct sockaddr));
57    if (ret == -1)
58    {
59        printf("connect error!\n");
60        return -1;
61    }
62
63    
64    while (1)
65    {
66        if (fgets(buf, sizeof(buf), stdin))
67        {
68            len = send(client_socket, buf, strlen(buf), 0);
69            if (len <= 0)
70            {
71                close(client_socket);
72                return -1;
73            }
74        }
75    }
76    
77    close(client_socket);
78    return 0;
79}
```

#### 6.4.3 Makefile文件

```c
all:server client
server:server.c
    gcc $^ -o $@
client:client.c
    gcc $^ -o $@
clean:
    rm server client -f

（注意：命令语句的开头要用“Tab”键。）
```

#### 6.4.4 执行

服务器端：

```c
./server
```

客户端：

```c
./client 127.0.0.1
```

客户端输入：

```c
good night
```

服务器端显示：

```c
Get connect from 127.0.0.1
Get connect from 127.0.0.1, Msg is good night
```

### 6.5 UDP编程简单示例

 UDP服务器首先进行初始化操作：调用函数socket创建一个数据报类型的套接字，函数bind将这个套接字与服务器的公认地址绑定在一起。然后调用函数recvfrom接收UDP客户机的数据报。UDP客户机首先调用函数socket创建一个数据报套接字，然后调用函数sendto向服务器发送数据报。在结束通信后，客户机调用close关闭UDP套接字，服务器继续使用这个UDP套接字接收其它客户机的数据报。

#### 6.**5.1** 服务器端代码

参考UDP/server_line.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4//#include <sys/type.h>
5#include <sys/socket.h>
6#include <netinet/in.h>
7#include <arpa/inet.h>
8#include <unistd.h>
9#include <signal.h>
10
11/*服务器端口为8180*/
12#define SERVER_PORT 8180
13
14/************************************************************
15*函数功能描述：从8180端口接收客户端数据
16*输入参数：无
17*输出参数：打印客户IP以及发来的信息
18*返回值：无
19*修改日期         版本号         修改人         修改内容
20*2020/05/13           v1.0.0          zonghzha        creat
21*************************************************************/
22
23
24int main(int argc, char **argv)
25{
26    unsigned char buf[512];
27    int len;
28    int duty_socket;
29    int customer_socket;
30    struct sockaddr_in socket_server_addr;
31    struct sockaddr_in socket_client_addr;
32    int ret;
33    int addr_len;
34
35    /* 创建数据报套接字 */
36    duty_socket = socket(AF_INET, SOCK_DGRAM, 0);
37    if (duty_socket == -1)
38    {
39        printf("socket error");
40        return -1;
41    }
42    
43    /* 服务器端填充 sockaddr_in结构 */
44    socket_server_addr.sin_family   = AF_INET;
45    socket_server_addr.sin_port     = htons(SERVER_PORT);
46    socket_server_addr.sin_addr.s_addr  = INADDR_ANY;
47    memset(socket_server_addr.sin_zero, 0, 8);
48    
49    /*绑定套接字*/
50    ret = bind(duty_socket, (const struct sockaddr *)&socket_server_addr, sizeof(struct sockaddr));
51    if (ret == -1)
52    {
53        printf("bind error!\n");
54        return -1;
55    }
56
57    
58    while (1)
59    {
60        addr_len = sizeof(struct sockaddr);
61        /* 接收客户端数据报，返回的为接收到的字节数 */ 
62        len = recvfrom(duty_socket, buf, sizeof(buf), 0, (struct sockaddr *)&socket_client_addr, &addr_len);
63        if (len > 0)
64        {
65            buf[len] = '\0';
66            printf("Get Msg from %s : %s\n", inet_ntoa(socket_client_addr.sin_addr), buf);
67        }
68   
69    }
70    
71    close(duty_socket);
72    return 0;
73}
74
```

#### **6.5.2** **客户端代码**

##### 6.**5.2.1** 客户端程序1

参考UDP/client_line_1.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4#include <sys/socket.h>
5#include <netinet/in.h>
6#include <arpa/inet.h>
7#include <unistd.h>
8
9#define SERVER_PORT 8180
10
11/************************************************************
12*函数功能描述：向指定IP的8180端口发送数据
13*输入参数：点分十进制服务器IP
14*输出参数：无
15*返回值：无
16*修改日期         版本号         修改人         修改内容
17*2020/05/13           v1.0.0          zonghzha        creat
18*************************************************************/
19
20int main(int argc, char **argv)
21{
22    unsigned char buf[512];
23    int len;
24    struct sockaddr_in socket_server_addr;
25    int ret;
26    int addr_len;
27    int client_socket;
28
29    
30    if (argc != 2)
31    {
32        printf("Usage:\n");
33        printf("%s <server_ip>\n", argv[0]);
34        return -1;
35    }
36    
37    /*创建套接字*/
38    client_socket = socket(AF_INET, SOCK_DGRAM, 0);
39    if (client_socket == -1)
40    {
41        printf("socket error");
42        return -1;
43    }
44    
45    /* 填充服务端的资料 */
46    socket_server_addr.sin_family   = AF_INET;
47    socket_server_addr.sin_port     = htons(SERVER_PORT);
48    if (inet_aton(argv[1], &socket_server_addr.sin_addr) == 0)
49    {
50        printf("invalid server ip\n");
51        return -1;
52    }
53    memset(socket_server_addr.sin_zero, 0, 8);
54    
55
56
57    
58    while (1)
59    {
60        if (fgets(buf, sizeof(buf), stdin))
61        {
62 //           len = send(client_socket, buf, strlen(buf), 0);
63            /*向服务器端发送数据报*/
64            addr_len = sizeof(struct sockaddr);
65            len = sendto(client_socket, buf, sizeof(buf), 0, (struct sockaddr *)&socket_server_addr, addr_len);
66            if (len <= 0)
67            {
68                close(client_socket);
69                return -1;
70            }
71        }
72    }
73    
74    close(client_socket);
75    return 0;
76}
77
```

问：用UDP协议写网络通讯程序不可以用connect函数吗？

答：非也。

##### 6.**5.2.2** **客户端程序2**

参考UDP/client_line_2.c

```c
1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4#include <sys/socket.h>
5#include <netinet/in.h>
6#include <arpa/inet.h>
7#include <unistd.h>
8
9/*服务器端口为8180*/
10#define SERVER_PORT 8180
11
12/************************************************************
13*函数功能描述：向指定IP的8180端口发送数据
14*输入参数：点分十进制服务器IP
15*输出参数：无
16*返回值：无
17*修改日期         版本号         修改人         修改内容
18*2020/05/13           v1.0.0          zonghzha        creat
19*************************************************************/
20
21int main(int argc, char **argv)
22{
23    unsigned char buf[512];
24    int len;
25    struct sockaddr_in socket_server_addr;
26    int ret;
27    int addr_len;
28    int client_socket;
29
30    
31    if (argc != 2)
32    {
33        printf("Usage:\n");
34        printf("%s <server_ip>\n", argv[0]);
35        return -1;
36    }
37    
38    /*创建数据报套接字*/
39    client_socket = socket(AF_INET, SOCK_DGRAM, 0);
40    if (client_socket == -1)
41    {
42        printf("socket error");
43        return -1;
44    }
45    
46    socket_server_addr.sin_family   = AF_INET;
47    socket_server_addr.sin_port     = htons(SERVER_PORT);
48    if (inet_aton(argv[1], &socket_server_addr.sin_addr) == 0)
49    {
50        printf("invalid server ip\n");
51        return -1;
52    }
53    memset(socket_server_addr.sin_zero, 0, 8);
54    
55    ret = connect(client_socket, (const struct sockaddr *)&socket_server_addr, sizeof(struct sockaddr));
56    if (ret == -1)
57    {
58        printf("connect error!\n");
59        return -1;
60    }
61
62    
63    while (1)
64    {
65        if (fgets(buf, sizeof(buf), stdin))
66        {
67            len = send(client_socket, buf, strlen(buf), 0);
68            if (len <= 0)
69            {
70                close(client_socket);
71                return -1;
72            }
73        }
74    }
75    
76    close(client_socket);
77    return 0;
78}
79
```

 在客户端代码2中，connect函数并非真的在协议层建立了连接，它只是指定了服务器的地址和端口号信息。

 因为在connect中指定了服务器的地址和端口号信息，所以后面的send就可以直接发送了，而不用再次指定地址和端口号。

#### 6.5.3 Makefile文件

```c
all:server client_1 client_2
server:server.c
    gcc $^ -o $@
client_1:client_1.c
    gcc $^ -o $@
client_2:client_2.c
    gcc $^ -o $@
clean:
    rm server client_1 client_2 -f

（注意：命令语句的开头要用“Tab”键。）
```

#### 6.5.4 执行

服务器端执行：

```c
./server
```

客户端执行：

```c
./client_1 127.0.0.1
```

客户端输入：

```c
good night
```

服务器端显示：

```c
Get Msg from 127.0.0.1 : good night
```

## 7 GPIO编程

### 7.1 GPIO编程基础介绍

 GPIO(General-Purpose IO Ports)，即通用IO接口。GPIO的使用较为简单，主要分为输入和输出两种功能。GPIO主要用于实现一些简单设备的控制。在作为输入型GPIO的情况下，我们可以将该IO连接外部按键或者传感器，用于检测外部状态。当作为输出时，我们可以通过输出高低电平来控制外部设备的运转。

 由于GPIO的功能多种多样，我们需要首先将引脚设置为GPIO。设置为GPIO之后，我们需要设置GPIO的方向。当设置为输出时，我们可以控制输出高电平或者低电平。当设置为输入时，我们可以读取GPIO的电平来判断外部输入电平的高低。

### 7.2 GPIO编程软件接口

 GPIO编程有多种实现方式，在这里，我们通过sysfs方式来实现GPIO的控制实现。

 如果要通过sysfs方式控制gpio，首先需要底层内核的支持。为了实现内核对sysfs gpio的支持，我们需要在内核中进行设置。在编译内核的时候，加入 Device Drivers-> GPIO Support ->/sys/class/gpio/… (sysfs interface)。作为GPIO的引脚，不允许在内核中被用作其他用途。

 在系统正常运行之后，我们可以在/sys/class/gpio下看到sysfs控制相关的接口。有三种类型的接口， 分别是控制接口，GPIO信号和GPIO控制器三种接口。这部分的具体介绍可参考《kernel\Documentation\gpio\sysfs.txt》。

#### 7.2.1 控制接口

 控制接口用于实现在用户空间对GPIO的控制，主要包括/sys/class/gpio/export和/sys/class/gpio/unexport两个接口。这这两个控制接口都是只写的，/sys/class/gpio/export实现将GPIO控制从内核空间导出到用户空间，/sys/class/gpio/unexport用于实现取消GPIO控制从内核空间到用户空间的导出。

 下面以引脚编号为19的GPIO为例进行说明，在/sys/class/gpio/目录下，我们执行"echo 19 > export"之后，将会产生一个”gpio19”节点来控制引脚编号为19的GPIO。我们执行"echo 19 > unexport"之后，将会删除之前通过export产生的”gpio19”节点。为了使用gpio，我们需要首先使用/sys/class/gpio/export导出gpio引脚编号。完成使用之后，通过/sys/class/gpio/unexport删除掉之前导出的gpio引脚。

#### 7.2.2 GPIO信号

 GPIO信号，即为GPIO本身，其路径为/sys/class/gpio/gpioN/,拥有多个属性。通过对这些属性进行控制，就可以实现对GPIO的控制。

- “direction”属性，读取的值为”in”或者”out”。通过对该属性写入”in”或者”out”可以设置该GPIO为输入或者输出。如果直接写入”out”，则会使GPIO直接输出低电平。也可以通过写入”low”或者”high”来直接设置输出低电平或者高电平。
- ”value”属性，用于读取输入电平或者控制输出电平。如果GPIO为输出，则对value写入0为输出低电平，写入非0为输出高电平。如果设置为输入的话，则读到0表示输入为低电平，1为高电平。
- ”edge”属性，用于设置触发电平，只有在GPIO可以设置为中断输入引脚时才会出现该属性。

#### 7.2.3 GPIO控制器

 GPIO控制器，用于表示GPIO 控制实现的初始GPIO，其路径为/sys/class/gpio/gpiochipN/。比如/sys/class/gpio/gpiochip42/ 则表示实现GPIO控制器的初始化编号为42。GPIO控制器的属性为只读属性，包括base、label和ngpio等多个。

- ”base”属性，和gpiochipN的N代表的含义相同，表示被该组GPIO控制器实现的第一个GPIO.
- ” ngpio”属性，用于表示该控制器支持多少个GPIO，支持的GPIO编号为从N到N+ngpio-1
- ” label”属性，用于判断控制器，并不总是唯一的

### 7.3 IMX6ULL开发板GPIO编号的确定

 每个芯片可以有N组GPIO，每组GPIO最多有32个GPIO，即最多有N*32个GPIO。但是在实际设计中，每组的GPIO数量各有不同。在IMX6ULL中，实际每组拥有的GPIO数量如下图所示，具体详见《IMX6ULLRM.pdf》手册1347页。



![img](https://pic1.zhimg.com/80/v2-fb4eba69de3c2d7b5421736bebd0da38_720w.webp)



 从上图可以看到，在IMX6ULL中，共有5组GPIO，起始GPIO组为GPIO1。因此在实际GPIO编号计算中，第一组GPIO1对应的编号为0~31。以此类推，IMX6ULL的GPION_X（N=1~5，X=0~31对应的编号实际为（N-1）*32+X。接下来，我们以板载的LED和按键各自对应的GPIO为例来说明如何在实际应用中计算GPIO编号。

#### 7.3.1 LED的GPIO编号计算

 从原理图中找到对应LED的设计，具体的连接如下图所示。从图中我们可以看到，LED连接到的GPIO为GPIO5_3，其对应的GPIO编号实际为（5-1）*32+3 = 131。因此，我们如果要在sys_gpio中操作LED，我们就需要将编号131的GPIO进行导出。



![img](https://pic2.zhimg.com/80/v2-213808a6a0eabebebcc3a75af50ff951_720w.webp)



#### 7.3.2 按键的GPIO编号计算

 从原理图中找到对应按键的设计，底板有2个按键，具体的连接如下图所示。从图中我们可以看到，两个按键连接到的GPIO分别为GPIO5_1和GPIO4_14，第一个按键KEY1对应的GPIO编号为（5-1） *32+1 = 129，第二个按键KEY2对应的GPIO编号为（4-1）* 32+14=110。因此，我们如果要在sys_gpio中读取按键KEY1和KEY2的值，，我们就需要将编号129和110的GPIO进行导出。



![img](https://pic3.zhimg.com/80/v2-306ee3fcbadbeb81493804ce0d2c65aa_720w.webp)



#### 7.3.3 特殊情况下的GPIO编号计算

 在有些情况下，起始的gpiochipN不是gpiochip0。这个时候 ，我们就需要在原有的GPIO编号基础上加上起始gpiochipN值进行计算。下图所示的为其实gpiochip为gpiochip0的情况。



![img](https://pic4.zhimg.com/80/v2-6ea388233862276c623f1b8d96eca10f_720w.webp)



### 7.4 实际编程操作

 在实际操作中，我们使用LED和按键实现了GPIO输出和输入的实验，相关的实验过程和相关代码如下。

#### 7.4.1 导出GPIO口

 为了导出GPIO口，我们需要向/sys/class/gpio/export写入需要导出的引脚编号。在使用之后，我们也可以使用/sys/class/gpio/unexport取消导出引脚编号。

 导出引脚编号的实现代码如下所示，具体详见《sysfs_gpio_1_export_gpio sysfs_gpio_export.c》的sysfs_gpio_export()函数。

```c
32 int sysfs_gpio_export(unsigned int gpio)
33 {
34     int fd, len;
35     char buf[MAX_BUF];
36  // /sys/class/gpio/export
37     fd = open( "/sys/class/gpio/export", O_WRONLY);//打开文件
38     if (fd < 0) {
39         perror("gpio/export");
40         return fd;
41     }
42  
43     len = snprintf(buf, sizeof(buf), "%d", gpio);//从数字变换为字符串，即1 变为”1“
44     write(fd, buf, len);//将需要导出的GPIO引脚编号进行写入
45     close(fd);//关闭文件
46  
47     return 0;
48 }
```

 取消导出引脚编号的实现代码如下所示，具体详见《sysfs_gpio_export.c》的sysfs_gpio_unexport()函数。

```c
59 int sysfs_gpio_unexport(unsigned int gpio)
60 {
61     int fd, len;
62     char buf[MAX_BUF];
63  // /sys/class/gpio/unexport
64     fd = open("/sys/class/gpio/unexport", O_WRONLY);//打开文件
65     if (fd < 0) {
66         perror("gpio/export");
67         return fd;
68     }
69  
70     len = snprintf(buf, sizeof(buf), "%d", gpio);//从数字变换为字符串，即1 变为”1“
71     write(fd, buf, len);//将需要取消导出的GPIO引脚编号进行写入
72     close(fd);//关闭文件
73     return 0;
74 }
```

 在实现导出和取消导出引脚编号的函数之后，我们来实现具体的引脚编号的导出。LED和按键各自对应的引脚编号如下所示

```c
11 #define GPIO4_14 110
12 #define GPIO5_1  129
13 #define GPIO5_3  131     
14 
15 #define GPIO_KEY1     GPIO4_14
16 #define GPIO_KEY2     GPIO5_1
17 #define GPIO_LED      GPIO5_3
```

 在确定了各自对应的引脚编号，我们就可以进行导出了。具体实现代码在程序文件《sysfs_gpio_1_export_gpio/sysfs_gpio_export.c》中main函数，下为对应代码部分，我们将LED和按键对应的引脚都进行了导出。

```c
183 int main(int argc, char **argv) {
184     unsigned int i;
185     unsigned int value1,value2;
186    
187     printf("\t********************************************\n");
188     printf("\t********  SYSFS_GPIO_TEST_DEMO**************\n");
189     printf("\t******** version date: 2020/05    **********\n");
190     printf("\t********************************************\n");    
191 
192     printf("gpio begin to export gpio\r\n");
193     sysfs_gpio_export(GPIO_KEY1);//export gpio key1
194     sysfs_gpio_export(GPIO_KEY2);//export gpio key2
195     sysfs_gpio_export(GPIO_LED);//export gpio led
196     printf("gpio export gpio ok\r\n");
197 
198 
199     return 0;
200 }
```

 在将代码编译之后，我们将代码在板卡上进行运行。代码运行之后的的结果如下图所示，可以看到成功的将GPIO110、GPIO129和GPIO131进行了导出。



![img](https://pic2.zhimg.com/80/v2-be8fb26dc152191d5b05d094e1d3ce85_720w.webp)



#### 7.4.2 设置GPIO方向

 为了实现导出的引脚的方向设置，我们需要对/sys/class/gpio/gpioN/direction写入不同的值。写入“in”则表示设置为输入，写入“out”则表示设置为输出。设置引脚编号的的实现代码如下所示，具体详见《sysfs_gpio_2_export_gpio sysfs_gpio_export.c》的sysfs_gpio_set_dir ()函数。

```c
86 int sysfs_gpio_set_dir(unsigned int gpio, unsigned int out_flag)
87 {
88     int fd, len;
89     char buf[MAX_BUF];
90  // /sys/class/gpio/gpioN/direction
91     len = snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR  "/gpio%d/direction", gpio);
92  
93     fd = open(buf, O_WRONLY);//打开文件
94     if (fd < 0) {
95         perror(buf);
96         return fd;
97     }
98  
99     if (out_flag)//为1，则写入“out"，即设置为输出
100         write(fd, "out", 4);
101     else//为0，则写入“in"，即设置为输入
102         write(fd, "in", 3);
103  
104     close(fd);//关闭文件
105     return 0;
106 }
```

 在实现引脚方向的设置函数之后，我们分别针对按键和LED设置各自不同的方向。将按键设置为输入“IN”,将LED设置为输出“out”，对应的代码如下图所示。相关的代码在程序文件《sysfs_gpio_2_export_gpio/sysfs_gpio_export.c》中main函数，下为对应代码部分。

```c
183 int main(int argc, char **argv) {
184     unsigned int i;
185     unsigned int value1,value2;
186    
187     printf("\t********************************************\n");
188     printf("\t********  SYSFS_GPIO_TEST_DEMO**************\n");
189     printf("\t******** version date: 2020/05    **********\n");
190     printf("\t********************************************\n");    
191         
192     printf("begin to export gpio and direction\r\n");
193     sysfs_gpio_export(GPIO_KEY1);//export gpio key1
194     sysfs_gpio_export(GPIO_KEY2);//export gpio key2
195     sysfs_gpio_export(GPIO_LED);//export gpio led
196 
197     sysfs_gpio_set_dir(GPIO_KEY1, 0);//set as input
198     sysfs_gpio_set_dir(GPIO_KEY2, 0);//set as input
199     sysfs_gpio_set_dir(GPIO_LED, 1);//set as output
200     printf(" export gpio and direction ok\r\n");
201 
202 
203 
204     return 0;
205 }
```

 在将代码编译之后，我们将代码在板卡上进行运行。代码运行之后的的结果如下图所示，我们可以看到按键GPIO110和GPIO129的方向设置成了输入，LED2的GPIO131设置成了输入。



![img](https://pic1.zhimg.com/80/v2-1fea936659cf7679345f766d56cf2824_720w.webp)



#### 7.4.3 GPIO输出实验-LED输出控制

 为了设置引脚的输出电平高低，我们需要对/sys/class/gpio/gpioN/value写入不同的值。写入‘1’则表示输出高电平，写入‘0’则表示输出低电平。设置引脚输出高低电平的的实现代码如下所示，具体详见《sysfs_gpio_3_export_gpio sysfs_gpio_export.c》的sysfs_gpio_set_value ()函数。

```c
119 int sysfs_gpio_set_value(unsigned int gpio, unsigned int value)
120 {
121     int fd, len;
122     char buf[MAX_BUF];
123     // /sys/class/gpio/gpioN/value
124     len = snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR "/gpio%d/value", gpio);
125  
126     fd = open(buf, O_WRONLY);//打开文件
127     if (fd < 0) {
128         perror(buf);
129         return fd;
130     }
131  
132     if (value)//为1，则写入“1"，即设置为输出高电平
133         write(fd, "1", 2);
134     else//为0，则写入“0"，即设置为输出低电平
135         write(fd, "0", 2);
136  
137     close(fd);//关闭文件
138     return 0;
139 }
```

 在实现引脚输出电平的控制函数之后，我们来实现LED的控制。我们通过将“1”或“0”写入value来控制GPIO输出高电平或者低电平，具体相关的代码在程序文件《sysfs_gpio_3_export_gpio/sysfs_gpio_export.c》中main函数，下为对应代码部分。

```c
183 int main(int argc, char **argv) {
184     unsigned int i;
185     unsigned int value1,value2;
186    
187     printf("\t********************************************\n");
188     printf("\t********  SYSFS_GPIO_TEST_DEMO**************\n");
189     printf("\t******** version date: 2020/05    **********\n");
190     printf("\t********************************************\n");    
191         
192     printf("led begin to init\r\n");
193     sysfs_gpio_export(GPIO_LED);//export gpio led
194 
195     sysfs_gpio_set_dir(GPIO_LED, 1);//set as output
196     printf("led init ok\r\n");
197 
198 
199     /* Confirm INIT_B Pin as High */
200     while(1)
201     {
202     
203        
204         sysfs_gpio_set_value(GPIO_LED, 1);//output high 
205         printf("led off\r\n");
206         usleep(500000); //delay 
207         sysfs_gpio_set_value(GPIO_LED, 0);//output low 
208         printf("led on\r\n");
209         usleep(500000);//delay
210     }
211     
212     sysfs_gpio_unexport(GPIO_LED);//unexport gpio led
213 
214     return 0;
215 }
```

 在将代码编译之后，我们将代码在板卡上进行运行。代码运行之后的的结果如下图所示， 可以看到规律性的打印LED控制信息（实物可以看到LED灯闪烁）。



![img](https://pic3.zhimg.com/80/v2-b12ccc09f55d49679a41ecc248091116_720w.webp)



#### 7.4.4 GPIO输入试验-按键值读取

 为了读取引脚输入的电平高低，我们需要读取/sys/class/gpio/gpioN/value的值。读到的是‘1’则表输入为高电平，读到的是‘0’则表示输入为低电平。读取引脚输入电平的、的的实现代码如下所示，具体详见《sysfs_gpio_4_export_gpio sysfs_gpio_export.c》的sysfs_gpio_get_value ()函数。

```c
152 int sysfs_gpio_get_value(unsigned int gpio, unsigned int *value)
153 {
154     int fd, len;
155     char buf[MAX_BUF];
156     char ch;
157     // /sys/class/gpio/gpioN/value
158     len = snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR "/gpio%d/value", gpio);
159  
160     fd = open(buf, O_RDONLY);//打开文件
161     if (fd < 0) {
162         perror("gpio/get-value");
163         return fd;
164     }
165  
166     read(fd, &ch, 1);//读取外部输入电平
167 
168     if (ch != '0') {//为'1'，则设置为1，即输入为高电平
169         *value = 1;
170     } else {//为'0'，则设置为0，即输入为低电平
171         *value = 0;
172     }
173  
174     close(fd);//关闭文件
175     return 0;
176 }
```

 在实现引脚电平读取函数之后，我们来实现外部按键值得读取，我们通过读取value的值来读取按键值，具体相关的代码在程序文件《sysfs_gpio_4_export_gpio/sysfs_gpio_export.c》中main函数，下为对应代码部分。

```c
183 int main(int argc, char **argv) {
184     unsigned int i;
185     unsigned int value1,value2;
186    
187     printf("\t********************************************\n");
188     printf("\t********  SYSFS_GPIO_TEST_DEMO**************\n");
189     printf("\t******** version date: 2020/05    **********\n");
190     printf("\t********************************************\n");    
191         
192     printf("key begin to init\r\n");
193     sysfs_gpio_export(GPIO_KEY1);//export gpio key1
194     sysfs_gpio_export(GPIO_KEY2);//export gpio key2
195     
196     sysfs_gpio_set_dir(GPIO_KEY1, 0);//set as input
197     sysfs_gpio_set_dir(GPIO_KEY2, 0);//set as input
198    
199     printf("key init ok\r\n");
200 
201 
202     /* Confirm INIT_B Pin as High */
203     while(1)
204     {
205     
206         sysfs_gpio_get_value(GPIO_KEY1, &value1);   //read key1 value   
207         //printf("@@key1 value 1is %d \n\r",value1);
208         if(value1==0)//key1 pressed
209         {
210             printf("@@key1 is pressed 0\n\r");          
211         }
212         sysfs_gpio_get_value(GPIO_KEY2, &value2);//read key2 value  
213         //printf("##key2 value 1is %d \n\r",value2);
214         if(value2==0)//key2 pressed
215         {
216             printf("##key2 is pressed 0\n\r");          
217         }
218         usleep(100000);//delay
219                 
220     }
221     
222     sysfs_gpio_unexport(GPIO_KEY1);//unexport gpio key1
223     sysfs_gpio_unexport(GPIO_KEY2);//unexport gpio key2
224    
225 
226     return 0;
227 }
```

 在将代码编译之后，我们将代码在板卡上进行运行。代码运行之后的的结果如下图所示，我们可以看到在按键KEY1和KEY2按下之后打印的值各有不同。



![img](https://pic3.zhimg.com/80/v2-4c4227c55c66fd9722cbc69c97b1bd96_720w.webp)



#### 7.4.5 LED和按键控制实验

 在前几个实验中，我们分别实现了LED和按键各自的控制。在这个实验中，我们将前几个实验进行整合，控制LED得闪烁，并读取按键得值。当按键按下时，打印相关信息。具体相关的代码在程序文件《sysfs_gpio_5_export_gpio/sysfs_gpio_export.c》中main函数，下为对应代码部分

```c
183 int main(int argc, char **argv) {
184     unsigned int i;
185     unsigned int value1,value2;
186    
187     printf("\t********************************************\n");
188     printf("\t********  SYSFS_GPIO_TEST_DEMO**************\n");
189     printf("\t******** version date: 2020/05    **********\n");
190     printf("\t********************************************\n");    
191         
192     printf("led&key begin to init\r\n");
193     sysfs_gpio_export(GPIO_KEY1);//export gpio key1
194     sysfs_gpio_export(GPIO_KEY2);//export gpio key2
195     sysfs_gpio_export(GPIO_LED);//export gpio led
196     sysfs_gpio_set_dir(GPIO_KEY1, 0);//set as input
197     sysfs_gpio_set_dir(GPIO_KEY2, 0);//set as input
198     sysfs_gpio_set_dir(GPIO_LED, 1);//set as output
199     printf("led&key init ok\r\n");
200 
201 
202     /* Confirm INIT_B Pin as High */
203     while(1)
204     {
205     
206         sysfs_gpio_get_value(GPIO_KEY1, &value1);   //read key1 value       
207         //printf("@@key1 value 1is %d \n\r",value1);
208         if(value1==0)//key1 pressed
209         {
210             printf("@@key1 is pressed 0\n\r");          
211         }
212         sysfs_gpio_get_value(GPIO_KEY2, &value2);//read key2 value  
213         //printf("##key2 value 1is %d \n\r",value2);
214         if(value2==0)//key2 pressed
215         {
216             printf("##key2 is pressed 0\n\r");          
217         }
218         //led flash 
219         sysfs_gpio_set_value(GPIO_LED, 1);
220         printf("LED OFF\n\r");      
221         usleep(500000);
222         sysfs_gpio_set_value(GPIO_LED, 0);
223         printf("LED ON\n\r");       
224         usleep(500000);
225     }
226     
227     sysfs_gpio_unexport(GPIO_KEY1);//unexport gpio key1
228     sysfs_gpio_unexport(GPIO_KEY2);//unexport gpio key2
229     sysfs_gpio_unexport(GPIO_LED);//unexport gpio led
230 
231     return 0;
232 }
```

 在将代码编译之后，我们将代码在板卡上进行运行。代码运行之后的的结果如下图所示，可以看到LED闪烁，按键KEY1和KEY2按下之后打印的值各有不同（因为LED的闪烁导致按键需要经过一次LED闪烁之后才能读取，因此按键必须一直按着才能读取到值的变化）。



![img](https://pic4.zhimg.com/80/v2-0cf2fb621ea7845a510c39b989a8c3bb_720w.webp)



## 8 RTC

### 8.1 RTC的作用及时间表示

 “RTC”的英文全称是Real-Time Clock，翻译过来是实时时钟芯片。实时时钟芯片是日常生活中应用最为广泛的电子器件之一，它为人们或者电子系统提供精确的实时时间。实时时钟芯片通过引脚对外提供时间读写接口，通常内部带有电池，保证在外部系统关电时，内部电路正常工作，时间正常运行。不同的时钟芯片内部机制不一样，时间数据存储格式、读写操作方式也不一样，Linux系统和驱动封装了不同时钟芯片的操作细节，为应用程序提供了统一的时间操作接口。

 那么在Linux世界里，时间是怎么表示的呢？是不是与人们一样用年月日+时分秒来表示时间呢？聪明的程序员自然不会让计算机这么做，正所谓越简单越科学，直接用一个整数表示时间，这个整数代表当前与Epoch Time的时间差(以秒为单位)。Epoch Time 是指一个特定的时间：1970年1月1日0时0分0秒。假设现在距离1970年1月1日0时0分0秒走了N秒，在Linuxx系统里，时间数值就是N。

 那么问题来了，为什么要从1970年1月1日0时0分0秒开始呢?那年发生了什么，以至于Unix系统以它作“纪元”。原来Unix就是在那个时代产生的，1969年发布的雏形，最早是基于硬件60Hz的时间计数。1971年底出版的《Unix Programmer's Manual》里定义的Unix Time是以1971年1月1日00:00:00作为起始时间，每秒增长60。后来考虑到如果每秒60个数字，则1.1年后时间值就到达最大，于是改成以秒为计数单位，时间能表示到68.1年之长，就不在乎起始时间是1970还是1971年，遂改成人工记忆、计算比较方便的1970年。于是Unix的世界开启了“纪元”，Unix时间戳也就成为了一个专有名称。后Linux系统沿用了这种定义时间的方式。

 当时计算机操作系统是32位，时间也是用一个32位的有符号数来表示，数据取值范围为-2147483648~2147483647，也就是说时间最大值只能取到2147483647（秒），换算成年也即2147483647÷365÷24÷60÷60=68.1年，也就是说32位能表示的最长时间是1970+68.1=2038年。精确点讲，2038年01月19日03时14分07秒，时间便会达到最大值，为0x7FFFFFFF。过了这个时间点，下一秒时间值便会变为0x80000000，算下来也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多系统便会运行异常。

 上边说过了，那是Unix系统“元年”时候的事情，32位的时间已经足以解决当时的问题了。现在主流CPU都是64位的，使用64位的数据表示时间也是顺其自然的事，用64位的有符号数来表示时间，可以表示到292，277，026，596年12月4日15时30分08秒，相信我们再也不用愁时间回归的问题了。

### 8.2 RTC的操作命令

 弄清楚了时间怎么表示之后，Linux是怎么使用和维护时间的呢？我们怎么通过Linux操作时间呢？

#### 8.2.1 系统时间和硬件时间

 在Linux中有系统时钟与硬件时钟两种时钟。系统时间是由CPU主芯片的定时器进行维护的时间，一般情况下都会选择芯片上精度最高的定时器作为系统时间的定时基准，以避免在系统运行较长时间后出现大的时间偏移。特点是系统掉电后，系统时间将丢失。硬件时钟是指系统中包含的RTC芯片内部所维护的时间。RTC芯片都有电池+系统电源的双重供电机制，在系统正常工作时由系统供电，在系统掉电后由电池进行供电。因此系统电源掉电后RTC时间仍然能够正常运行，Linux系统中硬件时钟的基本目的是在Linux不运行时保持时间。

 在Linux启动时，将系统时间从硬件时钟初始化，然后不再使用硬件时钟。在系统开机时，由Linux操作系统从RTC芯片读取硬件时间后，由CPU内部定时器维护时间运行。此后操作系统使用的时间都是系统时间，如果没有显式的通过命令去控制RTC的读写操作，系统将不会再从RTC中去获取或者同步设置时间。

#### 8.2.2 系统时间操作命令

 查看系统时间：

```c
date
Sat May  1 08:11:19 EDT 2020
```

 格式化输出：

```c
date +"%Y-%m-%d" 
2020-05-01
```

 2秒后输出：

```c
date -d "2 second" +"%Y-%m-%d %H:%M.%S"
2020-05-01 14:21.31
```

 显示1234567890秒的时间：

```c
date -d "1970-01-01 1234567890 seconds" +"%Y-%m-%d %H:%m:%S"
2009-02-13 23:02:30
```

 普通转格式：

```c
date -d "2009-05-01" +"%Y/%m/%d %H:%M.%S"
2020/05/01 00:00.00
```

 输出其他日期：

```c
date -d "+1 day" +%Y%m%d   #显示后一天的日期 
date -d "-1 day" +%Y%m%d   #显示前一天的日期 
date -d "-1 month" +%Y%m%d #显示上一月的日期 
date -d "+1 month" +%Y%m%d #显示下一月的日期 
date -d "-1 year" +%Y%m%d  #显示前一年的日期 
date -d "+1 year" +%Y%m%d  #显示下一年的日期
```

 设置系统时间：

```c
date -s 20200501 #设置成20200501，这样会把具体时间设置成空00:00:00 
date -s 01:01:01 #设置具体时间，不会对日期做更改 
date -s "01:01:01 2020-05-01" #这样可以设置全部时间 
date -s "01:01:01 20200501"    #这样可以设置全部时间 
date -s "2020-05-01 01:01:01" #这样可以设置全部时间 
date -s "20200501 01:01:01"    #这样可以设置全部时间
```

 命令更多参数使用方法可访问：[https://www.cnblogs.com/machangwei-8/p/10352546.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/machangwei-8/p/10352546.html)

#### 8.2.3 硬件时间操作命令

 显示硬件时间：

```c
hwclock或 hwclock -r 或 hwclock --show
2000年04月11日 星期二 13时24分35秒  -0.109687 seconds
```

 设置硬件时钟：

```c
hwclock --set --date '2015-04-11 13:36:11'11
```

 将系统时钟同步到硬件时钟：

```c
hwclock -w
```

 将硬件时钟同步到系统时钟：

```c
hwclock -s
```

 命令更多参数使用方法可访问：[https://www.cnblogs.com/wj78080458/p/9806774.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/wj78080458/p/9806774.html)

### 8.3 RTC的数据结构和函数

 在Linux环境中，我们学会了使用命令，修改系统时间和硬件时间。在编程时我们当然可以直接使用system系统调用来操作时间，但是这样既显得不够专业，也不能满足大部分需求，因为很多情况下我们不只是要修改时间，而是要对时间进行运算处理。

 RTC编程，重点是学习时间相关的结构体和相关操作函数。

#### 8.3.1 时间相关的数据结构

 在C语言涉及中经常需要定时触发事件，涉及到获取系统时间，其结构体类型有多种。Linux系统下,与时间有关的数据类型定义在头文件 /usr/include/sys/time.h 中：

只要有以下几种时间相关的数据类型：

##### 1.time_t 类型：长整型

 一般用来表示从Epoch Time（1970年1月1日午夜(00:00:00)）以来的秒数，单位为秒。

```c
#define _TIME_T 
    typedef    long    time_t;        
#endif
```

 由函数time_t time(time_t* lpt)来获取time_t 数据，函数返回自Epoch Time（1970年1月1日午夜(00:00:00)）起经过的时间，以秒为单位。如果 lpt不为空，则返回值也存储在lpt指向的变量中。

 示例：

```text
time_t t = time(NULL);
```

##### 2.struct timeb 结构

 它有四个成员，一个是秒，另一个是毫秒。

```c
struct timeb{    
    time_t  time;
    unsigned short millitm;     
    short   timezone;          
    short   dstflag;                
};
```

 time是从Epoch Time（1970年1月1日午夜(00:00:00)）起累计的秒数。

 millitm是一秒内的毫秒数。

 dstflag不为0，说明这是夏令时时间。

 timezone是UTC时间和本地时间的相差分钟数。

 由函数int ftime(struct timeb *tp) 来获取timeb，调用成功返回0，调用失败返回-1。

示例：

```c
struct timeb tp;
ftime(&tp);
```

##### 3.struct timeval 和struct timezone结构

 timeval 有两个成员，一个是秒，另一个表示微秒。

```c
struct  timeval{
    long  tv_sec；    /*秒*/
    long  tv_usec；/*微秒*/
};
```

 tv_sec为Epoch Time到创建struct timeval时的秒数，tv_usec为微秒数，即秒后面的零头。比如当tv_sec为1234567890，tv_usec为1234，即当前时间距Epoch时间1234567890秒，1234微秒。

```c
struct  timezone{   
    int tz_minuteswest;/*和greenwich 时间差了多少分钟*/  
    int tz_dsttime;    /*type of DST correction*/
};
tz_minuteswest表示当前系统所在时区和UTC的时间差，tz_minuteswest以分钟计算。比如北京GMT+8区，tz_minuteswest为-480。tz_dsttime的定义为日光节约时间（DST，也就是夏令时。
```

 由函数int gettimeofday(struct timeval*tv,struct timezone* tz )来获取timeval和timezone，在gettimeofday()函数中tv或者tz都可以为空。如果为空则就不返回其对应的结构体。函数执行成功后返回0，失败后返回-1，错误代码存于errno中。

示例：

```c
struct  timeval  tv;
gettimeofday(&tv, NULL);
```

##### 4.struct tm 结构

```c
struct tm {
　　int tm_sec; /* 秒–取值区间为[0,59] */
　　int tm_min; /* 分 - 取值区间为[0,59] */
　　int tm_hour; /* 时 - 取值区间为[0,23] */
　　int tm_mday; /* 一个月中的日期 - 取值区间为[1,31] */
　　int tm_mon; /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */
　　int tm_year; /* 年份，其值从1900开始 */
　　int tm_wday; /* 星期–取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */
　　int tm_yday; /* 从每年的1月1日开始的天数–取值区间为[0,365]，其中0代表1月1日，1代表1月2               日，以此类推 */
　　int tm_isdst; /* 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；             不了解情况时，tm_isdst()为负。*/
};
    int   tm_sec 代表目前秒数，正常范围为0-59   
    int   tm_min 代表目前分数，范围0-59  
    int   tm_hour 从午夜算起的时数，范围为0-23      
    int   tm_mday 目前月份的日数，范围01-31 
    int   tm_mon 代表目前月份，从一月算起，范围从0-11
    int   tm_year 从1900 年算起至今的年数
    int   tm_wday 一星期的日数，从星期一算起，范围为0-6
    int   tm_yday 从今年1月1日算起至今的天数，范围为0-365
    int   tm_isdst 日光节约时间的旗标
```

 由函数struct tm *gmtime(const time_t*timep)解析得到tm，gmtime()将参数timep 所指的time_t 数据类型中的信息转换成真实世界所使用的时间日期表示方法，然后将结果由结构tm的指针返回。  示例：

```c
struct tm* tm =NULL ; 
time_t t = time(NULL);
tm = gmtime(&t);
```

#### 8.3.2时间相关的函数

##### 1.时间格式化函数

 strftime()函数原型：size_t strftime(char *str,size_t max,char* fmt,struct tm *tp);函数识别以百分号(%)开始的格式命令集合，其格式由fmt来指定,可以使用strftime 函数将时间格式转化为我们想要的格式（其输出结果为字符串），strftime有点像sprintf。

 str 表示返回的时间字符串

 count要写入的字节的最大数量

 format 格式字符串由零个或多个转换符和普通字符(除%)

 tm 输入时间

 格式命令，是区分大小写的：

```c
%a 星期几的简写
%A 星期几的全称
%b 月分的简写
%B 月份的全称
%c 标准的日期的时间串
%C 年份的后两位数字
%d 十进制表示的每月的第几天
%D 月/天/年
%e 在两字符域中，十进制表示的每月的第几天
%F 年-月-日
%g 年份的后两位数字，使用基于周的年
%G 年分，使用基于周的年
%h 简写的月份名
%H 24小时制的小时
%I 12小时制的小时
%j 十进制表示的每年的第几天
%m 十进制表示的月份
%M 十时制表示的分钟数
%n 新行符
%p 本地的AM或PM的等价显示
%r 12小时的时间
%R 显示小时和分钟：hh:mm
%S 十进制的秒数
%t 水平制表符
%T 显示时分秒：hh:mm:ss
%u 每周的第几天，星期一为第一天 （值从0到6，星期一为0）
%U 第年的第几周，把星期日做为第一天（值从0到53）
%V 每年的第几周，使用基于周的年
%w 十进制表示的星期几（值从0到6，星期天为0）
%W 每年的第几周，把星期一做为第一天（值从0到53）
%x 标准的日期串
%X 标准的时间串
%y 不带世纪的十进制年份（值从0到99）
%Y 带世纪部分的十进制年份
%z，%Z 时区名称，如果不能得到时区名称则返回空字符。
%% 百分号
```

 示例：

```c
time_t t = time(NULL);
struct tm *info;
info = gmtime(&t);
strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", info);
printf("格式化的日期 & 时间 : |%s|\n", buffer );
```

##### 2.localtime函数

 localtime（）函数原型：struct tm *localtime(const time_t* timer) 使用 timer 的值来填充 tm 结构，timer 的值被解析为 tm 结构，并用本地时区表示

 示例：

```c
time_t rawtime;
struct tm *info; 
time( &rawtime ); 
info = localtime( &rawtime );
```

##### 3.mktime函数

 mktime()函数原型： time_t mktime(struct tm *timeptr) 把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。函数将参数timeptr所指的tm结构数据转换成从公元1970年1月1日0时0分0 秒算起至今的UTC时间所经过的秒数。该函数返回一个 time_t 值，该值对应于以参数传递的日历时间。如果发生错误，则返回 -1 值。

 示例：

```c
time_t rawtime;
struct tm * timeinfo;
int year, month ,day;
/* 获取当前时间信息，并修改用户输入的输入信息 */
time ( &rawtime );
timeinfo = localtime ( &rawtime );
timeinfo->tm_year-= 1;//去年的今天
rawtime = mktime ( timeinfo );
```

##### 4.asctime函数

 asctime()函数原型： char *asctime(const struct tm* timeptr) ；函数返回一个指向字符串的指针，它代表了结构 struct timeptr 的日期和时间。包含了可读格式的日期和时间信息 Www Mmm dd hh:mm:ss yyyy，其中，Www 表示星期几，Mmm 是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。

 示例：

```c
struct tm t;
t.tm_sec    = 10;
t.tm_min    = 10;
t.tm_hour   = 6;
t.tm_mday   = 25;
t.tm_mon    = 2;
t.tm_year   = 89;
t.tm_wday   = 6;
puts(asctime(&t));
```

##### 5.ctime函数

 ctime()函数原型：char *ctime(const time_t* timer); 可以把time函数得到的结果转换成一个时间字符串， 返回一个表示当地时间的字符串，当地时间是基于参数 timer。返回的字符串格式如下： Www Mmm dd hh:mm:ss yyyy 其中，Www 表示星期几，Mmm 是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。调用ctime(t)等价于asctime(localtime(t))。

 示例：

```c
time_t curtime; 
time(&curtime); 
printf("当前时间 = %s", ctime(&curtime));
```

### 8.4 RTC时间的编程实例

 嵌入式Linux环境下，RTC时间编程与桌面Linux环境下的编程是一样的。本文在桌面Linux下编程，实现时间显示、计算等功能。编译后的程序名为“mytime”，进入程序后，使用不同命令完成不同功能，主要命令见下表：

| 序号 | 命令 | 功能 | 示例 | | ---- | ---- | ---------------------------------- | ------ | | 1 | p | 在终端显示当前时间 | p | | 2 | y | 在终端显示昨天日期 | y | | 3 | n | 在终端显示现在距新年的天数 | n | | 4 | a | 根据输入的出生年代，在终端显示年纪 | a 2001 | | 5 | e | 退出程序 | e |

 在main函数中，首先打印函数的使用手册，然后循环接收用户输入的命令，根据命令调用相应的函数：

```c
32      //打印使用手册
33      printf( "\n\n"\
34            "Usage:\np\n"\
35            "y\n"\
36             "n\n"\
37             "a 2001\n"\
38             "e\n"\
39             "p:在终端显示当前时间\ny:查看昨天日期\nn:查看现在距新年的天数\n"\
40             "a:根据输入的出生年计算出年纪\ne:退出程序\n"\
41      );
42
43     //主程序中循环接收输入的命令，根据不同命令执行不同函数
44      while (1){
45              if (c !='\n')
46                printf("\n请输入命令：");
47              scanf("%c",&c);
48              switch(c){
49                      case 'p'://在终端显示当前时间
50                              displaydate();
51                              break;
52                      case 'y'://显示昨天日期
53                              displayyesterday();
54                              break;
55                      case 'n'://显示现在距新年的天数
56                              displaynewyear();
57                              break;
58                      case 'a'://根据输入的出生年计算出年纪
59                              scanf("%d",&age);
60                              displayage(age);
61                              break;
62                      case 'e'://退出程序
63                              exit(0);
64                              break;
65
66                      default : /* 可选的 */
67                              break;
68          }
69      }
```

 实现在终端显示当前时间的函数：

```c
/**********************************************************
72  * 函数名称： displaydate
73  * 功能描述： 在终端打印当前时间信息
74  * 输入参数： 无
75  * 输出参数： 无
76  * 返 回 值： 无
77  * 2020/05/10         V1.0    yanxni            创建
78 ***********************************************************/
79 void displaydate(){
80      struct tm *ptr;
81      time_t lt;
82
83     /*获取日历时间*/
84     lt = time(NULL);
85
86     /*转化为本地时间*/
87     ptr = localtime(&lt);
88
89     /*以本地时间的字符串方式打印*/
90     printf("%s\n",ctime(&lt));
91
92      /*以本地时间的字符串方式打印*/
93     printf("%s\n",asctime(ptr));
94
95 }
```

 实现在终端显示昨天日期的函数：

```c
/**********************************************************
97  * 函数名称： displayyesterday
98  * 功能描述： 在终端打印昨天的日期
99  * 输入参数： 无
100  * 输出参数： 无
101  * 返 回 值： 无
102  * 2020/05/10         V1.0    yanxni            创建
103 ***********************************************************/
104 void displayyesterday(void){
105     struct tm *ptr;
106     time_t lt;
107
108     /*获取日历时间*/
109     lt = time(NULL);
110     lt -= 24*60*60;
111
112     /*转化为本地时间*/
113     ptr = localtime(&lt);
114
115     /*以本地时间的字符串方式打印*/
116     printf("昨天是%d年%d月%d日\n",ptr->tm_year + 1900,ptr->tm_mon + 1,ptr->tm_mday);
117 }
```

 实现在终端显示现在距新年的天数的函数：

```c
118 /**********************************************************
119  * 函数名称： displaynewyear
120  * 功能描述： 在终端打印距离新年的天数
121  * 输入参数： 无
122  * 输出参数： 无
123  * 返 回 值： 无
124  * 2020/05/10         V1.0    yanxni            创建
125 ***********************************************************/
126 void displaynewyear(void){
127     struct tm *ptr;
128     time_t lt,lt2;
129     int date;
130
131     /*获取日历时间*/
132     lt = time(NULL);
133
134     /*转化为本地时间*/
135     ptr = localtime(&lt);
136     /*构造新年的本地时间*/
137     ptr->tm_year += 1;
138     ptr->tm_mon = 0;
139     ptr->tm_mday =1;
140     ptr->tm_hour =0;
141     ptr->tm_min =0;
142     ptr->tm_sec =0;
143
144     lt2 = mktime(ptr);
145     date = (lt2-lt)/(24*60*60);
146
147     printf("距离新年还有%d天\n",date);
148 }
```

 实现在根据输入的出生年代在终端显示年纪的函数：

```c
/**********************************************************
151  * 函数名称： displayage
152  * 功能描述： 在终端打印年纪
153  * 输入参数： 出生年代
154  * 输出参数： 无
155  * 返 回 值： 无
156  * 2020/05/10         V1.0    yanxni            创建
157 ***********************************************************/
158 void displayage(int year){
159     struct tm *ptr;
160     time_t lt;
161
162     /*获取日历时间*/
163     lt = time(NULL);
164
165     /*转化为本地时间*/
166     ptr = localtime(&lt);
167
168     printf("你的年龄是：%d岁\n",ptr->tm_year +1900 - year  );
```

## 9 PWM编程

### 9.1 PWM概述

 PWM，英文名Pulse Width Modulation，是脉冲宽度调制缩写，它是通过对一系列脉冲的宽度进行调制，等效出所需要的波形（包含形状以及幅值），对模拟信号电平进行数字编码，也就是说通过调节占空比的变化来调节信号、能量等的变化，占空比就是指在一个周期内，信号处于高电平的时间占据整个信号周期的百分比，例如方波的占空比就是50%。是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。



![img](https://pic1.zhimg.com/80/v2-0db6cf5d27897312b8597e737e2bd2f0_720w.webp)



 PWM信号把模拟信号转化为数字电路所需要的编码，现在基本是采用数字电路，因此在很多场合都采用PWM信号，我们经常见到的就是交流调光电路，也可以说是无级调速，高电平占多一点，也就是占空比大一点亮度就亮一点，占空比小一点亮度就没有那么亮，前提是PWM的频率要大于我们人眼识别频率，要不然会出现闪烁现象。除了在调光电路应用，还有在直流斩波电路、蜂鸣器驱动、电机驱动、逆变电路、加湿机雾化量等都会有应用。



![img](https://pic4.zhimg.com/80/v2-a8dc247218968bf875d1d3f37ff17e73_720w.webp)



#### 9.1.1 PWM的参数说明

[https://www.kernel.org/doc/Documentation/pwm.txt](https://link.zhihu.com/?target=https%3A//www.kernel.org/doc/Documentation/pwm.txt) **period** PWM信号的总周期（读/写）。 值以纳秒为单位，是活动和非活动的总和 PWM的时间。

**duty_cycle（占空比）** PWM信号的有效时间（读/写）。 值以纳秒为单位，且必须小于周期。 在NORMAL模式下，表示一个周期内高电平持续的时间 在INVERTED模式下，表示一个周期中低电平持续的时间

**polarity** 改变PWM信号的极性（读/写）。 写入此属性仅在PWM芯片支持更改时才有效 极性。只有PWM不能改变极性 启用。值是字符串“normal”或“inversed”。

**enable** 启用/禁用PWM信号（读/写）。

- 0 - 禁用
- 1 - 启用

### 9.2 用户层查看PWM

 如果在内核配置中启用了CONFIG_SYSFS，则会提供一个简单的sysfs接口来使用用户空间的PWM。它在/ sys / class / pwm /中公开。每个被探测的PWM控制器/芯片将被输出为pwmchipN，其中N是PWM芯片的基础。你在目录里面会发现：

```c
1 echo 0 > /sys/class/pwm/pwmchip0/export /*设置PWM4输出，调出pwm0目录下设备节点，用于以下配置 */
2 echo 1000000 >/sys/class/pwm/pwmchip0/pwm0/period /*设置PWM4一个周期的持续时间，单位为ns，即1K Hz */
3 echo 500000 >/sys/class/pwm/pwmchip0/pwm0/duty_cycle /*设置一个周期中的”ON”时间，单位为ns，即占空比=duty_cycle/period=50% */
4 echo 1 >/sys/class/pwm/pwmchip0/pwm0/enable /*设置PWM4使能 */
```

### 9.3 PWM的SYSFS使用

```c
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <linux/ioctl.h>

#define dbmsg(fmt, args ...) printf("%s[%d]: "fmt"\n", __FUNCTION__, __LINE__,##args)

#define DUTY              "duty"
#define PERIOD            "1000000"
#define DUTYCYCLE         "500000"
#define LENGTH            100

int fd_period = 0,fd_duty = 0,fd_enable = 0,duty_m = 0;

int usage()
{
    printf("usage:\n");
    printf("./pwm-sysfs-test duty <0/1> : 0-->static; 1-->dynamic \n");   
    return 0;
}

int pwm_setup()
{
  int fd,ret;

  fd = open("/sys/class/pwm/pwmchip0/export", O_WRONLY);
  if(fd < 0)
  {
      dbmsg("open export error\n");
      return -1;
  }
  ret = write(fd, "0", strlen("0"));
  if(ret < 0)
  {
      dbmsg("creat pwm0 error\n");
      return -1;
  }else
  dbmsg("export pwm0 ok\n");

  fd_period = open("/sys/class/pwm/pwmchip0/pwm0/period", O_RDWR);
  fd_duty = open("/sys/class/pwm/pwmchip0/pwm0/duty_cycle", O_RDWR);
  fd_enable = open("/sys/class/pwm/pwmchip0/pwm0/enable", O_RDWR);

  if((fd_period < 0)||(fd_duty < 0)||(fd_enable < 0))
  {
      dbmsg("open error\n");
      return -1;
  }

  ret = write(fd_period, PERIOD,strlen(PERIOD));
  if(ret < 0)
  {
      dbmsg("change period error\n");
      return -1;
  }else
    dbmsg("change period ok\n");

  ret = write(fd_duty, DUTYCYCLE, strlen(DUTYCYCLE));
  if(ret < 0)
  {
      dbmsg("change duty_cycle error\n");
      return -1;
  }else
    dbmsg("change duty_cycle ok\n");

  ret = write(fd_enable, "1", strlen("1"));
  if(ret < 0)
  {
      dbmsg("enable pwm0 error\n");
      return -1;
  }else
  dbmsg("enable pwm0 ok\n");

  duty_m = atoi(DUTYCYCLE)/2;
  printf("duty_m: %d \n",duty_m);

  return 0;
}

int main ( int argc, char *argv[] )
{
  int ret;
  int num;
  if(argc < 2)
  {
    usage();
    return -1;
  }

  if(strncmp(argv[1],DUTY, sizeof(DUTY)) == 0)
  {
    dbmsg("%s", DUTY);
    if(argc != 3)
    {
      usage();
      return -1;
    }
    pwm_setup();
  }

  return 0;
}
```

### 9.4 PWM应用编程

The main useful user API are the following: devm_pwm_get() or pwm_get() / pwm_put(): this API is used to look up, request, then free a PWM device. pwm_init_state(),pwm_get_state(), pwm_apply_state(): this API is used to initialize, retrieve and apply the current PWM device state. pwm_config(): this API updates the PWM device configuration (period and duty cycle).

#### 9.4.1 修改设备树

```c
beeper {
compatible = "pwm-beeper";
pwms = <&pwm 0 1000000 0>;
pinctrl-names = "default";
pinctrl-0 = <&pwm0_pin>;
};
```

#### 9.4.2 修改配置文件

```c
Activate PWM framework in the kernel configuration through the Linux menuconfig tool, Menuconfig or how to configure kernel (CONFIG_PWM=y):
Device Drivers  --->
   [*] Pulse-Width Modulation (PWM) Support  --->
```

#### 9.4.3 添加驱动

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/miscdevice.h>
#include <linux/fs.h>
#include <asm/gpio.h>
#include <linux/pwm.h>

//#include <plat/gpio-cfg.h>

#define PWM_ON  0x100001
#define PWM_OFF 0x100002

struct pwm_device *pwm_dev_2;
struct pwm_device *pwm_dev_3;

static long pwm_ioctl(struct file *file,
                        unsigned int cmd,
                        unsigned long arg)
{
    int ret;
    switch(cmd) {
        case PWM_ON:
                ret = pwm_config(pwm_dev_2,200000,500000);
                if(ret < 0){
                    printk("pwm_dev_2 ioctl fail");
                    return 0;
                }
                ret = pwm_config(pwm_dev_3,300000,500000);
                if(ret < 0){
                    printk("pwm_dev_3 ioctl fail");
                }
                pwm_enable(pwm_dev_2);
                pwm_enable(pwm_dev_3);
            break;
        case PWM_OFF:
                ret = pwm_config(pwm_dev_2,0,500000);
                if(ret < 0){
                    printk("pwm_dev_2 ioctl fail");
                    return 0;
                }
                ret = pwm_config(pwm_dev_3,0,500000);
                if(ret < 0){
                    printk("pwm_dev_3 ioctl fail");
                }
                pwm_disable(pwm_dev_2);
                pwm_disable(pwm_dev_3);
            break;
    }
    return 0;
}

//定义初始化硬件操作方法
static struct file_operations pwm_fops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = pwm_ioctl
};

//定义初始化混杂设备对象
static struct miscdevice pwm_misc = {
    .minor = MISC_DYNAMIC_MINOR, //动态分配次设备号
    .name = "mypwm",             //dev/mypwm
    .fops = &pwm_fops 
};

static int pwm_init(void)
{
    int ret;
    printk("regisger pwm_misc device\n");
    //1.申请pwm资源，设置输出为0
    pwm_dev_2 = pwm_request(1,"pwm_2");
    if(pwm_dev_2 == NULL){
        printk("pwm_dev_2 register fail\n");
    }
    pwm_dev_3 = pwm_request(2,"pwm_3");
    if(pwm_dev_3 == NULL){
        printk("pwn_dev_3 register fail\n");
    }

    ret = pwm_config(pwm_dev_2,0,500000);
    if(ret < 0){
        printk("pwm_config_2 init fail\n");
        return 0;
    }
    ret = pwm_config(pwm_dev_3,0,500000);
    if(ret < 0){
        printk("pwm_config_3 init fail\n");
        return 0;
    }

    ret = pwm_enable(pwm_dev_2);
    if(ret == 0){
        printk("pwm_enable_dev_2 init success\n");
    }
    if(ret < 0 ){
        printk("pwm_enable_dev_2 init fail\n");
        return 0;
    }
    ret = pwm_enable(pwm_dev_3);
    if(ret == 0){
        printk("pwm_enable_dev_3 init success\n");
    }
    if(ret < 0 ){
        printk("pwm_enable_dev_3 init fail\n");
        return 0;
    }
    //2.注册混杂设备
    misc_register(&pwm_misc);
    return 0;
}

static void pwm_exit(void)
{
    printk("unregister pwm_misc device\n");
    //1.卸载混杂设备
    misc_deregister(&pwm_misc);
    //2.释放pwm资源
    pwm_config(pwm_dev_2,0,500000);
    pwm_disable(pwm_dev_2);
    pwm_free(pwm_dev_2);

    pwm_config(pwm_dev_3,0,500000);
    pwm_disable(pwm_dev_3);
    pwm_free(pwm_dev_3);
}
module_init(pwm_init);
module_exit(pwm_exit);
MODULE_LICENSE("GPL");
```

#### 9.4.4 运行测试

```c
#include <stdio.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 

#define PWM_ON  0x100001 
#define PWM_OFF 0x100002 

int main(void) 
{
    int fd; 
    int a; 

    fd = open("/dev/mypwm", O_RDWR); 
    if (fd < 0) 
        return -1; 

    while(1) { 
            ioctl(fd, PWM_ON); 
    } 
    close(fd); 
    return 0; 
}
```



## 10 I2C编程

### 10.1 I2C协议

#### **10.1.1** **概述**

 I2C是一种串行通信总线，使用多主从架构，最初设计目的为了让主板、嵌入式系统或手机用来连接低速周边设备。多用于小数据量的场合，有传输距离短，任意时刻只能有一个主机等特性。严格意义上讲，I2C应该是软硬件结合体，所以我们将分物理层和协议层来介绍该总线。

 I2C总线结构如下图：



![img](https://pic2.zhimg.com/80/v2-44fbfc0a6f3f3707785642ca7621b501_720w.webp)



 传输数据时，我们需要发数据，从主设备发送到从设备上去；也需要把数据从从设备传送到主设备上去，数据涉及到双向传输。

 对于I2C通信的过程，下面使用一个形象的生活例子进行类比。



![img](https://pic4.zhimg.com/80/v2-e4b45e2a6b74020d5358f6ec48145dff_720w.webp)



 体育老师：可以把球发给学生，也可以把球从学生中接过来。

① 发球：

- a. 老师说：注意了(start)；
- b. 老师对A学生说，我要球发给你(A就是地址)；
- c. 老师就把球发出去了（传输）；
- d. A收到球之后，应该告诉老师一声（回应）；
- e. 老师说下课（停止）。

② 接球：

- a. 老师说注意了(start)；
- b. 老师说：B把球发给我(B是地址)；
- c. B就把球发给老师（传输）；
- d. 老师收到球之后，给B说一声，表示收到球了（回应）；
- e. 老师说下课（停止）。

我们就使用这个简单的例子，来解释一下I2C的传输协议：

① 老师说注意了，表示开始信号(start)

② 老师告诉某个学生，表示发送地址(address)

③ 老师发球/接球，表示数据的传输

④ 老师/学生收到球，回应表示：回应信号(ACK)

⑤ 老师说下课，表示I2C传输接受(P)

#### **10.2.2** 物理层**

##### 1) 特性1：半双工（非全双工）

 I2C总线中只使用两条线路：SDA、SCL。

**① SDA(串行数据线):**

 主芯片通过一根SDA线既可以把数据发给从设备，也可以从SDA上读取数据。在I2C设备内部有两个引脚（发送引脚/接受引脚），它们都连接到外部的SDA线上，具体可以参考下图device端里面的I2Cn_SDA(output/input)。

**② SCL(串行时钟线)：**

 I2C主设备发出时钟，从设备接收时钟。

 SDA和SCL引脚的内部电路结构一致，引脚的输出驱动与输入缓冲连在一起。其中输出为漏极开路的场效应管、输入缓冲为一只高输入阻抗的同相器。这样结构有如下特性：

a. 由于 SDA、SCL 为漏极开路结构，借助于外部的上拉电阻实现了信号的“线与”逻辑；

b. 引脚在输出信号的同时还作用输入信号供内部进行检测，当输出与输入不一致时，就表示有问题发生了。这为 “时钟同步”和“总线仲裁”提供硬件基础。

 SDA和CLK连接线上连有两个上拉电阻，当总线空闲时，两根线均为高电平。连到总线上的任一器件输出的低电平，都将使总线的信号变低。

 物理层连接如下图所示：



![img](https://pic2.zhimg.com/80/v2-42b486165f81d59643874184c8f3a8b5_720w.webp)



##### **2) 特性2：地址和角色可配置**

 每个连接到总线的器件都可以通过唯一的地址和其它器件通信，主机/从机角色和地址可配置，主机可以作为主机发送器和主机接收器。

##### **3) 特性3：多主机**

 I2C是真正的多主机总线，I2C设备可以在通讯过程转变成主机。如果两个或更多的主机同时请求总线，可以通过冲突检测和仲裁防止总线数据被破坏。

##### 4) 特性4：传输速率

 传输速率在标准模式下可以达到100kb/s，快速模式下可以达到400kb/s。

##### 5) 特性5：负载和距离

 节点的最大数量受限于地址空间以及总线电容决定，另外总电容也限制了实际通信距离只有几米。

#### **10.2.3** 协议层

##### 1) 数据有效性

 I2C协议的数据有效性是靠时钟来保证的，在时钟的高电平周期内，SDA线上的数据必须保持稳定。数据线仅可以在时钟SCL为低电平时改变。



![img](https://pic1.zhimg.com/80/v2-5c122f8e01a6ffc06b69eb4c009b0000_720w.webp)



##### 2) 起始和结束条件

**起始条件：**当SCL为高电平的时候，SDA线上由高到低的跳变被定义为起始条件。

**结束条件：**当SCL为高电平的时候，SDA线上由低到高的跳变被定义为停止条件。

 要注意起始和终止信号都是由主机发出的，连接到I2C总线上的器件，若具有I2C总线的硬件接口，则很容易检测到起始和终止信号。



![img](https://pic2.zhimg.com/80/v2-16ef4028adef1f8c7cb4bcb9e1a90445_720w.webp)



 总线在起始条件之后，视为忙状态，在停止条件之后被视为空闲状态。

##### 3) 应答

 每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据，从机应答主机所需要的时钟仍是主机提供的，应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答。

##### 4) 数据帧格式

 SDA线上每个字节必须是8位长，在每个传输(transfer)中所传输字节数没有限制，每个字节后面必须跟一个ACK。8位数据中，先传输最高有效位（MSB）传输。



![img](https://pic1.zhimg.com/80/v2-3bb8a6428485e462a305ccb23ac50660_720w.webp)



### 10.2 在linux系统下操作I2C总线的外设

#### 10.2.1 概述

 下图是在linux系统环境里操作i2c总线上的外设流程框图。我们按照从下向上的顺序研究一下该流程中各个角色的功能。

 在硬件层中，I2C硬件总线只有两条线路，上面可以挂载多个I2C-device，这些I2C-device有的在I2C总线里充当主机的角色，一般情况该主机为板子上的主cpu中的I2C控制器，比如我们用的100ask_imx6UL板子，这个I2C主机就是imx6中的I2C控制器模块；其他的I2C-device在I2C总线里充当从机的角色，通常这些从机是板子上完成特定功能的传感器外设，只不过该外设与主控cpu的通信方式是只需要两条线路的I2C总线，比如在我们的100ask_imx6UL板子中就有eeprom和AP3216两个外设，它们在I2C总线中充当的都是I2C从机的角色，它们和主控芯片imx6中的I2C控制器1都是以并联的方式挂在这个I2C总线上。

 在内核中，驱动程序对下要完成I2C总线上的I2C通信协议，收集硬件传感器的I2C数据并封装成标准的linux操作接口供用户空间的应用程序操作。对上要实现可以通过linux程序把数据流组织成I2C协议下发到硬件层的相应的外设传感器中。

 在用户空间的应用程序中，应用工程师完全可以不必理会I2C协议的详细规定。只需要按照驱动层提供给我们的操作I2C外设的操作接口函数就可以像操作linux中其他普通设备文件那样轻松的操作I2C外设了。



![img](https://pic2.zhimg.com/80/v2-0de85fca9faa081818f1915489424ead_720w.webp)



#### **10.2.2** **简述I2C的linux驱动**

 I2C在linux内核层的驱动框架主要由三部分组成：

##### 1) I2C核心层：

 I2C核心提供了I2C总线驱动和设备驱动的注册、注销方法，I2C通信方法(algorithm)的上层部分，并且还提供了一系列与具体硬件平台无关的接口函数以及探测设备，检测设备地址的上层代码等。它位于内核源码目录下的drivers/i2c/i2c-core.c文件中，是I2C总线驱动和设备驱动之间依赖于I2C核心作为纽带。

 I2C核心中的主要函数包括：

 增加/删除i2c_adapter

```c
int i2c_add_adapter(struct i2c_adapter *adap);
int i2c_del_adapter(struct i2c_adapter *adap);
```

 增加/删除i2c_driver

```c
int i2c_register_driver(struct module *owner, struct i2c_driver *driver);
int i2c_del_driver(struct i2c_driver *driver);
inline int i2c_add_driver(struct i2c_driver *driver);
```

 i2c_client依附/脱离

```c
int i2c_attach_client(struct i2c_client *client);
int i2c_detach_client(struct i2c_client *client);
```

 i2c传输、发送和接收

```c
int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num);
```

 用于进行I2C适配器和I2C设备之间的一组消息交互。其本身不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正驱动硬件流程。

```c
int i2c_master_send(struct i2c_client *client,const char *buf ,int count);
int i2c_master_recv(struct i2c_client *client, char *buf ,int count);
```

 i2c_master_send()和i2c_master_recv()函数内部会调用i2c_transfer()函数分别完成一条写消息和一条读消息。

a） I2C控制命令分派

 下面函数有助于将发给I2C适配器设备文件ioctl的命令分派给对应适配器的algorithm的algo_control()函数或i2c_driver的command()函数：

```c
int i2c_control(struct i2c_client *client, unsigned int cmd, unsigned long arg);
void i2c_clients_command(struct i2c_adapter *adap, unsigned int cmd, void *arg);
```

##### 2) I2C总线驱动层：

 I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器可由CPU控制，甚至可以直接集成在CPU内部。

 它主要完成的功能有：

a） 初始化I2C适配器所使用的硬件资源，申请I/O地址、中断号等。

b） 通过i2c_add_adapter()添加i2c_adapter的数据结构，当然这个i2c_adapter数据结构的成员已经被xxx适配器的相应函数指针所初始化。

c） 释放I2C适配器所使用的硬件资源，释放I/O地址、中断号等。

d） 通过i2c_del_adapter()删除i2c_adapter的数据结构。

##### 3) I2C总线驱动层：

 I2C设备驱动(也称为客户驱动)是对I2C硬件体系结构中设备端的实现，设备一般挂接在受CPU控制的I2C适配器上，通过I2C适配器与CPU交换数据。I2C设备驱动模块加载函数通用的方法是在I2C设备驱动模块加载函数中完成两件事：通过register_chrdev()函数将I2C设备注册为一个字符设备。通过I2C核心的i2c_add_driver()函数添加i2c_driver。

### 10.3 在linux应用层使用I2C

 前面我们讲解了I2C的协议及在linux驱动框架，那么当你拿到开发板或者是从公司的硬件同事拿到一个带有I2C外设的板子，我们应该如何最快速的使用起来这个I2C设备呢？既然我们总是说这个I2C总线在嵌入式开发中被广泛的使用，那么是否有现成的测试工具帮我们完成这个快速使用板子的I2C设备呢？答案是有的，而且这个测试工具的代码还是开源的，它被广泛的应用在linux应用层来快速验证I2C外设是否可用，为我们测试I2C设备提供了很好的捷径。

#### **10.3.1** **如何使用I2C tools测试I2C外设**

##### 1) I2C tools概述：

 I2C tools包含一套用于Linux应用层测试各种各样I2C功能的工具。它的主要功能包括：总线探测工具、SMBus访问帮助程序、EEPROM解码脚本、EEPROM编程工具和用于SMBus访问的python模块。只要你所使用的内核中包含I2C设备驱动，那么就可以在你的板子中正常使用这个测试工具。

##### 2) 下载I2C tools源码：

 前面我们已经说过了这个I2C tools工具是开源的，那么这个源码在哪里可以找到呢？

 下载方法一：直接在内核的网站[https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/](https://link.zhihu.com/?target=https%3A//mirrors.edge.kernel.org/pub/software/utils/i2c-tools/)下载I2C tools代码的压缩包。

 下载方法二：利用git管理工具下载这个I2C tools的源代码，命令为git clone git://[http://git.kernel.org/pub/scm/utils/i2c-tools/i2c-tools.git](https://link.zhihu.com/?target=http%3A//git.kernel.org/pub/scm/utils/i2c-tools/i2c-tools.git)强烈建议读者采用第二种方法下载这个代码，因为你可以通过git快速地了解这个开源代码的不同版本的功能改进及bug修复，而且使用git开发也是作为一名优秀的开发人员必备的一项技能。

##### 3) 编译I2C tools源码：

 进入刚才利用git下载好的iic-tools源码目录，修改编译工具为你当前使用的交叉编译工具：

```c
26  CC ?= arm-linux-gnueabihf-gcc
27  AR ?= arm-linux-gnueabihf-ar
```

 编译源码：如果你想编译静态版本，你可以输入命令：make USE_STATIC_LIB=1；如果使用动态库的话，可以直接输入make进行编译。安装命令为：make install,如果你想要让最后生成的二进制文件最小的话，可以在“make install”之前运行“make strip”。但是，这将不能生成任何调试库，也就不能尝试进一步调试。然后将tools目录下的5个可执行文件i2cdetect，i2cdump，i2cget，i2cset和i2ctransfer复制到板子的/usr/sbin/中；将lib目录下的libi2c.so.0.1.1文件复制到板子的/usr/lib/libi2c.so.0。之后别忘了将上面的文件修改为可执行的权限。

##### 4) 介绍I2C tools各功能之—i2cdetect

 i2cdetect的主要功能就是I2C设备查询，它用于扫描I2C总线上的设备。它输出一个表，其中包含指定总线上检测到的设备的列表。

 该命令的常用格式为：i2cdetect [-y] [-a] [-q|-r] i2cbus [first last]。具体参数的含义如下：

![img](https://pic1.zhimg.com/80/v2-2431598c266ea4643d52993581fd3e40_720w.webp)

 该功能的常用方式：

 第一，先通过i2cdetect -l查看当前系统中的I2C的总线情况：



![img](https://pic1.zhimg.com/80/v2-cb09cbbe68e3185862b80be97454f00c_720w.webp)



 第二，若总线上挂载I2C从设备，可通过i2cdetect扫描某个I2C总线上的所有设备。可通过控制台输入i2cdetect -y 1：（其中"--"表示地址被探测到了，但没有芯片应答； "UU"因为这个地址目前正在被一个驱动程序使用，探测被省略；而16进制的地址号60，1e和50则表示发现了一个外部片选从地址为0x60，0x1e（AP3216）和0x50(eeprom)的外设芯片。



![img](https://pic3.zhimg.com/80/v2-720ce55a9771e49e1d6d08a49e98fc32_720w.webp)





![img](https://pic1.zhimg.com/80/v2-d73837bf103583b2946a429914f5bf50_720w.webp)



 第三，查询I2C总线1 (I2C -1)的功能，命令为i2cdetect -F 1：



![img](https://pic3.zhimg.com/80/v2-7478c16101de96cb5a9424ec5393c23a_720w.webp)



##### 5) 介绍I2C tools各功能之—i2cget

 i2cget的主要功能是获取I2C外设某一寄存器的内容。该命令的常用格式为：

 i2cget [-f] [-y] [-a] i2cbus chip-address [data-address [mode]]。具体参数的含义如下：

![img](https://pic3.zhimg.com/80/v2-d847a4cd8d019275b7a2bb9922013706_720w.webp)

 下面是完成读取0总线上从地址为0x50的外设的0x10寄存器的数据，命令为：

 i2cget -y -f 0 0x50 0x10



![img](https://pic1.zhimg.com/80/v2-bc623e2202c9d28494ad2bdbd535810c_720w.webp)



##### 6) 介绍I2C tools各功能之—i2cdump

 i2cdump的主要功能查看I2C从设备器件所有寄存器的值。 该命令的常用格式为：i2cdump [-f] [-r first-last] [-y] [-a] i2cbus address [mode [bank [bankreg]]]。具体参数的含义如下：

![img](https://pic1.zhimg.com/80/v2-1955382385e19f65015dcc1570739eb8_720w.webp)

 下面是完成读取0总线上从地址为0x50的eeprom的数据，命令为：

 i2cdump -f -y 0 0x50



![img](https://pic2.zhimg.com/80/v2-740946c1369a4494b056afacf2bb3ba5_720w.webp)



##### 7) 介绍I2C tools各功能之—i2cset

 i2cset的主要功能是通过I2C总线设置设备中某寄存器的值。该命令的常用格式为：

 i2cset [-f] [-y] [-m mask] [-r] i2cbus chip-address data-address [value] ...[mode]

具体参数的含义如下：

![img](https://pic4.zhimg.com/80/v2-63c546a325f93cffae3c76b66281aba7_720w.webp)

 下面是完成向0总线上从地址为0x50的eeprom的0x10寄存器写入0x55，命令为：

 i2cset -y -f 0 0x50 0x10 0x55

 然后用i2cget读取0总线上从地址为0x50的eeprom的0x10寄存器的数据，命令为：i2cget -y -f 0 0x50 0x10



![img](https://pic2.zhimg.com/80/v2-e59861ffe0c729965892ec0a2daab431_720w.webp)



##### 8) 介绍I2C tools各功能之—i2ctransfer

 i2ctransfer的主要功能是在一次传输中发送用户定义的I2C消息。i2ctransfer是一个创建I2C消息并将其合并为一个传输发送的程序。对于读消息，接收缓冲区的内容被打印到stdout，每个读消息一行。

 该命令的常用格式为：i2ctransfer [-f] [-y] [-v] [-a] i2cbus desc [data] [desc [data]]

 具体参数的含义如下：

![img](https://pic3.zhimg.com/80/v2-a1c1ae573bb812c1c14aa857e145035a_720w.webp)

 下面是完成向0总线上从地址为0x50的eeprom的0x20开始的4个寄存器写入0x01，0x02，0x03，0x04命令为：i2ctransfer -f -y 0 w5@0x50 0x20 0x01 0x02 0x03 0x04然后再通过命令i2ctransfer -f -y 0 w1@0x50 0x20 r4将0x20地址的4个寄存器数据读出来，见下图：



![img](https://pic2.zhimg.com/80/v2-a57c74369e9765e787e635025a2682b9_720w.webp)



#### **10.3.2** **在linux应用程序中读写I2C外设**

 首先通过前面的介绍，我们已经知道站在cpu的角度来看，操作I2C外设实际上就是通过控制cpu中挂载该I2C外设的I2C控制器，而这个I2C控制器在linux系统中被称为“I2C适配器”，这个已经在驱动简介中介绍过了。而且众所周知，在linux系统中，每一个设备都是以文件的形式存在的，所以在linux中操作I2C外设就变成了操作I2C适配器设备文件。Linux系统（也就是内核）为每个I2C适配器生成了一个主设备号为89的设备节点（次设备号为0-255），它并没有针对特定的I2C外设而设计，只是提供了通用的read(),write(),和ioctl()等文件操作接口，在用户空间的应用层就可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器，并控制I2C设备的工作方式。

 操作流程：

##### 1) 确定I2C适配器的设备文件节点

 i2c适配器的设备节点是/dev/i2c-x，其中x是数字。由于适配器编号是动态分配的（和注册次序有关），所以想了解哪一个适配器对应什么编号，可以查看/sys/class/i2c-dev/目录下的文件内容（在这里笔者强烈建议读者好好利用好sys文件系统）：

```c
cat /sys/class/i2c-dev/i2c-0/name
cat /sys/class/i2c-dev/i2c-1/name
```



![img](https://pic2.zhimg.com/80/v2-a65c6d3c945c25a3271c58d2b91b59d9_720w.webp)



 然后查看硬件原理图中eeprom是挂在cpu的i2c1控制器中了，然后查看IMX6UL芯片手册中I2C1的寄存器地址为21A_0000。



![img](https://pic4.zhimg.com/80/v2-b649ecc67a9b70abf2762681f79a7367_720w.webp)



 比对后，我们就很容易知道eeprom外设对应的I2C控制器的设备节点为：/dev/i2c-0。

##### 2) 打开适配器对应的设备节点

 当用户打开适配器设备节点的时候，Kernel中的i2c-dev代码为其建立一个i2c_client，但是这个i2c_client并不加到i2c_adapter的client链表当中。当用户关闭设备节点时，它自动被释放。

##### 3) IOCTL控制

 这个可以参考内核源码中的include/linux/i2c-dev.h文件。下面举例说明主要的IOCTL命令：

![img](https://pic3.zhimg.com/80/v2-19c8fdc1d8d1ebdeee1683924e51c796_720w.webp)

##### 4) 使用I2C协议和设备进行通信

 代码为：ioctl(file,I2C_RDWR,(struct i2c_rdwr_ioctl_data *)msgset); 它可以进行连续的读写，中间没有间歇。只有当适配器支持I2C_FUNC_I2C此命令才有效。参数msgset是一个指针，指向一个i2c_rdwr_ioctl_data类型的结构体，该结构体的功能就是让应用程序可以向内核传递消息，其成员包括：struct i2c_msg **user \*msgs; 和表示i2c_msgs 个数的** u32 nmsgs，它也决定了在硬件I2C总线的硬件通信中有多少个开始信号。由于I2C适配器与外设通信是以消息为单位的，所以struct i2c_msg对我们来说是非常重要的，它可以包含多条消息，而一条消息有可能包含多个数据，比如对于eeprom页写就包含多个数据。下面就介绍一下这个结构体的内容：

![img](https://pic3.zhimg.com/80/v2-ab11d10bb506e6076ac228699bd0a26e_720w.webp)

##### 5) 用read和write读写I2C设备

 当然你可以使用read()/write()来与I2C设备进行通信，代码如下（以eeprom为例简要概述操作过程）：

 第一，打开I2C控制器文件节点: fd =open(“/dev/i2c-0”, O_RDWR);

 第二，设置eeprom的设备地址：ioctl(fd,I2C_SLAVE, 0x50);

 第三，向eeprom写数据:

首先将要操作的eeprom的第一个寄存器地址赋给写buf的第0个元素wr_buf[0] = 0x10;

然后把要写入的数据写入到后面的buf中for(i=1;i<13;i++) wr_buf[i]=i;

最后通过write函数完成向eeprom写数据的功能：write(fd, wr_buf, 13);

 最后延迟1秒，让后面的操作与上面的写操作分开。

 第四，从eeprom读数据： 首先和写操作一样，将要操作的寄存器首地址0x10发给eeprom：write(fd, wr_buf, 1); 从0x10寄存器地址处读取12个字节的数据：ret=read(fd, rd_buf, 12);

 你会发现，用read和write一次只能进行一个方向的传输：或者是读外设操作，或者就是写操作传输。

 代码如下：

```c
01 #include <stdio.h>
02 #include <sys/ioctl.h>
03 #include <unistd.h>
04 #include <fcntl.h>
05 #include <linux/i2c-dev.h>
06 #include <linux/i2c.h>
07  
08 /* eeprom所对应的I2C控制器的设备节点 */ 
09 #define EEPROM_DEVICE        "/dev/i2c-0"    
10 
11 /* eeprom的I2C设备地址 */
12 #define EEPROM_ADDR    0x50
13 
14 
15 int main()
16 {
17  int fd,i,ret=0;
18  unsigned char w_add=0x10;
19  
20  /* 将要读取的数据buf*/
21  unsigned char rd_buf[13] = {0x10};  
22  
23  /* 要写的数据buf，第0个元素是要操作eeprom的寄存器地址*/
24  unsigned char wr_buf[13] = {0};     
25 
26  printf("hello,this is read_write i2c test \n");
27  
28  /* 打开eeprom对应的I2C控制器文件 */
29  fd =open(EEPROM_DEVICE, O_RDWR);
30  if (fd< 0) 
31  {
32      printf("open"EEPROM_DEVICE"failed \n");
33  }
34 
35  /*设置eeprom的I2C设备地址*/
36  if (ioctl(fd,I2C_SLAVE_FORCE, EEPROM_ADDR) < 0) 
37  {            
38      printf("set slave address failed \n");
39  }
40  
41  /* 将要操作的寄存器首地址赋给wr_buf[0] */
42  wr_buf[0] = w_add;      
43 
44  /* 把要写入的数据写入到后面的buf中 */
45  for(i=1;i<13;i++)
46      wr_buf[i]=i;
47 
48  /* 通过write函数完成向eeprom写数据的功能 */
49  write(fd, wr_buf, 13);
50 
51  /* 延迟一段时间 */
52  sleep(1);
53  
54  /*重新开始下一个操作，先写寄存器的首地址*/
55  write(fd, wr_buf, 1);
56 
57  /* 从wr_buf[0] = w_add的寄存器地址开始读取12个字节的数据 */
58  ret=read(fd, rd_buf, 12);
59  printf("ret is %d \r\n",ret);
60 
61  for(i=0;i<12;i++)
62  {
63      printf("rd_buf is :%d\n",rd_buf[i]);
64  }
65  
66  /* 完成操作后，关闭eeprom对应的I2C控制器的设备文件 */
67  close(fd);
68 
69  return 0;
70 }
```

##### 6) 用数据包的方式操作I2C设备

 构建数据包结构体：  首先是struct i2c_rdwr_ioctl_data data; 应用程序通过该结构体来给内核传递消息。该结构体包含两个成员struct i2c_msg **user \* msgs;和** u32 nmsgs;其中*msgs指向表示通信方法传输为消息的结构体。而nmsgs则决定了该数据包有多少个这样的通信消息，在I2C通信协议上来看就代表了有多少个开始信号。  接着就是struct i2c_msg; 它可以包含多条消息，而一条消息有可能包含多个数据。其成员包括：“代表I2C设备从地址的 **u16 addr; 表示本次消息的标志位的** u16 flags; 表示数据长度的 **u16 len; 表示数据缓冲区的指针** u8* buf”  然后把要和I2C从设备通信的数据与上面两个结构体建立起相应的联系。  最后调用I2C_RDWR进入驱动程序执行读写组合的I2C数据传输。  代码如下：

```c
01 #include <stdio.h>
02 #include <string.h>
03 #include <sys/ioctl.h>
04 #include <unistd.h>
05 #include <fcntl.h>
06 #include <linux/i2c-dev.h>
07 #include <linux/i2c.h>
08 
09 /* eeprom所对应的I2C控制器的设备节点 */ 
10 #define EEPROM_DEVICE        "/dev/i2c-0"    
11 
12 /* eeprom的I2C设备地址 */
13 #define EEPROM_ADDR    0x50              
14 
15 /*函数名：eeprom_write
16 **功能：向eeprom写数据
17 **参数：fd：eeprom对应I2C控制器设备节点的文件名
18 **       dev_addr：eeprom的I2C从设备地址
19 **       reg_addr：eeprom的寄存器地址
20 **       data_buf：要向eeprom写数据的数据buf
21 **       len：要写多少个字节。本例中当前最大支持为8个字节
22 **返回值：负数表示操作失败，其他为成功
23 */
24 int eeprom_write(int fd, unsigned char dev_addr, unsigned char reg_addr, unsigned char * data_buf,int len)
25 {
26  int ret;
27 
28  unsigned char msg_buf[9];
29  struct i2c_rdwr_ioctl_data data;
30 
31  struct i2c_msg messages;
32 
33 
34  /* 1. 构建msg_buf*/
35  /* 1.1. 将要操作的寄存器首地址赋给要进行I2C数据通信的首字节数据 */
36  msg_buf[0] = reg_addr;
37  
38  /* 1.2. 将要向eeprom写数据的数据buf赋在I2C数据通信中eeprom寄存器的后面 */
39  if (len < 9) {          /* 本demo最大支持一次向eeprom写一页大小的8个字节数据 */
40         memcpy((void *) &msg_buf[1], data_buf, len);  //第1位之后是数据
41     } else {
42         printf("This function supports up to 8 bytes at a time !!!\n");
43         return -1;
44     }
45 
46  /* 2. 构建 struct i2c_msg messages */
47  /* 2.1. 赋值eeprom的I2C从设备地址 */
48  messages.addr = dev_addr;  
49 
50  /* 2.2. 赋值flags为本次I2C通信完成写功能 */
51  messages.flags = 0;    
52 
53  /* 2.3. 赋值len为数据buf的长度 + eeprom寄存器地址的数据长度 */
54  messages.len = len+1;
55 
56  /* 2.4. 构建消息包的数据buf*/
57  messages.buf = msg_buf;  
58 
59  /* 3. 构建struct i2c_rdwr_ioctl_data data */
60  /* 3.1. 将准备好的消息包赋值给i2c_rdwr_ioctl_data中的msgs消息*/
61  data.msgs = &messages;
62 
63  /* 3.2. 由于本次I2C通信只有写动作，所以消息数为1次 */
64  data.nmsgs = 1;
65 
66  /* 4. 调用驱动层的读写组合的I2C数据传输 */
67  if(ioctl(fd, I2C_RDWR, &data) < 0)
68  {
69      printf("I2C_RDWR err \n");
70      return -1;
71  }
72 
73  /* 5. 等待I2C总线写入完成 */
74  sleep(1);
75 
76  return 0;
77 }
78 
79 /*函数名：eeprom_read
80 **功能：从eeprom读数据
81 **参数：fd：eeprom对应I2C控制器设备节点的文件名
82 **       dev_addr：eeprom的I2C从设备地址
83 **       reg_addr：eeprom的寄存器地址
84 **       data_buf：存放从eeprom读数据的buf
85 **       len：要读多少个字节。
86 **返回值：负数表示操作失败，其他为成功
87 */
88 int eeprom_read(int fd, unsigned char dev_addr, unsigned char reg_addr, unsigned char * data_buf,int len)
89 {
90  int ret;
91 
92  unsigned char msg_buf[9];
93  struct i2c_rdwr_ioctl_data data;
94 
95  struct i2c_msg messages[2];
96 
97  /* 1. 构建 struct i2c_msg messages */
98  /* 1.1. 构建第一条消息 messages[0] */
99  /* 1.1.1. 赋值eeprom的I2C从设备地址 */
100     messages[0].addr = dev_addr;  
101 
102     /* 1.1.2. 赋值flags为本次I2C通信完成写动作 */
103     messages[0].flags = 0;    
104 
105     /* 1.1.3. 赋值len为eeprom寄存器地址的数据长度是1 */
106     messages[0].len = 1;
107 
108     /* 1.1.4. 本次写动作的数据是要读取eeprom的寄存器首地址*/
109     messages[0].buf = &reg_addr;  
110     
111     /* 1.2. 构建第二条消息 messages[1] */
112     /* 1.2.1. 赋值eeprom的I2C从设备地址 */
113     messages[1].addr = dev_addr;  
114 
115     /* 1.1.2. 赋值flags为本次I2C通信完成读动作 */
116     messages[1].flags = I2C_M_RD;    
117 
118     /* 1.1.3. 赋值len为要读取eeprom寄存器数据长度len */
119     messages[1].len = len;
120 
121     /* 1.1.4. 本次读动作的数据要存放的buf位置*/
122     messages[1].buf = data_buf; 
123 
124     /* 2. 构建struct i2c_rdwr_ioctl_data data */
125     /* 2.1. 将准备好的消息包赋值给i2c_rdwr_ioctl_data中的msgs消息*/
126     data.msgs = messages;
127 
128     /* 2.2. 由于本次I2C通信既有写动作也有读动作，所以消息数为2次 */
129     data.nmsgs = 2;
130 
131     /* 3. 调用驱动层的读写组合的I2C数据传输 */
132     if(ioctl(fd, I2C_RDWR, &data) < 0)
133     {
134         printf("I2C_RDWR err \n");
135         return -1;
136     }
137 
138     /* 4. 等待I2C总线读取完成 */
139     sleep(1);
140 
141     return 0;
142 }
143  
144 int main()
145 {
146     int fd,i,ret=0;
147     unsigned char w_add=0x10;
148     
149     /* 将要读取的数据buf*/
150     unsigned char rd_buf[8] = {0};  
151     
152     /* 要写的数据buf*/
153     unsigned char wr_buf[8] = {0};  
154 
155     printf("hello,this is I2C_RDWR i2c test \n");
156     
157     /* 打开eeprom对应的I2C控制器文件 */
158     fd =open(EEPROM_DEVICE, O_RDWR);
159     if (fd< 0) 
160     {
161         printf("open"EEPROM_DEVICE"failed \n");
162     }   
163 
164     /* 把要写入的数据写入到后面的buf中 */
165     for(i=0;i<8;i++)
166         wr_buf[i]=i;
167 
168     /* 通过I2C_RDWR完成向eeprom读数据的功能 */
169     eeprom_write(fd,EEPROM_ADDR,w_add,wr_buf,8);
170 
171     
172     /* 通过I2C_RDWR完成向eeprom写数据的功能 */
173     eeprom_read(fd,EEPROM_ADDR,w_add,rd_buf,8);
174 
175     for(i=0;i<8;i++)
176     {
177         printf("rd_buf is :%d\n",rd_buf[i]);
178     }
179     
180     /* 完成操作后，关闭eeprom对应的I2C控制器的设备文件 */
181     close(fd);
182 
183     return 0;
184 }
185 
186
```

#### 10.3.3 简介I2C的调试方式

##### 1) 概述I2C通信中完成正常通信的常见元素：

 第一，先检查I2C总线上的所有设备是否都经上拉电阻到电源，并检查供电是否稳定。

 第二，数据线和时钟信号线是否有接反的情况。

 第三，I2C的通信速率是否超过了设备所支持的最高速度。

 第四，检查外部I2C设备与操作的I2C控制器是否挂在了同一条I2C总线上。

 第五，检查操作的I2C外设地址是否正确。

 第六，检查I2C总线上是否有多个相同设备地址的从机设备，导致通信冲突。

 第七，操作的I2C外设是否处于写保护状态，写保护状态是无法写入数据的。

 第八，检查I2C通信时序是否满足I2C通信协议。

 第九，检查在没有开始运行I2C通信程序的时候，I2C总线上的电平信号是否干净稳定的保持高电平，是否出现过主机误把SDA拉低的情况，导致I2C总线出现“忙碌”状态。

 第十，检查I2C通信过程中是否出现SDA或者SCL被长时间一直拉低的状态。比如I2C外设从机由于异常在发送完ACK信号后没有释放SDA。另一种情况是cpu在做从机的时候，没有及时完成将读取的主机数据进行处理，导致长时间将SCL拉低，破坏了I2C通信流程，因此我们在写I2C通信的时候最好尽快在I2C接收数据中断服务函数中完成数据处理工作并授权I2C控制器让其正常工作。

 由于I2C总线的协议特性，如果总线上有任何一个I2C设备将SCL或者SDA的信号拉低，其他的I2C设备都将看到这个低电平，并且都无法拉高他们。这也就是说，如果有设备不释放总线，一直把总线的电平拉低，那么整个I2C总线将会出现暂停挂死的状态，将无法按照I2C协议进行正常通信。

 如果负责I2C总线主机cpu的I2C控制器出现上述长时间拉低I2C总线的电平，理论上我们可以通过调试代码找出I2C总线死机的原因，并修改代码重新初始化该I2C控制器来复位它，让其重新进行I2C通信。如果通过调试发现导致I2C总线死机的原因是由I2C外设导致的，那么我们可以复位该外设芯片。但是在实际的项目开发中，可能复位I2C总线上的元件也无法恢复正常的I2C通信，这个时候就要设计I2C总线的主机程序将I2C控制器引脚设置为GPIO功能并模拟I2C协议完成一次完整的I2C通信，再将I2C控制器设置设置为I2C功能。

### 10.4 总结I2C在嵌入式项目开发的应用优缺点

 优点：只使用两根线，支持多个主控制器和多个从设备，I2C具有非常广泛使用的协议。

 缺点：数据传输速率比SPI慢，数据帧的大小限制为8位，实现比SPI更复杂的硬件。而且I2C通信需要注意下面的使用问题：

##### 1) I2C时钟信号（SCL）的同步问题

 在I2C总线上传送信息时的时钟同步信号是由挂接在SCL线上的所有器件的逻辑“与”完成的。SCL线上由高电平到低电平的跳变将影响到这些器件，一旦某个器件的时钟信号下跳为低电平，将使SCL线一直保持低电平，使SCL线上的所有器件开始低电平期。此时，低电平周期短的器件的时钟由低至高的跳变并不能影响SCL线的状态，于是这些器件将进入高电平等待的状态。当所有器件的时钟信号都上跳为高电平时，低电平期结束，SCL线被释放返回高电平，即所有的器件都同时开始它们的高电平期。其后，第一个结束高电平期的器件又将SCL线拉成低电平。这样就在SCL线上产生一个同步时钟。可见，时钟低电平时间由时钟低电平期最长的器件确定，而时钟高电平时间由时钟高电平期最短的器件确定。

##### 2) 总线驱动能力

 上拉电阻和负载电容决定了总线在某一速率下的稳定性。当输出为高时，电流通过上拉电阻对负载电容充电。上拉越大，电容越大，所需要的时间就越长，如果超过了通信周期的10%，那么这个上升沿就太缓了，相应的建立时间会受到影响，I2C规范的最大负载电容是400pF，快速模式下是100pF。如果输出为低，电流通过上拉电阻被I2C master器件吸取，（注意根据I2C规范，最小只有3毫安的吸取电流）那么这个吸取电流在上拉电阻上的压降就决定了输出低电平能达到的范围，如果不能达到0.3VDD以下，就会有误采样。有人说加大上拉电阻是不妥当的，要具体分析吸取电流、负载电容、上拉电平和通信速率才能决定（普通模式和快速模式是不一样的）。

 虽然速度不是特别快，但是信号线上如果有加电容的话，切记不要加大的，一定要小，否则信号还没到从设备呢，就被电容吃了。

## 11 MQTT协议分析

### 11.1 mqtt协议介绍

#### 11.1.1 概述

 MQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。

#### 11.1.2 特点

a) 开放消息协议，简单易实现

b) 发布订阅模式，一对多消息发布

c) 基于TCP/IP网络连接

d) 1字节固定报头，2字节心跳报文，报文结构紧凑

e) 消息QoS支持，可靠传输保证

#### 11.1.3 应用

 MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域。

a) 物联网M2M通信，物联网大数据采集

b) Android消息推送，WEB消息推送

c) 移动即时消息，例如Facebook Messenger

d) 智能硬件、智能家具、智能电器

e) 车联网通信，电动车站桩采集

f) 智慧城市、远程医疗、远程教育

g) 电力、石油与能源等行业市场

### 11.2 mqtt协议报文格式组成

#### 11.2.1 mqtt控制报文结构

MQTT 协议通过交换预定义的 MQTT 控制报文来通信。 这一节描述这些报文的格式。MQTT 控制报文由三部分组成，如下图:



![img](https://pic2.zhimg.com/80/v2-f32f0648d3cc3eab532ac7ccbdfbb605_720w.webp)





图2.1 mqtt报文组成



#### 11.2.2 mqtt固定报头

 每个 MQTT 控制报文都包含一个固定报头， 固定报头的格式如下图:



![img](https://pic2.zhimg.com/80/v2-671954bc425073c0ca23fb19c8be1fad_720w.webp)





图2.2 mqtt固定报头



#### 11.2.3 mqtt控制报文类型

 位置： 第 1 个字节， 二进制位 7-4,表示为 4 位无符号值。

 MQTT 控制报文的类型：如下表:

![img](https://pic4.zhimg.com/80/v2-f89b1e42b4639efbd490903392b18f1b_720w.webp)

#### 11.2.4 标记

 固定报头第 1 个字节的剩余的 4 位 [3-0]包含每个 MQTT 控制报文类型特定的标志 。标记位说明如下表所示:

![img](https://pic3.zhimg.com/80/v2-79b9c9d30c95629aadd03ed9fda04ade_720w.webp)

DUP1 =控制报文的重复分发标志 QoS2 = PUBLISH 报文的服务质量等级 RETAIN3 = PUBLISH 报文的保留标志

#### 11.2.5 剩余长度

 位置：从第二个字节开始。剩余长度（ Remaining Length） 表示当前报文剩余部分的字节数， 包括可变报头和负载的数据。 剩余长度不包括用于编码剩余长度字段本身的字节数。



![img](https://pic1.zhimg.com/80/v2-ffc1bf983d3a549a9926b7a9066f0bdc_720w.webp)





图2.3 剩余长度包含的报文范围



 剩余长度字段使用一个变长度编码方案， 对小于 128 的值它使用单字节编码。 更大的值按下面的方式处理。低 7 位有效位用于编码数据，最高有效位用于指示是否有更多的字节。 因此每个字节可以编码 128 个数值和一个延续位（ continuation bit） 。 剩余长度字段最大 4 个字节。

 例如， 十进制数 64 会被编码为一个字节， 数值是 64， 十六进制表示为 0x40,。十进制数字321(=65+2*128)被编码为两个字节， 最低有效位在前。 第一个字节是 65+128=193。 注意最高位为 1 表示后面至少还有一个字节。 第二个字节是 2。

#### 11.2.5.1 示例

```c
123456  = 964 x 128 + 64 

964 = 7x128 + 68

7 < 128

也就是123456 = (7 x 128 + 68)x128 + 64

展开:64 + 68 x128 + 7x128x128 

第一字节:64 | 0x80 = x (0x80=0x1000 0000或上最高位表示是否还有更多的字节)

第二字节:68 | 0x80 = y (0x80=0x1000 0000或上最高位表示是否还有更多的字节)

第三字节:7=z

c语言表示:unsigned char len_byte[4] = { 64 | 128 , 68 | 128,  7  , 0 }

反过来，如果要算出123456

x-128 + (y-128)*128 + z x 128 x 128
```

把剩余长度转换成字节表示：



![img](https://pic1.zhimg.com/80/v2-e151be468795335868939ff8cc23536c_720w.webp)



把字节转换成剩余长度表示：



![img](https://pic2.zhimg.com/80/v2-71088b2aa0404c57180024b1d9177af9_720w.webp)



#### 11.2.6 可变报头

 某些 MQTT 控制报文包含一个可变报头部分。 它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。报文标识符是可变报头一种，可变报头的报文标识符（ Packet Identifier） 字段存在于在多个类型的报文里。

报文标识符类型如下图:



![img](https://pic1.zhimg.com/80/v2-a106872eb0909ecafcc0e0585f06fc04_720w.webp)





图2.4 报文标识符



 很多控制报文的可变报头部分包含一个两字节的报文标识符字段。 这些报文是 PUBLISH（ QoS>0 时） ，PUBACK， PUBREC， PUBREL， PUBCOMP， SUBSCRIBE, SUBACK， UNSUBSCIBE，UNSUBACK，如下表所示：

![img](https://pic2.zhimg.com/80/v2-77087b3dbcd727309bfbe4137759c50d_720w.webp)

 客户端和服务端彼此独立地分配报文标识符。 因此，客户端服务端组合使用相同的报文标识符可以实现并发的消息交换。

 例如，当client发送一个packet Identifier =0x1234的报文给server时，server的回复报文packet identifier 必须是0x1234,Packet identifier 从1开始递增，到达65535时，又从1开始计算。



![img](https://pic1.zhimg.com/80/v2-d7529dad9ac4c96dbcc3acff89b579d0_720w.webp)





图2.5 需要 Packet Identifier 的报文类型交互示意图



#### 11.2.7 有效载荷

 某些 MQTT 控制报文在报文的最后部分包含一个有效载荷，带有有效载荷报文类型如下表所示：

![img](https://pic3.zhimg.com/80/v2-1205cffea21bcafb1ea4a015a933d82a_720w.webp)

### 11.3 报文分析

#### 11.3.1 CONNECT-连接服务端

 客户端到服务端的网络连接建立（完成三次握手）后，客户端发送给服务端的第一个报文必须是 CONNECT 报文。



![img](https://pic2.zhimg.com/80/v2-70cbbbc5e44fd0e84832b42138e5eb49_720w.webp)





图3.1 三次握手与mqtt connect交互过程



 在一个网络连接上，客户端只能发送一次 CONNECT 报文。服务端必须将客户端发送的第二个 CONNECT报文当作协议违规处理并断开客户端的连接。

 有效载荷包含一个或多个编码的字段。 包括客户端的唯一标识符， Will 主题， Will 消息， 用户名和密码。 除了客户端标识之外， 其它的字段都是可选的， 基于标志位来决定可变报头中是否需要包含这些字段。



![img](https://pic2.zhimg.com/80/v2-484121b22fa5c6796ddb281aab09dc25_720w.webp)





图3.2 connect报文组成



##### 11.3.1.1 connect固定报头

![img](https://pic2.zhimg.com/80/v2-edf855d7e79c66bfd2ba3f136f9ade11_720w.webp)

表格3.1



##### 11.3.1.2 协议名字节组成

![img](https://pic4.zhimg.com/80/v2-eb1929de183845babc13c535c8a1fdb3_720w.webp)

 数据包检测工具， 例如防火墙， 可以使用协议名来识别 MQTT 流量。

##### 11.3.1.3 协议级别

![img](https://pic2.zhimg.com/80/v2-6e0ead6c478d021fc6b1661f636ef0b1_720w.webp)

 客户端用 8 位的无符号值表示协议的修订版本。对于 3.1.1 版协议，协议级别字段的值是 4(0x04)。如果发现不支持的协议级别，服务端必须给发送一个返回码为 0x01（不支持的协议级别）的CONNACK 报文响应CONNECT 报文， 然后断开客户端的连接。

##### 11.3.1.4 连接标记

![img](https://pic1.zhimg.com/80/v2-0b636ec143a820a6d48b00eb69c49c8c_720w.webp)

**bit1清除会话**

一般来说， 客户端连接时总是将清理会话标志设置为 0 或 1， 并且不交替使用两种值。 这个选择取决于具体的应用。 清理会话标志设置为 1 的客户端不会收到旧的应用消息， 而且在每次连接成功后都需要重新订阅任何相关的主题。清理会话标志设置为 0 的客户端会收到所有在它连接断开期间发布的 QoS 1 和 QoS 2 级别的消息。因此， 要确保不丢失连接断开期间的消息， 需要使用 QoS 1 或QoS 2 级别，同时将清理会话标志设置为 0。

**Bit2遗嘱标志**

遗嘱标志（Will Flag） 被设置为 1，表示如果连接请求被接受了， 遗嘱（Will Message） 消息必须被存储在服务端并且与这个网络连接关联。之后网络连接关闭时，服务端必须发布这个遗嘱消息， 除非服务端收到DISCONNECT 报文时删除了这个遗嘱消息。

**Bit3和 bit4遗嘱 QoS**

这两位用于指定发布遗嘱消息时使用的服务质量等级, 如果遗嘱标志被设置为 0， 遗嘱 QoS 也必须设置为 0(0x00)，如果遗嘱标志被设置为 1， 遗嘱 QoS 的值可以等于 0(0x00)， 1(0x01)， 2(0x02)， 它的值不能等于 3。

**Bit5遗嘱保留**

如果遗嘱消息被发布时需要保留，需要指定这一位的值, 如果遗嘱标志被设置为 0， 遗嘱保留（Will Retain） 标志也必须设置为 0 。 如果遗嘱标志被设置为 1： · 如果遗嘱保留被设置为 0， 服务端必须将遗嘱消息当作非保留消息发布 。 · 如果遗嘱保留被设置为 1， 服务端必须将遗嘱消息当作保留消息发布。

**Bit7** **用户名标志**

如果用户名（User Name） 标志被设置为 0， 有效载荷中不能包含用户名字段。

如果用户名（User Name） 标志被设置为 1， 有效载荷中必须包含用户名字段。

**Bit6** **用户名密码标记**

如果密码（Password） 标志被设置为 0， 有效载荷中不能包含密码字段 。 如果密码（Password） 标志被设置为 1， 有效载荷中必须包含密码字段 。 如果用户名标志被设置为 0， 密码标志也必须设置为 0 。

##### 11.3.1.5 保持连接

![img](https://pic2.zhimg.com/80/v2-c7bd0c92d937570fd3895a46dbae0a8d_720w.webp)

a) 保持连接（Keep Alive） 是一个以秒为单位的时间间隔，表示为一个 16 位的字，它是指在客户端传输完成。

b) 一个控制报文的时刻到发送下一个报文的时刻， 两者之间允许空闲的最大时间间隔。 客户端负责保证控制。

c) 报文发送的时间间隔不超过保持连接的值。 如果没有任何其它的控制报文可以发送， 客户端必须发送一个PINGREQ 报文。

d) 不管保持连接的值是多少，客户端任何时候都可以发送 PINGREQ 报文，并且使用 PINGRESP 报文判断网络和服务端的活动状态。

e) 如果保持连接的值非零，并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文， 它必须断开客户端的网络连接， 认为网络连接已断开。

f) 客户端发送了 PINGREQ 报文之后， 如果在合理的时间内仍没有收到 PINGRESP 报文， 它应该关闭到服务端的网络连接。

g) 保持连接的值为零表示关闭保持连接功能。 这意味着，服务端不需要因为客户端不活跃而断开连接。 注意：不管保持连接的值是多少， 任何时候，只要服务端认为客户端是不活跃或无响应的， 可以断开客户端的连接。

##### 11.3.1.6 客户端标识符

 服务端使用客户端标识符 (ClientId) 识别客户端。 连接服务端的每个客户端都有唯一的客户端标识符（ClientId） 。客户端和服务端都必须使用 ClientId 识别两者之间的 MQTT 会话相关的状态, 客户端标识符 (ClientId) 必须存在而且必须是 CONNECT 报文有效载荷的第一个字段,客户端标识符必须是UTF-8 编码字符串。

##### 11.3.1.7 遗嘱主题

 如果遗嘱标志被设置为 1， 有效载荷的下一个字段是遗嘱主题（Will Topic） 。 遗嘱主题必须是 UTF-8 编码字符串。

##### 11.3.1.8 遗嘱消息

 如果遗嘱标志被设置为 1， 有效载荷的下一个字段是遗嘱消息。 遗嘱消息定义了将被发布到遗嘱主题的应用消息。

##### 11.3.1.9 用户名和密码

 如果用户名（ User Name） 标志被设置为 1， 有效载荷的下一个字段就是它。 用户名必须是定义的UTF-8 编码字符串。服务端可以将它用于身份验证和授权。

 如果密码（ Password） 标志被设置为 1， 有效载荷的下一个字段就是它。密码字段包含一个两字节的长度字段， 长度表示二进制数据的字节数（ 不包含长度字段本身占用的两个字节），后面跟着 0 到 65535 字节的二进制数据。



![img](https://pic3.zhimg.com/80/v2-ba2ed63a160b224314e5567f2495610a_720w.webp)





图3.2 用户名和密码在connect报文中的组成



##### 11.3.1.10 wirshark抓包分析connect报文

 从抓包可知，从上到下分别是固定报头，可变报头，连接标记，保持连接，用户名，用名密码，其中没有遗嘱相关消息字段，与3.1.1节分析的固定报头组成分析一致。



![img](https://pic3.zhimg.com/80/v2-42c45b78dbef6afd78028c8f2d3b56c2_720w.webp)





图 3.3使用wireshark抓包分析connect报文组成格式



##### 11.3.1.11 c语言构造mqtt connect报文

```c
static uint8_t client_id[512] = {"mqtt_client"};
static uint8_t user_name[512] = {"mqtt"};
static uint8_t passwd[512] = {"12345678"};
#define KEEP_ALIVE 20
int mqtt_connect(int sockfd)
{
    uint8 flags = 0x00;
    uint8 *packet = NULL;
    uint16 packet_length = 0;   
    uint16 clientidlen = strlen(client_id);
    uint16 usernamelen = strlen(user_name);
    uint16 passwordlen = strlen(passwd);
    uint16 payload_len = clientidlen + 2;
    // Variable header
    uint8 var_header[10] = {
        0x00,0x04,/*len*/
        0x4d,0x51,0x54,0x54,/*mqtt*/
        0x04,/*协议版本*/};

    uint8 fixedHeaderSize = 2;    // Default size = one byte Message Type + one byte Remaining Length
    uint8 remainLen = 0;
    uint8 *fixed_header = NULL;
    uint16 offset = 0;

    // Preparing the flags
    if(usernamelen) { /*用户名长度(可选)*/
        payload_len += usernamelen + 2;
        flags |= MQTT_USERNAME_FLAG;/*或上用户名标记*/
    }
    if(passwordlen) { /*用户密码(可选)*/
        payload_len += passwordlen + 2;
        flags |= MQTT_PASSWORD_FLAG;/*用户密码标记位*/
    }
    flags |= MQTT_CLEAN_SESSION;
    var_header[7] = flags;/*连接标记*/
    var_header[8] = KEEP_ALIVE>>8;/*保持连接字段，占用两个字节*/
    var_header[9] = KEEP_ALIVE&0xFF;

    remainLen = sizeof(var_header)+payload_len; /*剩余长度，也就是可变报头加上负载的长度*/

    if (remainLen > 127) {
        fixedHeaderSize++;// add an additional byte for Remaining Length          
    }

    fixed_header = (uint8 *)malloc(fixedHeaderSize); /*固定报头*/
    // Message Type
    *fixed_header = MQTT_MSG_CONNECT;/*报文类型,connect*/


    if (remainLen <= 127) {// Remaining Length,剩余长度计算，可变长编码
        *(fixed_header+1) = remainLen;
    } else {
        // first byte is remainder (mod) of 128, then set the MSB to indicate more bytes
        *(fixed_header+1) = remainLen % 128;
        *(fixed_header+1) = *(fixed_header+1) | 0x80;
        // second byte is number of 128s
        *(fixed_header+2) = remainLen / 128;
    }

    packet_length = fixedHeaderSize+sizeof(var_header)+payload_len;/*固定报头+可变报头+负载长度*/
    packet = (uint8 *)malloc(packet_length);/*分配内存*/
    memset(packet, 0, packet_length);
    memcpy(packet, fixed_header, fixedHeaderSize);/*填充固定报头*/
    free(fixed_header); 
    offset += fixedHeaderSize;
    memcpy(packet+offset, var_header, sizeof(var_header));/*填充可变报头*/
    offset += sizeof(var_header);

    packet[offset++] = clientidlen>>8;// Client ID - UTF encoded,填充clientid长度+clientid
    packet[offset++] = clientidlen&0xFF;
    memcpy(packet+offset, client_id, clientidlen);
    offset += clientidlen;

    if(usernamelen) {// Username - UTF encoded,填充用户名+用户名长度
        packet[offset++] = usernamelen>>8;
        packet[offset++] = usernamelen&0xFF;
        memcpy(packet+offset, user_name, usernamelen);
        offset += usernamelen;
    }

    if(passwordlen) {// Password - UTF encoded,填充用户密码+用户名密码长度
        packet[offset++] = passwordlen>>8;
        packet[offset++] = passwordlen&0xFF;
        memcpy(packet+offset, passwd, passwordlen);
        offset += passwordlen;
    }
    // Send the packet
    if (client_send(sockfd,packet, packet_length) < 0){
         free(packet);
        return -1;
    }
    free(packet);
    return 1;
}
```

#### 11.3.2 CONNACK-确认连接请求

 服务端发送 CONNACK 报文响应从客户端收到的 CONNECT 报文。服务端发送给客户端的第一个报文必须是 CONNACK。

##### 11.3.2.1 固定报头

![img](https://pic1.zhimg.com/80/v2-a2f4fdbc0d753e6ff8e4771ffcc8caa4_720w.webp)

 剩余长度字段表示可变报头的长度。 对于 CONNACK 报文这个值等于 2。

##### 11.3.2.2 可变报头

![img](https://pic4.zhimg.com/80/v2-33d3409bcfb5c8e7c08119a55af930c3_720w.webp)

**Byte1,Bit0连接确认标志**

位 7-1 是保留位且必须设置为 0,

对于bit0,如果服务端收到一个 CleanSession 为 0 的连接， 当前会话标志的值取决于服务端是否已经保存了 ClientId对应客户端的会话状态。 如果服务端已经保存了会话状态， 它必须将 CONNACK 报文中的当前会话标志设置为 1 。 如果服务端没有已保存的会话状态， 它必须将 CONNACK 报文中的当前会话设置为 0。 还需要将 CONNACK 报文中的返回码设置为 0。

**连接返回码**

如果服务端发送了一个包含非零返回码的 CONNACK 报文， 那么它必须关 闭网络连接。

![img](https://pic4.zhimg.com/80/v2-2bbd1cff8e79f21a2ae2c4c2e9675da7_720w.webp)

CONNACK没有有效载荷。

##### 11.3.2.3 CONNACK报文wireshark抓包分析



![img](https://pic1.zhimg.com/80/v2-c428e3366cb9e91a44c43ad97d63fefc_720w.webp)





图3.4 CONNACK 抓包报文



##### 11.3.2.4 c语言构造connect ack报文

```c
void mqtt_connect_ack(int sockfd)
{
    uint8_t cmd[]={ 0x20/*报文类型*/, 0x02/*剩余长度*/ ,0x00,0x00/*最后两个字节可变报头表示返回状态码*/ };
    send_msg(sockfd,cmd,sizeof(cmd));
    socket_record_t *socket_record = look_up_by_sokfd(sockfd);
    if(socket_record==NULL){
        return;
    }
    socket_record->is_connect=0x01; 
}
```

#### 11.3.3 PUBLISH-发布消息

PUBLISH 控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息。



![img](https://pic1.zhimg.com/80/v2-dd9e40eca6ad13fd9629aa363be90800_720w.webp)





图 3.5 publish报文组成格式



##### 11.3.3.1 固定报头

![img](https://pic1.zhimg.com/80/v2-563766173f91891ad4671ccfbe7a77ac_720w.webp)

**Bit3 dup**

如果 DUP 标志被设置为 0， 表示这是客户端或服务端第一次请求发送这个 PUBLISH 报文。 如果 DUP 标志被设置为 1，表示这可能是一个早前报文请求的重发。客户端或服务端请求重发一个 PUBLISH 报文时， 必须将 DUP 标志设置为 1.。 对于 QoS0 的消息， DUP 标志必须设置为 0。

**Bit1和bit2 qos等级**

![img](https://pic4.zhimg.com/80/v2-648b059826664d924d80eda4f5078aeb_720w.webp)

qos由发送端决定，发送端发送什么qos的消息，接收端就回复什么qos的消息。



![img](https://pic4.zhimg.com/80/v2-b2c7c7b0fb3f78a7fc32b60ca1bc0dd7_720w.webp)





不同qos等级mqtt报文交互流程



**Bit0** **保留标记位**

一般设置为0。

**剩余长度**

等于可变报头的长度加上有效载荷的长度。

**可变报头**

可变报头按顺序包含主题名和标识符。主题，用于识别有效载荷数据应该被发布到哪一个信息通道，标识符，只有当 QoS 等级是 1 或 2 时，报文标识符（ Packet Identifier） 字段才能出现在 PUBLISH 报文中。

##### 11.3.3.2 抓包分析PUBLISH报文



![img](https://pic1.zhimg.com/80/v2-1f02341d6cc61a1de46b35caa68ee110_720w.webp)





图 3.6 PUBLISH 抓包报文



##### 11.3.3.3 构造publish 报文

```c
int mqtt_publish_with_qos(int sockfd,const char* topic, const char* msg, uint16 msgl, uint8 retain, uint8 qos, uint16* message_id) 
{
    socket_record_t *socket_record = look_up_by_sokfd(sockfd);
    if(NULL == socket_record){
        return -1;
    }
    DEBUG_INFO("sockfd:%d",socket_record->sockfd);
    uint16 topiclen = strlen(topic);
    uint16 msglen = msgl;
    uint8 *var_header = NULL; // Topic size (2 bytes), utf-encoded topic
    uint8 *fixed_header = NULL;
    uint8 fixedHeaderSize = 0,var_headerSize = 0; // Default size = one byte Message Type + one byte Remaining Length
    uint16 remainLen = 0;
    uint8 *packet = NULL;
    uint16 packet_length = 0;

    uint8 qos_flag = MQTT_QOS0_FLAG; /*qos标记*/
    uint8 qos_size = 0; // No QoS included
    if(qos == 1) {
        qos_size = 2; // 2 bytes for QoS
        qos_flag = MQTT_QOS1_FLAG;
    }
    else if(qos == 2) {
        qos_size = 2; // 2 bytes for QoS
        qos_flag = MQTT_QOS2_FLAG;
    }

    // Variable header
    var_headerSize = topiclen/*主题内容*/+2/*主题长度占用两字节*/+qos_size/*标识符*/;
    var_header = (uint8 *)malloc(var_headerSize);
    memset(var_header, 0, var_headerSize);
    *var_header = topiclen>>8;
    *(var_header+1) = topiclen&0xFF;
    memcpy(var_header+2, topic, topiclen);
    if(qos_size) {//qos1和qos2的报文需要填充标识符,有点像tcp的seq
        socket_record->publish_seq++;
        if(socket_record->publish_seq == 0){
            //unsigned short 表示范围0~65535,标识符必须是非零整数
            socket_record->publish_seq = 1;
        }
        var_header[topiclen+2] = (socket_record->publish_seq & 0xff00)>>8;
        var_header[topiclen+3] = socket_record->publish_seq & 0x00ff;
        if(message_id) { 
            *message_id = socket_record->publish_seq;
        }
    }

    fixedHeaderSize = 2;    // Default size = one byte Message Type + one byte Remaining Length
    remainLen = var_headerSize+msglen;
    if (remainLen > 127) {/*剩余长度*/
        fixedHeaderSize++;          // add an additional byte for Remaining Length
    }
    fixed_header = (uint8 *)malloc(fixedHeaderSize);/*固定报头+剩余长度*/

    // Message Type, DUP flag, QoS level, Retain
    *fixed_header = MQTT_MSG_PUBLISH | qos_flag;/*报文类型和qos标记*/
    if(retain) {
        *fixed_header  |= MQTT_RETAIN_FLAG;/*是否保留*/
    }
    // Remaining Length，剩余长度
    if (remainLen <= 127) {
       *(fixed_header+1) = remainLen;
    } else {
       // first byte is remainder (mod) of 128, then set the MSB to indicate more bytes
       *(fixed_header+1) = remainLen % 128;
       *(fixed_header+1) = *(fixed_header+1) | 0x80;
       // second byte is number of 128s
       *(fixed_header+2) = remainLen / 128;
    }

    packet_length = fixedHeaderSize+var_headerSize+msglen;/*固定报头+可变报头+负载长度*/
    packet = (uint8 *)malloc(packet_length);
    memset(packet, 0, packet_length);
    memcpy(packet, fixed_header, fixedHeaderSize);/*填充固定报头*/
    memcpy(packet+fixedHeaderSize, var_header, var_headerSize);/*填充可变报头*/
    memcpy(packet+fixedHeaderSize+var_headerSize, msg, msglen);/*负载*/
    free(var_header);
    free(fixed_header);
    send_msg(sockfd,packet , packet_length);
    free(packet);
    return 1;
}
```

#### 11.3.4 PUBREC-发布收到

PUBREC 报文是对 QoS 等级 2 的 PUBLISH 报文的响应。它是 QoS 2 等级协议交换的第二个报文。

##### 11.3.4.1 固定报头

![img](https://pic4.zhimg.com/80/v2-91e81f66ecdcd29a4dadb0054aadf8cb_720w.webp)

**剩余长度**

表示可变报头的长度。 对 PUBREC 报文它的值等于 2。

**可变报头**

![img](https://pic1.zhimg.com/80/v2-efdd4c3e09bc91cc7abd9943b58f8ff0_720w.webp)

**有效载荷**

PUBREC 报文没有有效载荷。

##### 11.3.4.2 PUBREC抓包报文



![img](https://pic4.zhimg.com/80/v2-ec4b53ef2d09ff4f3bce415ffb457d53_720w.webp)





图 3.7 PUBREC抓包报文图示



##### 11.3.4.3 c语言构造pubrec报文

```c
//如果是PUBREC报文，head_type=0x50
void mqtt_qos2_pubrec(int  sockfd , unsigned char *data,unsigned char head_type)
{
    uint16 msg_id = mqtt_parse_msg_id(data);/*报文标识符,回复报文和接受报文的标识符必须一样*/
    unsigned char qos2_pubrec_respon[]={head_type/*固定报头*/,0x02/*剩余长度*/, (msg_id&0xff00)>>8 , msg_id&0x00ff/*最后两个字节是报文标识符*/};
    send_msg(sockfd,qos2_pubrec_respon,sizeof(qos2_pubrec_respon));
}
```

#### 11.3.5 PUBREL-发布释放

PUBREL 报文是对 PUBREC 报文的响应。 它是 QoS 2 等级协议交换的第三个报文。

##### 11.3.5.1 固定报头

![img](https://pic4.zhimg.com/80/v2-f368eb1340c9847db404f5b120760fc7_720w.webp)

**剩余长度**

表示可变报头的长度。 对 PUBREL 报文它的值等于 2。

**可变报头**

![img](https://pic2.zhimg.com/80/v2-3f45f4ef877c6111fdf3f370c3e50fe9_720w.webp)

**有效载荷**

PUBREL 报文没有有效载荷。

##### 11.3.5.2 PUBREL抓包报文



![img](https://pic1.zhimg.com/80/v2-63f454d36b093790dc65e8b9de2a5c8c_720w.webp)





图 3.8 PUBREL抓包报文图示



##### 11.3.5.3 c语言构造pubrel报文

```c
//head_type=0x62
void mqtt_qos2_pubrel(int sockfd , unsigned char *data,unsigned char head_type)
{
    uint16 msg_id = mqtt_parse_msg_id(data);
    unsigned char qos2_pubrel_respon[]={head_type/*报文类型*/,0x02/*剩余长度*/, (msg_id & 0xff00)>>8 , msg_id & 0x00ff/*最后两个字节是报文标识符*/};
    send_msg(sockfd,qos2_pubrel_respon,sizeof(qos2_pubrel_respon));
}
```

#### 11.3.6 PUBCOMP-发布完成

PUBCOMP 报文是对 PUBREL 报文的响应。 它是 QoS 2 等级协议交换的第四个也是最后一个报文。

##### 11.3.6.1 固定报头

![img](https://pic1.zhimg.com/80/v2-cf5b9146cfc09d37c27a9287f1796510_720w.webp)

**剩余长度**

表示可变报头的长度。 对 PUBCOMP 报文它的值等于 2。

**可变报头**

![img](https://pic1.zhimg.com/80/v2-62d339e20f1be67c1155c01c0b855c9c_720w.webp)

**有效载荷**

PUBCOMP 报文没有有效载荷。

##### 11.3.6.2 PUBCOMP抓包报文



![img](https://pic4.zhimg.com/80/v2-8355db8c46ac0793030af8ac802e4663_720w.webp)





图 3.9 PUBCOMP抓包报文图示



##### 11.3.6.3 c语言构造pubcom报文

```c
//head_type=0x70
void mqtt_qos2_pubcomp(int   sockfd , unsigned char *data,unsigned char head_type)
{
    uint16 msg_id = mqtt_parse_msg_id(data);/*报文标识符*/
    unsigned char qos2_pubcomp_respon[]={head_type/*报文类型*/,0x02/*剩余长度*/, (msg_id & 0xff00)>>8 , msg_id & 0x00ff/*最后两个字节报文标识符*/};
    send_msg(sockfd,qos2_pubcomp_respon,sizeof(qos2_pubcomp_respon));
}
```

#### 11.3.7 PINGREQ-心跳请求

客户端发送 PINGREQ 报文给服务端的。用于：

a) 在没有任何其它控制报文从客户端发给服务的时，告知服务端客户端还活着。

b) 请求服务端发送 响应确认它还活着。

c) 使用网络以确认网络连接没有断开。

##### 11.3.7.1 固定报头

![img](https://pic1.zhimg.com/80/v2-2f279dad3245d4cd0fb44051f3f35d98_720w.webp)

**可变报头**

报文没有可变报头。

**有效载荷**

PINGREQ 报文没有有效载荷。

##### 11.3.7.2 PINGREQ 抓包报文



![img](https://pic4.zhimg.com/80/v2-e2b7083d78c3dabaad5ad3c7ebfc944b_720w.webp)





图 3.10 PINGREQ抓包报文图示



##### 11.3.7.3 c语言构造pingreq报文

```c
int mqtt_ping(int sockfd)
{
    uint8 packet[] = {MQTT_MSG_PINGREQ/*报文类型*/,0x00/*剩余长度*/};
    int ret = send_msg(sockfd,packet, sizeof(packet));
    return ret;
}
```

#### 11.3.8 PINGRESP – 心跳响应

服务端发送 PINGRESP 报文响应客户端的 PINGREQ 报文。 表示服务端还活着。

##### 11.3.8.1 固定报头

![img](https://pic4.zhimg.com/80/v2-f1b400c4c5ffd6e297fa4f3812e4d4ab_720w.webp)

**可变报头**

报文没有可变报头。

**有效载荷**

PINGRESP 报文没有有效载荷。

##### 11.3.8.2 PINGRESP 抓包报文



![img](https://pic2.zhimg.com/80/v2-dc89c925704d207a2196b1c136817515_720w.webp)





图 3.11 PINGRESP抓包报文图示



##### 11.3.8.3 c语言构造pinpresp报文

```c
void mqtt_ping_req_reply(int sockfd)
{
    uint8_t cmd[]={0xd0/*报文类型*/, 0x00/*剩余长度*/};
    send_msg(sockfd,cmd,sizeof(cmd));
}
```

#### 11.3.9 DISCONNECT –断开连接

DISCONNECT 报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。

##### 11.3.9.1 固定报头

| bit    | 7                  | 6      | 5    | 4    | 3    | 2    | 1    | 0    |
| ------ | ------------------ | ------ | ---- | ---- | ---- | ---- | ---- | ---- |
| Byte 1 | MQTT报文类型（14） | 保留位 |      |      |      |      |      |      |
|        | 1                  | 1      | 1    | 0    | 0    | 0    | 0    | 0    |
| Byte2  | 剩余长度 0         |        |      |      |      |      |      |      |

**可变报头**

DISCONNECT报文没有可变报头。

**有效载荷**

DISCONNECT 报文没有有效载荷。

##### 11.3.9.2 DISCONNECT 抓包报文



![img](https://pic3.zhimg.com/80/v2-e9bf99f3252832b2c4b9f116551d506a_720w.webp)





图 3.12 DISCONNECT抓包报文图示



##### 11.3.9.3 c语言构造disconnect报文

```c
int mqtt_disconnect(int sockfd) 
{
    uint8 packet[] = {MQTT_MSG_DISCONNECT/*报文类型*/,0x00/*剩余长度*/}; 
    int ret = client_send(sockfd,packet, sizeof(packet));
    DEBUG_INFO("ret=%d",ret);
    return ret;
}
```

#### 11.3.10 SUBSCRIBE-订阅主题

客户端向服务端发送 SUBSCRIBE 报文用于创建一个或多个订阅。 每个订阅注册客户端关心的一个或多个主题。 为了将应用消息转发给与那些订阅匹配的主题， 服务端发送 PUBLISH 报文给客户端。 SUBSCRIBE报文也（为每个订阅）指定了最大的 QoS 等级， 服务端根据这个发送应用消息给客户端。



![img](https://pic4.zhimg.com/80/v2-00fa06e644b4072a2f110a4c61294067_720w.webp)





图 3.13 订阅主题报文组成格式



##### 11.3.10.1 固定报头

![img](https://pic3.zhimg.com/80/v2-585d0e7a0240b0b9399647af46285fa6_720w.webp)

SUBSCRIBE 控制报固定报头的第 3,2,1,0 位是保留位， 必须分别设置为 0,0,1,0,服务端必须将其它的任何值都当做是不合法的并关闭网络连接。

**剩余长度字段** 等于可变报头的长度（ 2 字节） 加上有效载荷的长度。

**可变报头**

![img](https://pic1.zhimg.com/80/v2-084cb3c5f2a56e66067ce252dc8a6d90_720w.webp)

服务端收到客户端发送的一个 SUBSCRIBE 报文时， 必须使用 SUBACK 报文响应。SUBACK 报文必须和等待确认的 SUBSCRIBE 报文有相同的报文标识符。

**有效载荷**

![img](https://pic4.zhimg.com/80/v2-316937aead8463234a100e998b0e0ad7_720w.webp)

QoS 不等于 0,1 或 2， 服务端必须认为 SUBSCRIBE 报文是不合法的并关闭网络连接。

##### 11.3.10.2 SUBSCRIBE报文抓包



![img](https://pic2.zhimg.com/80/v2-dbba0348ad3f0fce2140c9a6ea007601_720w.webp)





图 3.14 订阅主题抓包报文



##### 11.3.10.3 c语言构造subscribe报文

```c
static uint16 su_seq = 1;
int mqtt_subscribe_theme(int sockfd,char *Theme , uint8_t Qos)
{
    su_seq++;//报文标识符
    if(su_seq == 0){
        su_seq = 1;
    }
    uint16_t MessageId = su_seq;
    uint8_t cmd[1024]={0};
    //报文标示符长度2 + 主题长度位占用2字节+主题内容+qos标识
    int data_length = 2+2+strlen(Theme)+1; 
    int playload_len = strlen(Theme);
    uint8_t len_byte[4] ={0x00 , 0x00 ,0x00 ,0x00};
    uint8_t byte_num = length_trans_byte_form(data_length , len_byte);/*把剩余长度转换成变长编码*/
    cmd[0] = 0x82;
    memcpy(&cmd[1] , len_byte , byte_num);

    cmd[1+byte_num]=(MessageId & 0xff00) >> 8 ;
    cmd[1+byte_num+1] = MessageId & 0x00ff;     
    cmd[1+byte_num+1+1] = (playload_len & 0xff00) >> 8;
    cmd[1+byte_num+1+1+1] = playload_len & 0x00ff;
    memcpy(&cmd[1+byte_num+1+1+1+1] , Theme , playload_len);
    cmd[1+byte_num+1+1+1+1+playload_len] = Qos;
    client_send(sockfd,cmd, 1+byte_num+1+1+1+1+playload_len+1);
}
```

#### 11.3.11 SUBACK –订阅确认

服务端发送 SUBACK 报文给客户端，用于确认它已收到并且正在处理 SUBSCRIBE 报文。

##### 11.3.11.1 固定报头

![img](https://pic2.zhimg.com/80/v2-783b1828339d9a0e33d66c71d58cc021_720w.webp)

**剩余长度字段** 等于可变报头的长度加上有效载荷的长度。

**可变报头**

![img](https://pic1.zhimg.com/80/v2-0819483b8ab3b1204299351e90eb829c_720w.webp)

可变报头包含等待确认的 SUBSCRIBE 报文的报文标识符。

##### 11.3.11.2 SUBACK抓包报文



![img](https://pic4.zhimg.com/80/v2-f80f120c3c7245660f2f7064053669c3_720w.webp)





图 3.15订阅主题ack抓包报文



##### 11.3.11.3 c语言构造suback报文

```c
void mqtt_subscribe_ack(int sockfd,const uint8 *buf)
{
    uint16 msg_id = mqtt_parse_msg_id(buf);/*提取报文标识符*/
    uint8 qos = MQTTParseMessageQos(buf);/*提取报文qos*/
    uint8 cmd[]={0x90,0x03/*剩余长度*/, (msg_id & 0xff00) >> 8, msg_id & 0x00ff,qos};
    send_msg(sockfd,cmd,sizeof(cmd));
}
```

#### 11.3.12 UNSUBSCRIBE –取消订阅

客户端发送 UNSUBSCRIBE 报文给服务端， 用于取消订阅主题。



![img](https://pic1.zhimg.com/80/v2-f54d6d90eae5763f0c1543678e9e2264_720w.webp)





图 3.16取消订阅主题报文结构



##### 11.3.12.1 固定报头

![img](https://pic3.zhimg.com/80/v2-47da5aebb8ef0f9a3cc327adcf0a8d96_720w.webp)

UNSUBSCRIBE 报文固定报头的第 3,2,1,0 位是保留位且必须分别设置为 0,0,1,0。 服务端必须认为任何其它的值都是不合法的并关闭网络连接。

**剩余长度字段** 等于可变报头的长度，加上有效载荷的长度。

**可变报头**

![img](https://pic2.zhimg.com/80/v2-169af962e597df68ea733d9629422f5d_720w.webp)

可变报头包含一个报文标识符。

**有效载荷**

![img](https://pic4.zhimg.com/80/v2-93b18405a58daf6fc0ab41f9c775684f_720w.webp)

UNSUBSCRIBE 报文的有效载荷必须至少包含一个消息过滤器。 没有有效载荷的 UNSUBSCRIBE 报文是违反协议的。

##### 11.3.12.2 UNSUBSCRIBE抓包报文



![img](https://pic3.zhimg.com/80/v2-943f58d76c7c87e49b8c71bb2833827a_720w.webp)





图 3.17取消订阅主题抓包报文



##### 11.3.12.3 c语言构造unsubscribe报文

```c
static uint16 un_seq = 1;
int mqtt_unsubscribe_theme(int sockfd,const char* topic)
{
    un_seq++;
    if(un_seq == 0){
        un_seq = 1;
    }
    uint16_t MessageId = un_seq;
    uint8_t cmd[1024]={0};
    //报文标示符长度2 + 主题长度位占用2字节+主题内容+qos标识
    int data_length = 2+2+strlen(topic)+1; 
    int playload_len = strlen(topic);
    uint8_t len_byte[4] ={0x00 , 0x00 ,0x00 ,0x00};
    uint8_t byte_num = length_trans_byte_form(data_length , len_byte);/*剩余长度转换成变长编码*/
    cmd[0] = 0xa2;
    memcpy(&cmd[1] , len_byte , byte_num);

    cmd[1+byte_num]=(MessageId & 0xff00) >> 8 ;
    cmd[1+byte_num+1] = MessageId & 0x00ff;     
    cmd[1+byte_num+1+1] = (playload_len & 0xff00) >> 8;
    cmd[1+byte_num+1+1+1] = playload_len & 0x00ff;
    memcpy(&cmd[1+byte_num+1+1+1+1] , topic , playload_len);
    client_send(sockfd,cmd,1+byte_num+1+1+1+1+playload_len+1);
    return 1;
}
```

#### 11.3.13 UNSUBACK –取消订阅确认

服务端发送 UNSUBACK 报文给客户端用于确认收到 UNSUBSCRIBE 报文。



![img](https://pic1.zhimg.com/80/v2-26f82c56600e0c4e2d270acfbb5c222c_720w.webp)





图 3.18取消订阅主题ack报文组成



##### 11.3.13.1 固定报头

![img](https://pic4.zhimg.com/80/v2-5df19bf9e7744e80f8bd450805fa2047_720w.webp)

**剩余长度字段** 表示可变报头的长度， 对 UNSUBACK 报文这个值等于 2。

**可变报头**

![img](https://pic4.zhimg.com/80/v2-1f482a2df82b8d08b4ffac5a0369ef2b_720w.webp)

可变报头包含等待确认的 UNSUBSCRIBE 报文的报文标识符。

##### 11.3.12.2 UNSUBSCRIBE ACK抓包报文



![img](https://pic1.zhimg.com/80/v2-c8c3a46a10caae929dbaa8faf8e169c0_720w.webp)





图 3.19取消订阅主题ACK抓包报文



##### 11.3.12.3 c语言构造unsubscribe报文

```c
void mqtt_unsubscribe_ack(int sockfd,const uint8 *buf)
{
    uint16 msg_id = mqtt_parse_msg_id(buf);
    uint8 cmd[]={0xb0,0x02/*剩余长度*/,(msg_id & 0xff00) >> 8, msg_id & 0x00ff/*最后两个字节是报文标识符*/};
    send_msg(sockfd,cmd,sizeof(cmd));
}
```

#### 11.3.14 服务端与客户端交互操作过程

##### 11.3.14.1 编译

编译client之前先在代码中指定server ip



![img](https://pic1.zhimg.com/80/v2-bcb15ce15ed18cbb34d689643fec3838_720w.webp)



进入client目录，直接make即可



![img](https://pic2.zhimg.com/80/v2-0541682b892766158237362849d26d05_720w.webp)



进入server目录，直接make即可



![img](https://pic1.zhimg.com/80/v2-02e948f4731ad0662f0b7093baeb8eac_720w.webp)



##### 11.3.14.2 执行

先运行server



![img](https://pic3.zhimg.com/80/v2-1c5340720b47ca1d746699f5be106582_720w.webp)



再运行client



![img](https://pic1.zhimg.com/80/v2-b05f999959a75a4e90abe62300148a30_720w.webp)



Client操作流程



![img](https://pic2.zhimg.com/80/v2-0c491f3a01f0177401bc9815666ae231_720w.webp)



在server端查看



![img](https://pic3.zhimg.com/80/v2-58ad1eb8ae4c2276daab0f2b99509612_720w.webp)

## 12 CAN编程

### 12.1 CAN介绍

#### 12.1.1 CAN是什么？

 CAN，全称为“Controller Area Network”，即控制器局域网，是国际上应用最广泛的现场总线之一。

最初，CAN 被设计作为汽车环境中的微控制器通讯，在车载各电子控制装置 ECU 之间交换信息，形成汽车

电子控制网络。比如：发动机管理系统、变速箱控制器、仪表装备、电子主干系统中，均嵌入 CAN 控制装

置。

 一个由 CAN 总线构成的单一网络中，理论上可以挂接无数个节点。实际应用中，节点数目受网络硬件

的电气特性所限制。例如，当使用 Philips P82C250 作为 CAN 收发器时，同一网络中允许挂接 110 个节点。

CAN 可提供高达 1Mbit/s 的数据传输速率，这使实时控制变得非常容易。另外，硬件的错误检定特性也增

强了 CAN 的抗电磁干扰能力。

#### 12.1.2 CAN的起源

 CAN 最初出现在 80 年代末的汽车工业中，由德国 Bosch 公司最先提出。当时，由于消费者对于汽车功

能的要求越来越多，而这些功能的实现大多是基于电子操作的，这就使得电子装置之间的通讯越来越复杂，

同时意味着需要更多的连接信号线。提出 CAN 总线的最初动机就是为了解决现代汽车中庞大的电子控制装

置之间的通讯，减少不断增加的信号线。于是，他们设计了一个单一的网络总线，所有的外围器件可以被

挂接在该总线上。1993 年，CAN 已成为国际标准 ISO11898(高速应用)和 ISO11519（低速应用）。

CAN 是一种多主方式的串行通讯总线，基本设计规范要求有高的位速率，高抗电磁干扰性，而且能够检

测出产生的任何错误。当信号传输距离达到 10Km 时，CAN 仍可提供高达 50Kbit/s 的数据传输速率。

由于 CAN 总线具有很高的实时性能，因此，CAN 已经在汽车工业、航空工业、工业控制、安全防护等领

域中得到了广泛应用。

#### 12.1.3 CAN传输模型

 CAN 通讯协议主要描述设备之间的信息传递方式。CAN 层的定义与开放系统互连模型（OSI）一致。每

一层与另一设备上相同的那一层通讯。实际的通讯发生在每一设备上相邻的两层，而设备只通过模型物理

层的物理介质互连。CAN 的规范定义了模型的最下面两层：数据链路层和物理层。下表中展示了 OSI 开放

式互连模型的各层。应用层协议可以由 CAN 用户定义成适合特别工业领域的任何方案。已在工业控制和制

造业领域得到广泛应用的标准是 DeviceNet，这是为 PLC 和智能传感器设计的。在汽车工业，许多制造商

都应用他们自己的标准。

![img](https://pic4.zhimg.com/80/v2-06243346ab05a5064f7d42b91774e7ef_720w.webp)

 虽然CAN传输协议参考了OSI 七层模型，但是实际上CAN协议只定义了两层“物理层”和“数据链路层”，因此出现了各种不同的“应用层”协议，比如用在自动化技术的现场总线标准DeviceNet，用于工业控制的CanOpen,用于乘用车的诊断协议OBD、UDS(统一诊断服务，ISO14229)，用于商用车的CAN总线协议SAEJ1939.

![img](https://pic3.zhimg.com/80/v2-3c0c672d822d54238e26472010b20ea6_720w.webp)

#### 12.1.4 CAN网络拓扑

 CAN总线是一种分布式的控制总线。

 CAN总线作为一种控制器局域网，和普通以太网一样，它的网络很多CAN节点构成。

其网络拓扑结构如下图所示：



![img](https://pic4.zhimg.com/80/v2-4c4a7ffc25e1c5caab460ee3c715cbff_720w.webp)



 CAN网络的每个节点非常简单，均由一个MCU（微控制器）、一个CAN控制器和一个CAN收发器构成，然后使用双绞线连接到CAN网络中。

#### 12.1.5 CAN物理特性

 CAN总线遵循国际标准ISO11898，如ISO11898-1,ISO11898-2,ISO11898-3,ISO11898-4标准。

![img](https://pic4.zhimg.com/80/v2-0e9bb7eeee9e9ea934e1c0c6702d5e73_720w.webp)

CAN 能够使用多种物理介质，例如双绞线、光纤等。最常用的就是双绞线。

信号使用差分电压传送，两条信号线被称为“CAN_H”和“CAN_L”。

静态时CAN_H和CAN_L均是 2.5V 左右，此时状态表示为逻辑“1”，也可以叫做 “隐性”。

用 CAN_H 比 CAN_L 高表示逻辑“0”，称为“显形”，此时，通常电压值为：CAN_H = 3.5V 和 CAN_L

= 1.5V 。

目前实际常用的CAN收发器有如下几种型号：

![img](https://pic2.zhimg.com/80/v2-62c1fe5b45d70c8bd6270affb2a15b35_720w.webp)

目前实际常用的CAN控制器有如下几种型号：

![img](https://pic2.zhimg.com/80/v2-91a2cdbe2ff76799b5a74c1877ce2251_720w.webp)

#### 12.1.6 CAN报文帧

##### 12.1.6.1 CAN报文格式

标准 CAN 的标志符长度是 11 位，而扩展格式 CAN 的标志符长度可达 29 位。

CAN 协议的 2.0A 版本 规定 CAN 控制器必须有一个 11 位的标志符。

同时，在 2.0B 版本中规定，CAN 控制器的标志符长度可以是 11 位或 29 位。

遵循 CAN2.0B 协议的 CAN 控制器可以发送和接收 11 位标识符的标准格式报文或 29 位标识符的扩展格式报文。

![img](https://pic1.zhimg.com/80/v2-ed18438b98db33002efa5e712e1a8778_720w.webp)

##### 12.1.6.2 CAN报文帧类型

CAN报文类型又分如5种帧类型：

数据帧：主要用于发送方向接收方传输数据的帧；

遥控帧：主要用于接收方向具有相同ID的发送方请求数据的帧；

错误帧：主要用于当检测出错误时向其他节点通知错误的帧。

过载帧：主要用于接收方通知其他尚未做好接收准备的帧。

间隔帧：主要用于将数据帧及遥控帧与前一帧分隔开来的帧。

其中数据帧是使用最多的帧类型，这里重点介绍以下数据帧。

数据帧如下图所示：



![img](https://pic2.zhimg.com/80/v2-8edea96dc300a10745b8178f1d942155_720w.webp)



由上图所示，数据帧包括：

（1）帧起始。表示数据帧开始的段。

（2）仲裁段。表示该帧优先级的段。

（3）控制段。表示数据的字节数及保留位的段。

（4）数据段。数据的内容，一帧可发送0~8个字节的数据。

（5）CRC段。检查帧的传输错误的段。

（6）ACK段。表示确认正常接收的段。

（7）帧结束。表示数据帧结束的段。

具体介绍可以查看”CAN2.0A”、”CAN2.0B”详细介绍。

我们主要关注我们编程所需要关注的几个段：

ID: CAN报文ID；

IDE: 为0是标准帧，为1是扩展帧；

RTR: 为0是数据帧，为1是远程帧；

DLC: CAN报文数据长度，范围0~8字节；

Data：数据，0~8个字节；

### 12.2 CAN编程框架创建

当前我们所学习的是应用编程，为了以后CAN编程框架的通用性和可移植性，我们创建一个抽象的CAN应用编程框架，此框架可以适用于单片机应用编程，也可以适用于linux应用编程。

因此，根据CAN总线编程的通用属性，我们抽象出如下属性：

![img](https://pic4.zhimg.com/80/v2-9d4a5e5456b61d5e313ed0b1da5475ab_720w.webp)

根据上面表格所描述的属性，创建CAN应用编程框架如下：

```c
typedef struct _CAN_COMM_STRUCT
{
    /* CAN硬件名称 */
    char name[10];
    /* CAN端口号，裸机里为端口号;linux应用里作为socket套接口 */
    int  can_port;                                
    /* CAN控制器配置函数，返回端口号赋值给can_port */
    int  (*can_set_controller)( void );                  
    /* CAN接口中断创建，在linux中对应创建接收线程 */
    void (*can_set_interrput)( int can_port , pCanInterrupt callback );             
    /* CAN读取报文接口 */
    void (*can_read)( int can_port , CanRxMsg* recv_msg);   
    /* CAN发送报文接口*/
    void (*can_write)( int can_port , CanTxMsg send_msg);   
}CAN_COMM_STRUCT, *pCAN_COMM_STRUCT;
```

此框架可以用类比套用在单片机上，也可以使用在linux socketcan应用编程上。

### 12.3 STM32 CAN应用编程

本节主要使用14.2中的应用编程框架，在单片机上试验框架的可行性，以一个基本的接收和发送的案例来做讲解；

#### 12.3.1 STM32 CAN接口电路

如下图所示，为本章STM32例程所使用的开发板STM32最小系统和CAN收发器接口电路。



![img](https://pic3.zhimg.com/80/v2-214307c7fe5ad34aea6c1cb681bf7de6_720w.webp)





图14.3.1-1 STM32F407最小系统





![img](https://pic1.zhimg.com/80/v2-fe05197de632b0d3f520c912bf0546a8_720w.webp)





图14.3.1-1 TJA1050 CAN收发器接口电路



#### 12.3.2 STM32 CAN应用编程步骤

下面我们按照CAN通信的编程框架来一步一步实现基于STM32的CAN应用编程。

STM32 CAN应用编程，步骤如下：

##### **12.3.2.1** **准备STM32工程模版**

请参见第14章节代码“01_stm32f407_can”例程；

所使用的开发环境为：MDK 5.24.

打开MDK工程后，如下图所示：



![img](https://pic1.zhimg.com/80/v2-588dab1682857c73c6581f01e73992a0_720w.webp)



上图中目录CMSIS, STM32F407_LIB，main均为STM32运行的基础框架。

目录app_can为CAN应用编程所需要的文件。

##### **12.3.2.2** **编写CAN抽象框架的实现函数**

**（1）定义CAN端口号**

见第14章节代码“01_stm32f407_can_addline”中“can_controller.h”文件。

主要根据STM32硬件的CAN有多路，依次定义为CAN_PORTCAN1, CAN_PORT_CAN2等，从“14.3.1 STM32 CAN接口电路”可知道，当前使用的CAN1.

```c
25 /* CAN端口号定义*/
26 enum
27 {
28     CAN_PORT_NONE = 0,
29     CAN_PORT_CAN1,
30     CAN_PORT_CAN2,
31     CAN_PORT_MAX
32 };
```

**（2）配置CAN控制器**

配置CAN控制器有3个部分：GPIO(CAN_TX,CAN_RX管脚）配置，CAN波特率配置，CAN过滤器配置。

见第14章节代码“01_stm32f407_can_addline”中“can_controller.c”文件int CAN_Set_Controller( void )函数。

**A.GPIO(CAN_TX,CAN_RX管脚）配置**

配置GPIO代码如下：

```c
96     /*************************************************************/
97     /*CAN相关GPIO配置，此处为：CAN_TX, CAN_RX*/
98
99     /*使能GPIO时钟*/
100     RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
101     /*初始化管脚配置*/
102     GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_0 ;
103     GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF;
104     GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_50MHz;
105     GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
106     GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_UP;
107     GPIO_Init(GPIOD, &GPIO_InitStructure);
108
109     GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_1;
110     GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF;
111     GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_50MHz;
112     GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
113     GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_UP;
114     GPIO_Init(GPIOD, &GPIO_InitStructure);
115     /*将GPIO设置为CAN复用模式*/
116     GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_CAN1);
117     GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_CAN1);
```

**B.配置波特率，工作模式**

按照如下代码，使能CAN外设，设置CAN工作模式为Normal，设置波特率为500kbps。

```c
119     /*************************************************************/
120     /*CAN控制器相关配置，此处为波特率，采样率等*/
121
122     /* 使能CAN时钟 */
123     RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);
124
125     /* 初始化CAN控制器工作模式*/
126     CAN_DeInit(CAN1);
127     CAN_StructInit(&CAN_InitStructure);
128     CAN_InitStructure.CAN_TTCM = DISABLE;
129     CAN_InitStructure.CAN_ABOM = DISABLE;
130     CAN_InitStructure.CAN_AWUM = DISABLE;
131     CAN_InitStructure.CAN_NART = DISABLE;
132     CAN_InitStructure.CAN_RFLM = DISABLE;
133     CAN_InitStructure.CAN_TXFP = DISABLE;
134     CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;//CAN工作模式
135
136     /* 初始化CAN波特率 */
137     CAN_Baud_Process(500,&CAN_InitStructure);
138     CAN_Init(CAN1, &CAN_InitStructure);
```

其中配置波特率的函数是一个自定义函数，这里可以不了解，只需要知道是配置波特率即可，如果需要使用本章代码，可以查看具体的源码工程。

**C.** **配置CAN过滤器**

如下代码为配置过滤器：

```c
141     /*************************************************************/
142     /* 初始化CAN过滤器 */
143     CAN_FilterInitStructure.CAN_FilterNumber = 0;                       /* CAN1滤波器号从0到13 */
144     CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;     /* 滤波屏蔽模式 */
145     CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
146     CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
147     CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
148     CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;      /* 不屏蔽任何ID */
149     CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;           /* 不屏蔽任何ID */
150     CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
151
152     CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
153     CAN_FilterInit(&CAN_FilterInitStructure);
154
155     /*************************************************************/
156     /* 设置完CAN后，返回当前设置的CAN的端口号，此处主要类比linux socketcan中的套接口 */
```

此处我们设置过滤器不屏蔽任何报文ID，这里只是了解单片机下的一些过程。

**（3）配置CAN接收中断**

CAN总线支持发送中断和接收中断，此处仅仅使用了接收中断。

见第14章节代码“01_stm32f407_can_addline”中“can_controller.c”文件void CAN_Set_Interrupt(int can_port, pCanInterrupt callback)函数。

CAN中断配置代码如下：

```c
163 /**********************************************************************
164 * 函数名称： void CAN_Set_Interrupt(int can_port,  pCanInterrupt callback)
165 * 功能描述： 使能CAN中断处理，并传入应用的的回调函数，回调函数主要处理应用层的功能
166 * 输入参数： can_port,端口号
167 *            callback： 中断具体处理应用功能的回调函数
168 * 输出参数： 无
169 * 返 回 值： 无
170 * 修改日期             版本号        修改人           修改内容
171 * -----------------------------------------------
172 * 2020/05/13         V1.0             bert            创建
173 ***********************************************************************/
174 void CAN_Set_Interrupt(int can_port,  pCanInterrupt callback)
175 {
176     NVIC_InitTypeDef NVIC_InitStructure;
177
178     /* 根据CAN端口号配置中断 */
179     switch( can_port )
180     {
181         case CAN_PORT_CAN1:
182         {
183             /* 初始化回调接口函数 */
184             if ( NULL != callback )
185             {
186                 g_pCanInterrupt = callback;
187             }
188
189             /* 使用CAN0_RX中断，在linux socket can中类似创建接收线程 */
190             NVIC_InitStructure.NVIC_IRQChannel = CAN1_RX0_IRQn;
191             NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
192             NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
193             NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
194             NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
195             NVIC_Init(&NVIC_InitStructure);
196             CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
197         }
198         break;
199
200         default:
201             break;
202
203     }
204     return ;
205 }
```

CAN接收中断函数如下：

```c
275 /**********************************************************************
276 * 函数名称： void CAN1_RX0_IRQHandler(void)
277 * 功能描述： CAN接收中断函数
278 * 输入参数： 无
279 * 输出参数： 无
280 * 返 回 值： 无
281 * 修改日期             版本号        修改人           修改内容
282 * -----------------------------------------------
283 * 2020/05/13         V1.0             bert            创建
284 ***********************************************************************/
285 void CAN1_RX0_IRQHandler(void)
286 {
287     /* 如果回调函数存在，则执行回调函数 */
288     if( g_pCanInterrupt != NULL)
289     {
290         g_pCanInterrupt();
291     }
292
293     /* 清除挂起中断 */
294     CAN_ClearITPendingBit(CAN1,CAN_IT_FMP0);
295 }
```

此处CAN中断通过回调函数g_pCanInterrupt()函数将应用层需要的代码分层到应用层，此处为驱动部分通用接口。

**（4）CAN报文读取函数**

当CAN接收中断产生，通过CAN报文读取函数从FIFO中读取已经接收到的CAN报文。

见第14章节代码“01_stm32f407_can_addline”中“can_controller.c”文件void CAN_Read(int can_port, CanRxMsg* recv_msg)函数。

CAN报文读取函数如下：

```c
208 /**********************************************************************
209 * 函数名称： void CAN_Read(int can_port, CanRxMsg* recv_msg)
210 * 功能描述： CAN读取接收寄存器，取出接收到的报文
211 * 输入参数： can_port,端口号
212 * 输出参数： recv_msg：接收报文
213 * 返 回 值： 无
214 * 修改日期             版本号        修改人           修改内容
215 * -----------------------------------------------
216 * 2020/05/13         V1.0             bert            创建
217 ***********************************************************************/
218 void CAN_Read(int can_port, CanRxMsg* recv_msg)
219 {
220     switch( can_port )
221     {
222         case CAN_PORT_CAN1:
223         {
224             /* 从FIFO中读取CAN报文 */
225             CAN_Receive(CAN1,CAN_FIFO0, recv_msg);
226         }
227         break;
228
229         default:
230             break;
231     }
232     return ;
233 }
```

**（5）CAN报文发送函数**

当需要发送CAN报文时，通过向CAN发送邮箱填充数据，启动发送报文。

见第14章节代码“01_stm32f407_can_addline”中“can_controller.c”文件void CAN_Write(int can_port, CanTxMsg send_msg)函数。

CAN报文读取函数如下：

```c
235 /**********************************************************************
236 * 函数名称： void CAN_Write(int can_port, CanTxMsg send_msg)
237 * 功能描述： CAN报文发送接口，调用发送寄存器发送报文
238 * 输入参数： can_port,端口号
239 * 输出参数： send_msg：发送报文
240 * 返 回 值： 无
241 * 修改日期             版本号        修改人           修改内容
242 * -----------------------------------------------
243 * 2020/05/13         V1.0             bert            创建
244 ***********************************************************************/
245 void CAN_Write(int can_port, CanTxMsg send_msg)
246 {
247     unsigned char i;
248     uint8_t transmit_mailbox = 0;
249     CanTxMsg TxMessage;
250
251     switch( can_port )
252     {
253         case CAN_PORT_CAN1:
254         {
255             TxMessage.StdId = send_msg.StdId;     // 标准标识符为0x000~0x7FF
256             TxMessage.ExtId = 0x0000;             // 扩展标识符0x0000
257             TxMessage.IDE   = CAN_ID_STD;         // 使用标准标识符
258             TxMessage.RTR   = CAN_RTR_DATA;       // 设置为数据帧
259             TxMessage.DLC   = send_msg.DLC;       // 数据长度, can报文规定最大的数据长度为8字节
260
261             for(i=0; i<TxMessage.DLC; i++)
262             {
263                 TxMessage.Data[i] = send_msg.Data[i];
264             }
265             transmit_mailbox = CAN_Transmit(CAN1,&TxMessage);  /* 返回这个信息请求发送的邮箱号0,1,2或没有邮箱申请发送no_box */
266         }
267         break;
268
269         default:
270             break;
271     }
272     return ;
273 }
```

**（6）CAN抽象结构体框架初始化**

定义一个can1通信结构实例CAN_COMM_STRUCT can1_controller；

使用（1）~（5）步骤实现的函数，初始化can1_controller，构成与应用层关联的一个连接点。

```c
298 /**********************************************************************
299 * 名称：     can1_controller
300 * 功能描述： CAN1结构体初始化
301 * 修改日期             版本号        修改人           修改内容
302 * -----------------------------------------------
303 * 2020/05/13         V1.0             bert            创建
304 ***********************************************************************/
305 CAN_COMM_STRUCT can1_controller = {
306     .name                   = "can0",
307     .can_port               = CAN_PORT_CAN1,
308     .can_set_controller     = CAN_Set_Controller,
309     .can_set_interrput      = CAN_Set_Interrupt,
310     .can_read               = CAN_Read,
311     .can_write              = CAN_Write,
312 };
```

##### **12.3.2.3** **编写CAN应用层代码**

根据14.3.2.2 已经将具体的CAN硬件操作已经实现，并且已经抽象实例化了CAN编程框架。

但是我们现在还没关联到应用层，应用层并不知道调用哪个接口。

**（1）CAN应用层注册实例**

在应用层编写一个通用的实例化注册函数。

见第14章节代码“01_stm32f407_can_addline”中“app_can.c”文件int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)函数。

代码实现如下：

```c
62 /**********************************************************************
63 * 函数名称： int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)
64 * 功能描述： 应用层进行CAN1结构体注册
65 * 输入参数： p_can_controller，CAN控制器抽象结构体
66 * 输出参数： 无
67 * 返 回 值： 无
68 * 修改日期             版本号        修改人           修改内容
69 * -----------------------------------------------
70 * 2020/05/13         V1.0             bert            创建
71 ***********************************************************************/
72 int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)
73 {
74     /* 判断传入的p_can_controller为非空，目的是确认这个结构体是实体*/
75     if( p_can_controller != NULL )
76     {
77         /* 将传入的参数p_can_controller赋值给应用层结构体gCAN_COMM_STRUCT */
78
79         /*端口号，类比socketcan套接口*/
80         gCAN_COMM_STRUCT.can_port              = p_can_controller->can_port;
81         /*CAN控制器配置函数*/
82         gCAN_COMM_STRUCT.can_set_controller    = p_can_controller->can_set_controller;
83         /*CAN中断配置*/
84         gCAN_COMM_STRUCT.can_set_interrput     = p_can_controller->can_set_interrput;
85         /*CAN报文读函数*/
86         gCAN_COMM_STRUCT.can_read              = p_can_controller->can_read;
87         /*CAN报文发送函数*/
88         gCAN_COMM_STRUCT.can_write             = p_can_controller->can_write;
89         return 1;
90     }
91      return 0;
92 }
```

然后通过调用register_can_controller( &can1_controller );将实例can1_controller注册给应用的4 static CAN_COMM_STRUCT gCAN_COMM_STRUCT;

之后应用层只需要调用应用层自己的gCAN_COMM_STRUCT实例即可操作CAN通信功能。

```c
315 /**********************************************************************
316 * 函数名称： void CAN1_contoller_add(void)
317 * 功能描述： CAN结构体注册接口，应用层在使用can1_controller前调用
318 * 输入参数： 无
319 * 输出参数： 无
320 * 返 回 值： 无
321 * 修改日期             版本号        修改人           修改内容
322 * -----------------------------------------------
323 * 2020/05/13         V1.0             bert            创建
324 ***********************************************************************/
325 void CAN1_contoller_add(void)
326 {
327     /*将can1_controller传递给应用层*/
328     register_can_controller( &can1_controller );
329 }
```

**（2）CAN应用层初始化**

CAN应用层初始化代码如下；

```c
94 /**********************************************************************
95 * 函数名称： void app_can_init(void)
96 * 功能描述： CAN应用层初始化
97 * 输入参数： 无
98 * 输出参数： 无
99 * 返 回 值： 无
100 * 修改日期             版本号        修改人           修改内容
101 * -----------------------------------------------
102 * 2020/05/13         V1.0             bert            创建
103 ***********************************************************************/
104 void app_can_init(void)
105 {
106     /**
107     * 应用层进行CAN1结构体注册
108     */
109     CAN1_contoller_add();
110
111     /*
112     *调用can_set_controller进行CAN控制器配置，
113     *返回can_port，类比linux socketcan中的套接口，单片机例程中作为自定义CAN通道
114     */
115     gCAN_COMM_STRUCT.can_port = gCAN_COMM_STRUCT.can_set_controller();
116     /**
117     * 调用can_set_interrput配置CAN接收中断，类比socketcan中的接收线程
118     */
119     gCAN_COMM_STRUCT.can_set_interrput( gCAN_COMM_STRUCT.can_port, CAN_RX_IRQHandler_Callback );
120 }
```

**（3）设计一个简单的周期发送报文功能**

CAN周期发送报文的功能代码实现如下：

```c
123 /**********************************************************************
124 * 函数名称： void app_can_tx_test(void)
125 * 功能描述： CAN应用层报文发送函数，用于测试周期发送报文
126 * 输入参数： 无
127 * 输出参数： 无
128 * 返 回 值： 无
129 * 修改日期             版本号        修改人           修改内容
130 * -----------------------------------------------
131 * 2020/05/13         V1.0             bert            创建
132 ***********************************************************************/
133 void app_can_tx_test(void)
134 {
135     // 以10ms为基准，运行CAN测试程序
136
137     unsigned char i=0;
138
139     /* 发送报文定义 */
140     CanTxMsg TxMessage;
141
142     /* 发送报文中用一个字节来作为计数器 */
143     static unsigned char tx_counter = 0;
144
145     /* 以10ms为基准，通过timer计数器设置该处理函数后面运行代码的周期为1秒钟*/
146     static unsigned int timer =0;
147     if(timer++>100)
148     {
149         timer = 0;
150     }
151     else
152     {
153         return ;
154     }
155
156     /* 发送报文报文数据填充，此报文周期是1秒 */
157     TxMessage.StdId = TX_CAN_ID;          /* 标准标识符为0x000~0x7FF */
158     TxMessage.ExtId = 0x0000;             /* 扩展标识符0x0000 */
159     TxMessage.IDE   = CAN_ID_STD;         /* 使用标准标识符 */
160     TxMessage.RTR   = CAN_RTR_DATA;       /* 设置为数据帧  */
161     TxMessage.DLC   = 8;                  /* 数据长度, can报文规定最大的数据长度为8字节 */
162
163     /* 填充数据，此处可以根据实际应用填充 */
164     TxMessage.Data[0] = tx_counter++;       /* 用来识别报文发送计数器 */
165     for(i=1; i<TxMessage.DLC; i++)
166     {
167         TxMessage.Data[i] = i;
168     }
169
170     /*  调用can_write发送CAN报文 */
171     gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
172
173 }
```

**（4）设计一个简单的接收报文功能**

```c
220 /**********************************************************************
221 * 函数名称： void CAN_RX_IRQHandler_Callback(void)
222 * 功能描述： CAN1接收中断函数；在linux中可以类比用线程，或定时器去读CAN数据
223 * 输入参数： 无
224 * 输出参数： 无
225 * 返 回 值： 无
226 * 修改日期             版本号        修改人           修改内容
227 * -----------------------------------------------
228 * 2020/05/13         V1.0             bert            创建
229 ***********************************************************************/
230 void CAN_RX_IRQHandler_Callback(void)
231 {
232     /* 接收报文定义 */
233     CanRxMsg RxMessage;
234
235     /* 接收报文清零 */
236     memset( &RxMessage, 0, sizeof(CanRxMsg) );
237
238     /* 通过can_read接口读取寄存器已经接收到的报文 */
239     gCAN_COMM_STRUCT.can_read(gCAN_COMM_STRUCT.can_port, &RxMessage);
240
241     /* 将读取到的CAN报文存拷贝到全局报文结构体g_CAN1_Rx_Message */
242     memcpy(&g_CAN1_Rx_Message, &RxMessage, sizeof( CanRxMsg ) );
243
244     /* 设置当前接收完成标志，判断当前接收报文ID为RX_CAN_ID，则设置g_CAN1_Rx_Flag=1*/
245     if( g_CAN1_Rx_Message.StdId == RX_CAN_ID )
246     {
247         g_CAN1_Rx_Flag = 1;
248     }
249 }
176 /**********************************************************************
177 * 函数名称： void app_can_rx_test(void)
178 * 功能描述： CAN应用层接收报文处理函数，用于处理中断函数中接收的报文
179 * 输入参数： 无
180 * 输出参数： 无
181 * 返 回 值： 无
182 * 修改日期             版本号        修改人           修改内容
183 * -----------------------------------------------
184 * 2020/05/13         V1.0             bert            创建
185 ***********************************************************************/
186 void app_can_rx_test(void)
187 {
188     unsigned char i=0;
189
190     /* 发送报文定义 */
191     CanTxMsg TxMessage;
192
193     /* 发送报文中用一个字节来作为计数器 */
194     static unsigned char rx_counter = 0;
195
196
197     if( g_CAN1_Rx_Flag == 1)
198     {
199         g_CAN1_Rx_Flag = 0;
200
201         /* 发送报文报文数据填充，此报文周期是1秒 */
202         TxMessage.StdId = RX_TO_TX_CAN_ID;    /* 标准标识符为0x000~0x7FF */
203         TxMessage.ExtId = 0x0000;             /* 扩展标识符0x0000 */
204         TxMessage.IDE   = CAN_ID_STD;         /* 使用标准标识符 */
205         TxMessage.RTR   = CAN_RTR_DATA;       /* 设置为数据帧  */
206         TxMessage.DLC   = 8;                  /* 数据长度, can报文规定最大的数据长度为8字节 */
207
208         /* 填充数据，此处可以根据实际应用填充 */
209         TxMessage.Data[0] = rx_counter++;      /* 用来识别报文发送计数器 */
210         for(i=1; i<TxMessage.DLC; i++)
211         {
212             TxMessage.Data[i] = g_CAN1_Rx_Message.Data[i];
213         }
214
215         /*  调用can_write发送CAN报文 */
216         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
217     }
218 }
```

##### **12.3.2.4 STM32 CAN案例测试**

在前面几个章节将代码编写完成之后，我们做个测试；

测试工具使用的是：英特蓓斯的Valuecan3(CAN协议盒)，Vehicle Vspy3（电脑端软件）。

也可以在淘宝上购买便宜的USB转CAN的工具即可。

测试步骤如下：

Step1：将已经完成的STM32 CAN测试程序下载到实际开发板上；

Step2：通过CAN测试工具Vehicle Vspy3发送报文ID为0X201的报文；

Step3：观察CAN测试软件显示如下：

报文ID为0x101的报文是按照1秒周期进行发送，如图14.3.2.4-1。

报文ID为0x201的报文是Vehicle Spy3按照周期500ms发送给STM32开发板，如图14.3.2.4-1

报文ID为0x301的报文是在接收到报文ID为0x201的报文后，然后转发出报文ID为0x301的报文，如图14.3.2.4-2。



![img](https://pic4.zhimg.com/80/v2-7b4f76cf483e112e4acffd573be0d7ff_720w.webp)





图14.3.2.4-1 报文发送结果查看





![img](https://pic2.zhimg.com/80/v2-9d47419d0d4bc7f5288985a2b2545395_720w.webp)





图14.3.2.4-2 报文接收情况查看



### **12.4 Linux socketcan基础应用编程**

#### **12.4.1 socketcan概述**

 socketcan是在Linux下CAN协议(Controller Area Network)实现的一种实现方法。 CAN是一种在世界范围内广泛用于自动控制、嵌入式设备和汽车领域的网络技术。Linux下最早使用CAN的方法是基于字符设备来实现的，与之不同的是Socket CAN使用伯克利的socket接口和linux网络协议栈，这种方法使得can设备驱动可以通过网络接口来调用。Socket CAN的接口被设计的尽量接近TCP/IP的协议，让那些熟悉网络编程的程序员能够比较容易的学习和使用。

 使用Socket CAN的主要目的就是为用户空间的应用程序提供基于Linux网络层的套接字接口。与广为人知的TCP/IP协议以及以太网不同，CAN总线没有类似以太网的MAC层地址，只能用于广播。CAN ID仅仅用来进行总线的仲裁。因此CAN ID在总线上必须是唯一的。当设计一个CAN-ECU(Electronic Control Unit 电子控制单元）网络的时候，CAN报文ID可以映射到具体的ECU。因此CAN报文ID可以当作发送源的地址来使用。

#### **12.4.2 socketcan基本知识点**

 在“14.3 STM32 CAN应用编程”中我们已经完整的构建了CAN应用编程框架，但是在linux应用编程中，操作CAN底层驱动与STM32思路上相似，但是操作方法或者说调用的接口还是差异很大的，因为STM32是直接调用的SDK包或直接操作寄存器，但是linux系统是需要通过调用系统命令或linuxCAN驱动来实现物理层的操作。

因此这里我们重点介绍linux上的一些系统调用命令，和一些socketcan相关的概念。

##### **12.4.2.1 CAN设备操作**

 CAN设备有开启、关闭、设置参数3个功能。因为linux下CAN设备是模拟网络操作的方式，这里CAN设备的开启、关闭和设置，均通过ip命令来操作。

 在100ask_IMX6ULL开发板上打开串口，使用“ifconfig -a”查看所有的网络节点，发现第1个节点就是“can0”。



![img](https://pic4.zhimg.com/80/v2-b4ee1303ff905c3718319caa8d69b52b_720w.webp)



（1）Linux CAN设备开启：

```c
#define ip_cmd_open      "ifconfig can0 up"     /* 打开CAN0 */
```

说明：can0：can设备名；

up： 打开设备命令

（2）Linux CAN设备关闭：

```c
#define ip_cmd_close      "ifconfig can0 down"    /* 关闭CAN0 */
```

说明：can0：can设备名；

down： 关闭设备命令

（2）Linux CAN参数设置（波特率，采样率）：

```c
#define ip_cmd_set_can_params "ip link set can0 type can bitrate 500000 triple-sampling on"

/* 将CAN0波特率设置为500000 bps */
```

说明：can0：can设备名；

down： 关闭设备命令

Type can： 设备类型为can

Bitrate 500000： 波特率设置为500kbps

Triple-sampleing on: 采样打开

##### **12.4.2.2 什么是Socket套接口**

 在linux里网络操作使用socket进行接口创建，竟然CAN设备也是虚拟成网络接口，也是使用的socket套接口。

 如下图所示，电话A呼叫电话B，电话A会输入电话B的号码，电话B会接收到电话A的来电。

电话A和电话B是两个端点。而linux套接口与这个电话通信类似，套接口就是一个通信的端点，端点之间是通信链路；电话通信是通过电话号码进行拨号通信，而套接口是使用地址进行识别对方的。



![img](https://pic4.zhimg.com/80/v2-9c1fb66fa4717c154f4e2bc1e701e9a7_720w.webp)





图14.2.2.2 电话通信模型



##### **12.4.2.3 Socket接口函数**

我们要创建并使用socket套接口进行通信编程，就需要了解一下socket相关的接口函数。

需要查询linux系统里的函数，可以通过man命令查看。

举例：

man socket / *查看socket函数描述* /

**（1）socket()函数**

在linux系统下，通过“man socket”命令，查询socket()函数描述如下：



![img](https://pic3.zhimg.com/80/v2-580c7f43bcf23f5f2b571c80ccdba372_720w.webp)



Socket函数原型如下：

```c
#include <sys/types.h>     

#include <sys/socket.h>

int socket(int domain, int type, int protocol);  /* 套接口函数原型 */
```

函数三个参数如下:

![img](https://pic3.zhimg.com/80/v2-9fc9c3cc403d82959ebe9b3554265492_720w.webp)

注意：

 1.并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。

 当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。

 2. Socketcan使用的domain协议域是AF_CAN(或PF_CAN)，type类型是SOCK_RAW, 指定协议protocol是CAN_RAW.

**（2）bind()函数**

 在linux系统下，通过“man bind”命令，查询bind()函数描述如下：



![img](https://pic3.zhimg.com/80/v2-b49376905923072b0eaa13b162f8e24e_720w.webp)



 bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。

 Bind函数原型如下所示：

```c
#include <sys/types.h>          
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
```

函数的三个参数分别为：

**sockfd**：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。

**addr**：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，

如ipv4对应的是：

```c
struct sockaddr_in {
    sa_family_t    sin_family;   /* address family: AF_INET */
    in_port_t      sin_port;    /* port in network byte order */
    struct in_addr sin_addr;     /* internet address */
};
/* Internet address. */struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};
```

ipv6对应的是：

```c
struct sockaddr_in6 { 
    sa_family_t     sin6_family;   /* AF_INET6 */ 
    in_port_t       sin6_port;     /* port number */ 
    uint32_t        sin6_flowinfo; /* IPv6 flow information */ 
    struct in6_addr  sin6_addr;     /* IPv6 address */ 
    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ 
};
struct in6_addr { 
    unsigned char   s6_addr[16];   /* IPv6 address */ 
};
```

Unix域对应的是：

```c
#define UNIX_PATH_MAX  108
struct sockaddr_un { 
  sa_family_t sun_family;        /* AF_UNIX */ 
  char    sun_path[UNIX_PATH_MAX]; /* pathname */ 
};
```

CAN域对应的是：

在文件“Linux-4.9.88\include\uapi\linux\can.h”中有定义，这个是本章需要重点了解的。

```c
/**
 * struct sockaddr_can - CAN sockets的地址结构
 * @can_family:  地址协议族 AF_CAN.
 * @can_ifindex:  CAN网络接口索引
 * @can_addr:    协议地址信息
 */
struct sockaddr_can {
    __kernel_sa_family_t can_family;
    int         can_ifindex;
    union {
        /* 传输协议类地址信息 (e.g. ISOTP) */
        struct { canid_t rx_id, tx_id; } tp;

        /* 预留给将来使用的CAN协议地址信息*/
    } can_addr;
};
```

**addrlen**：对应的是地址的长度。

通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。

**（3）ioctl()函数**

在linux系统下，通过“man ioctl”命令，查询ioctl()函数描述如下：



![img](https://pic2.zhimg.com/80/v2-d24b95020c7cef4b50f4725bfd6c6015_720w.webp)



Ioctl()函数调用层次如下图所示：



![img](https://pic1.zhimg.com/80/v2-6b0e9cd1482607ac62013a75261a77d8_720w.webp)



Ioctl()函数原型如下：

```c
#include <sys/ioctl.h>
int ioctl(int fd, unsigned long request, ...);
```

用ioctl获得本地网络接口地址时要用到两个结构体ifconf和ifreq。

**struct ifreq定义** ifreq用来保存某个接口的信息。

在文件“Linux-4.9.88\include\uapi\linux\if.h”中有定义struct ifreq，这个只需要了解是在ioctl()函数调用时用来获取CAN设备索引（ifr_ifindex）使用，其他的参数可以不用关注。

```c
/*
 * Interface request structure used for socket
 * ioctl's.  All interface ioctl's must have parameter
 * definitions which begin with ifr_name.  The
 * remainder may be interface specific.
 */

/* for compatibility with glibc net/if.h */
#if __UAPI_DEF_IF_IFREQ
struct ifreq {
#define IFHWADDRLEN 6
    union
    {
        char    ifrn_name[IFNAMSIZ];        /* if name, e.g. "en0" */
    } ifr_ifrn;

    union {
        struct  sockaddr ifru_addr;
        struct  sockaddr ifru_dstaddr;
        struct  sockaddr ifru_broadaddr;
        struct  sockaddr ifru_netmask;
        struct  sockaddr ifru_hwaddr;
        short   ifru_flags;
        int ifru_ivalue;
        int ifru_mtu;
        struct  ifmap ifru_map;
        char    ifru_slave[IFNAMSIZ];   /* Just fits the size */
        char    ifru_newname[IFNAMSIZ];
        void __user *   ifru_data;
        struct  if_settings ifru_settings;
    } ifr_ifru;
};
#endif /* __UAPI_DEF_IF_IFREQ */

#define ifr_name    ifr_ifrn.ifrn_name  /* interface name   */
#define ifr_hwaddr  ifr_ifru.ifru_hwaddr    /* MAC address      */
#define ifr_addr    ifr_ifru.ifru_addr  /* address      */
#define ifr_dstaddr ifr_ifru.ifru_dstaddr   /* other end of p-p lnk */
#define ifr_broadaddr   ifr_ifru.ifru_broadaddr /* broadcast address    */
#define ifr_netmask ifr_ifru.ifru_netmask   /* interface net mask   */
#define ifr_flags   ifr_ifru.ifru_flags /* flags        */
#define ifr_metric  ifr_ifru.ifru_ivalue    /* metric       */
#define ifr_mtu     ifr_ifru.ifru_mtu   /* mtu          */
#define ifr_map     ifr_ifru.ifru_map   /* device map       */
#define ifr_slave   ifr_ifru.ifru_slave /* slave device     */
#define ifr_data    ifr_ifru.ifru_data  /* for use by interface */
#define ifr_ifindex ifr_ifru.ifru_ivalue    /* interface index  */
#define ifr_bandwidth   ifr_ifru.ifru_ivalue    /* link bandwidth   */
#define ifr_qlen    ifr_ifru.ifru_ivalue    /* Queue length     */
#define ifr_newname ifr_ifru.ifru_newname   /* New name     */
#define ifr_settings    ifr_ifru.ifru_settings  /* Device/proto settings*/
```

**struct ifconf定义** ifconf通常是用来保存所有接口信息的，本章节未使用到，在此不作详细介绍。

**（4）setsockopt()函数**

 在linux系统下，通过“man setsockopt”命令，查询setsockopt()函数描述如下：



![img](https://pic1.zhimg.com/80/v2-c1b20d8481c975a1867dca400f798400_720w.webp)



setsockopt()和getsockopt函数原型如下：

```c
#include <sys/types.h>    
#include <sys/socket.h>
int getsockopt(int sockfd, int level, int optname,void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
```

Setsockopt()用于任意类型、任意状态[套接口](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%8F%A3/10058888)的设置选项值。尽管在不同协议层上存在选项，但本函数仅定义了最高的“套接口”层次上的选项。

其函数参数如下：可以看出其参数

![img](https://pic3.zhimg.com/80/v2-70022ec30790b4014da40b6adb3f5fd2_720w.webp)

函数调用示例如下：

![img](https://pic2.zhimg.com/80/v2-e63d61539245c4a666fbd18031865b65_720w.webp)

![img](https://pic3.zhimg.com/80/v2-1816eb307dc1c36d3e7874b08233d32e_720w.webp)

**（5）write()函数**

在linux系统下，通过“man 2 write”命令，查询write()函数描述如下：



![img](https://pic2.zhimg.com/80/v2-2924b32ac3ea12e3af9d04f787eb5fcd_720w.webp)



Write函数原型如下：

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

**（6）read()函数**

在linux系统下，通过“man 2 read”命令，查询read()函数描述如下：



![img](https://pic2.zhimg.com/80/v2-f3d3e30048968f5c07886c1d1898f145_720w.webp)



Read函数原型如下：

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```

**（7）close()函数**

在linux系统下，通过“man 2 close”命令，查询close()函数描述如下：



![img](https://pic1.zhimg.com/80/v2-0960fa918e4fbc787493ab1c4a3d3314_720w.webp)



close()函数原型如下：

```c
#include <unistd.h>
int close(int fd);
```

#### **12.4.3 socket_can简单发送实例**

简单发送实例代码目录：“02_socketcan_send”

案例描述：

1. 实现周期1秒发送报文ID：0x101的报文；

**了解内容：IMX6 CAN接口电路**

从下面CAN外围电路看，和STM32是完全相同的，只是处理内部的CAN控制器因为不同芯片制造厂家的不同，会有一些较小的差异。这里电路只是对比了解一下，做linux应用可以不需要关注底层驱动处理。



![img](https://pic1.zhimg.com/80/v2-4cab1120cdcf4fdabd60fb1de1d77b64_720w.webp)



那我们现在按照14.3章节构建STM32下CAN应用编程的框架，一步一步编写linux下socketCAN的应用编程。

**准备工作：**

我们按照14.3章节准备好can应用的代码文件：

![img](https://pic1.zhimg.com/80/v2-9c110b20e032a47e1da10c8881902d4c_720w.webp)

##### **12.4.3.1** **编写抽象框架的实现函数**

首先我们使用14.3章节已经构建好的抽象结构体，如下：

见第14章节代码“02_socketcan_send_addline”中“can_controller.h”。

```c
34 /* CAN通信抽象结构体定义*/
35 typedef struct _CAN_COMM_STRUCT
36 {
37     /* CAN硬件名称 */
38     char *name;
39     /* CAN端口号，裸机里为端口号;linux应用里作为socket套接口 */
40     int  can_port;                                
41     /* CAN控制器配置函数，返回端口号赋值给can_port */
42     int  (*can_set_controller)( void );                  
43     /* CAN接口中断创建，在linux中对应创建接收线程 */
44     void (*can_set_interrput)( int can_port , pCanInterrupt callback );             
45     /* CAN读取报文接口 */
46     void (*can_read)( int can_port , CanRxMsg* recv_msg);   
47     /* CAN发送报文接口*/
48     void (*can_write)( int can_port , CanTxMsg send_msg);   
49 }CAN_COMM_STRUCT, *pCAN_COMM_STRUCT;
50
```

我们就按照这个结构体的顺序依次编写can_controller.c中的CAN驱动操作具体实现函数。

**（1）定义CAN设备**

根据14.4.2.1章节描述，linux应用层操作CAN设备，需要知道设备名。.

在100ask_IMX6ULL开发板上打开串口，使用“ifconfig -a”命令查看，知道当前CAN设备名称为”can0”。

直接在linux命令行直接使用ip命令可以打开，设置，和关闭CAN设备，因此我们定义了三个宏ip_cmd_open, ip_cmd_close,ip_cmd_set_can_params, 这三个宏可以通过系统调用system()进行执行。

见第14章节代码“02_socketcan_send_addline”中“can_controller.c”文件中宏定义。

```c
29 /**************宏定义**************************************************/
30 
31 /* 将CAN0波特率设置为500000 bps */
32 #define ip_cmd_set_can_params  "ip link set can0 type can bitrate 500000 triple-sampling on"
33 
34 /* 打开CAN0 */
35 #define ip_cmd_open            "ifconfig can0 up"     
36 
37 /* 关闭CAN0 */    
38 #define ip_cmd_close           "ifconfig can0 down"
```

**（2）配置CAN控制器**

配置CAN控制器有3个部分：打开can0设备，CAN波特率配置，CAN过滤器配置。

见第14章节代码“01_stm32f407_can_addline”中“can_controller.c”文件int CAN_Set_Controller( void )函数。

**A.配置波特率，打开can0设备**

使用（1）中的三个命令ip_cmd_open, ip_cmd_close,ip_cmd_set_can_params,通过system系统调用：具体代码如下

```c
77     /* 通过system调用ip命令设置CAN波特率 */
78     system(ip_cmd_close);               
79     system(ip_cmd_set_can_params);
80     system(ip_cmd_open);
```

**B.创建套接口**

因为linux应用操作设备均使用读read写write操作，linux一切皆文件，而socketcan又是一个特殊的文件，因此我们需要调用socket()函数创建一个socketcan接口，获取sock_fd描述符。

具体代码如下：

```c
82   /*************************************************************/
83   /* 创建套接口 sock_fd */
84   sock_fd = socket(AF_CAN, SOCK_RAW, CAN_RAW);
85  if(sock_fd < 0)
86  {
87      perror("socket create error!\n");
88      return -1;
89  }
```

**C.绑定can0设备与套接口**

具体代码如下：

```c
92   //将套接字与 can0 绑定
93   strcpy(ifr.ifr_name, "can0");
94  ioctl(sock_fd, SIOCGIFINDEX,&ifr); // 设置设备为can0
95 
96  ifr.ifr_ifindex = if_nametoindex(ifr.ifr_name);
97  printf("ifr_name:%s \n",ifr.ifr_name);
98  printf("can_ifindex:%d \n",ifr.ifr_ifindex);
99 
100 addr.can_family = AF_CAN;
101 addr.can_ifindex = ifr.ifr_ifindex;
102         
103 if( bind(sock_fd, (struct sockaddr *)&addr, sizeof(addr)) < 0 )
104 {
105     perror("bind error!\n");
106     return -1;
107 }
```

**C.配置过滤器**

具体代码如下：

```c
109     /*************************************************************/
110     //禁用过滤规则，本进程不接收报文，只负责发送
111  setsockopt(sock_fd, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
```

**D.配置非阻塞操作**

Linux系统调用read和write函数有阻塞和非阻塞，我们在周期调用时，此采用非阻塞方式对CAN报文进行读写操作。

具体代码实现如下：

```c
114     //设置read()和write()函数设置为非堵塞方式
115     int flags;
116     flags = fcntl(sock_fd, F_GETFL);
117     flags |= O_NONBLOCK;
118     fcntl(sock_fd, F_SETFL, flags);
```

**E.返回sock_fd套接口**

具体代码实现如下：

int CAN_Set_Controller( void )函数直接结束后，返回值赋值给CAN_COMM_STRUCT的can_port成员。

后续应用层所访问的sock_fd描述符即为can_port.

**（3）创建CAN接收线程**

在STM32中，接收使用的接收FIFO中断进行处理，在linux应用中，我们则采用线程轮询去读取报文。

因此我们需要创建一个CAN接收线程，具体代码实现如下：

```c
127 /**********************************************************************
128 * 函数名称： void CAN_Set_Interrupt(int can_port,  pCanInterrupt callback)
129 * 功能描述： 创建CAN接收线程，并传入应用的的回调函数，回调函数主要处理应用层的功能
130 * 输入参数： can_port,端口号
131 *          callback： 中断具体处理应用功能的回调函数
132 * 输出参数： 无
133 * 返 回 值： 无
134 * 修改日期             版本号        修改人           修改内容
135 * -----------------------------------------------
136 * 2020/05/13         V1.0             bert            创建
137 ***********************************************************************/
138 void CAN_Set_Interrupt(int can_port,  pCanInterrupt callback)
139 {
140     int err;
141     
142     if ( NULL != callback ) 
143     {
144         g_pCanInterrupt = callback;
145     }
146     
147     err = pthread_create(&ntid, NULL,CAN1_RX0_IRQHandler, NULL );
148     if( err !=0 )
149     {
150         printf("create thread fail! \n");
151         return ;
152     }
153     printf("create thread success!\n");
154     
155 
156     return ;
157 }
```

创建后的线程函数如下所示：

CAN1_RX0_IRQHandler是一个CAN接收线程函数，与CAN接收中断功能相似，只这里采用轮询方式读取CAN报文。

```c
253 /**********************************************************************
254 * 函数名称： void CAN1_RX0_IRQHandler(void)
255 * 功能描述： CAN接收线程函数
256 * 输入参数： 无  
257 * 输出参数： 无
258 * 返 回 值： 无
259 * 修改日期             版本号        修改人           修改内容
260 * -----------------------------------------------
261 * 2020/05/13         V1.0             bert            创建
262 ***********************************************************************/
263 void *CAN1_RX0_IRQHandler(void *arg)
264 {
265     /* 接收报文定义 */
266     while( 1 )
267     {
268     /* 如果回调函数存在，则执行回调函数 */
269         if( g_pCanInterrupt != NULL)
270         {
271             g_pCanInterrupt();
272         }
273         usleep(10000);
274     }
275 }
```

**（4）CAN报文读取函数**

```c
161 /**********************************************************************
162 * 函数名称： void CAN_Read(int can_port, CanRxMsg* recv_msg)
163 * 功能描述： CAN读取接收寄存器，取出接收到的报文
164 * 输入参数： can_port,端口号     
165 * 输出参数： recv_msg：接收报文
166 * 返 回 值： 无
167 * 修改日期             版本号        修改人           修改内容
168 * -----------------------------------------------
169 * 2020/05/13         V1.0             bert            创建
170 ***********************************************************************/
171 void CAN_Read(int can_port, CanRxMsg* recv_msg)
172 { 
173     unsigned char i;
174     static unsigned int rxcounter =0;
175     
176     int nbytes;
177     struct can_frame rxframe;
178     
179     
180     nbytes = read(can_port, &rxframe, sizeof(struct can_frame));
181     if(nbytes>0)
182     {
183         printf("nbytes = %d \n",nbytes );
184         
185         recv_msg->StdId = rxframe.can_id;
186         recv_msg->DLC = rxframe.can_dlc;
187         memcpy( recv_msg->Data, &rxframe.data[0], rxframe.can_dlc);
188         
189         rxcounter++;
190         printf("rxcounter=%d, ID=%03X, DLC=%d, data=%02X %02X %02X %02X %02X %02X %02X %02X \n",  \
191             rxcounter,
192             rxframe.can_id, rxframe.can_dlc,  \
193             rxframe.data[0],\
194             rxframe.data[1],\
195             rxframe.data[2],\
196             rxframe.data[3],\
197             rxframe.data[4],\
198             rxframe.data[5],\
199             rxframe.data[6],\
200             rxframe.data[7] );
201     }
202 
203     return ;
204 }
205
```

**（5）CAN报文发送函数**

```c
206 /**********************************************************************
207 * 函数名称： void CAN_Write(int can_port, CanTxMsg send_msg)
208 * 功能描述： CAN报文发送接口，调用发送寄存器发送报文
209 * 输入参数： can_port,端口号     
210 * 输出参数： send_msg：发送报文
211 * 返 回 值： 无
212 * 修改日期             版本号        修改人           修改内容
213 * -----------------------------------------------
214 * 2020/05/13         V1.0             bert            创建
215 ***********************************************************************/
216 void CAN_Write(int can_port, CanTxMsg send_msg)
217 {
218     unsigned char i;
219     static unsigned int txcounter=0;
220     int nbytes;
221     
222     struct can_frame txframe;
223     
224     txframe.can_id = send_msg.StdId;
225     txframe.can_dlc = send_msg.DLC;
226     memcpy(&txframe.data[0], &send_msg.Data[0], txframe.can_dlc);
227 
228     nbytes = write(can_port, &txframe, sizeof(struct can_frame)); //发送 frame[0]
229     
230     if(nbytes == sizeof(txframe))
231     {
232         txcounter++;
233         printf("txcounter=%d, ID=%03X, DLC=%d, data=%02X %02X %02X %02X %02X %02X %02X %02X \n",  \
234             txcounter,
235             txframe.can_id, txframe.can_dlc,  \
236             txframe.data[0],\
237             txframe.data[1],\
238             txframe.data[2],\
239             txframe.data[3],\
240             txframe.data[4],\
241             txframe.data[5],\
242             txframe.data[6],\
243             txframe.data[7] );
244     }
245     else
246     {
247         //printf("Send Error frame[0], nbytes=%d\n!",nbytes);
248     }
249 
250     return ;
251 }
252
```

**（6）CAN抽象结构体框架初始化**

与14.3章节STM32定义实例类似。

定义一个can1通信结构实例CAN_COMM_STRUCT can1_controller；

使用（1）~（5）步骤实现的函数，初始化can1_controller，构成与应用层关联的一个连接点。

```c
298 /**********************************************************************
299 * 名称：     can1_controller
300 * 功能描述： CAN1结构体初始化
301 * 修改日期             版本号        修改人           修改内容
302 * -----------------------------------------------
303 * 2020/05/13         V1.0             bert            创建
304 ***********************************************************************/
305 CAN_COMM_STRUCT can1_controller = {
306     .name                   = "can0",
307     .can_port               = CAN_PORT_CAN1,
308     .can_set_controller     = CAN_Set_Controller,
309     .can_set_interrput      = CAN_Set_Interrupt,
310     .can_read               = CAN_Read,
311     .can_write              = CAN_Write,
312 };
```

##### **12.4.3.2 编写应用层代码**

根据14.4.3.1 已经将具体的linux下socketCAN硬件操作已经实现，并且已经抽象实例化了CAN编程框架。

但是我们现在还没关联到应用层，应用层并不知道调用哪个接口。

**（1）CAN应用层注册实例**

在应用层编写一个通用的实例化注册函数。

见第14章节代码“02_socketcan_send_addline”中“app_can.c”文件int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)函数。

代码实现如下：（和STM32应用编程完全一样，代码几乎不用更改）

```c
73 /**********************************************************************
74 * 函数名称： int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)
75 * 功能描述： 应用层进行CAN1结构体注册
76 * 输入参数： p_can_controller，CAN控制器抽象结构体
77 * 输出参数： 无
78 * 返 回 值： 无
79 * 修改日期             版本号        修改人           修改内容
80 * -----------------------------------------------
81 * 2020/05/13         V1.0             bert            创建
82 ***********************************************************************/
83 int register_can_controller(const pCAN_COMM_STRUCT p_can_controller)
84 {
85     /* 判断传入的p_can_controller为非空，目的是确认这个结构体是实体*/
86     if( p_can_controller != NULL )
87     {
88         /* 将传入的参数p_can_controller赋值给应用层结构体gCAN_COMM_STRUCT */
89         
90         /*端口号，类比socketcan套接口*/
91         gCAN_COMM_STRUCT.can_port              = p_can_controller->can_port; 
92         /*CAN控制器配置函数*/
93         gCAN_COMM_STRUCT.can_set_controller    = p_can_controller->can_set_controller; 
94         /*CAN中断配置*/
95         gCAN_COMM_STRUCT.can_set_interrput     = p_can_controller->can_set_interrput;
96         /*CAN报文读函数*/
97         gCAN_COMM_STRUCT.can_read              = p_can_controller->can_read;
98         /*CAN报文发送函数*/
99         gCAN_COMM_STRUCT.can_write             = p_can_controller->can_write;
100         return 1;
101     }
102     return 0;
103 }
```

**（2）CAN应用层初始化**

CAN应用层代码初始化如下：（和STM32 CAN应用代码完全一样）

```c
105 /**********************************************************************
106 * 函数名称： void app_can_init(void)
107 * 功能描述： CAN应用层初始化
108 * 输入参数： 无
109 * 输出参数： 无
110 * 返 回 值： 无
111 * 修改日期             版本号        修改人           修改内容
112 * -----------------------------------------------
113 * 2020/05/13         V1.0             bert            创建
114 ***********************************************************************/
115 void app_can_init(void)
116 {
117     /** 
118     * 应用层进行CAN1结构体注册
119     */
120     CAN1_contoller_add();
121     
122     /*
123     *调用can_set_controller进行CAN控制器配置，
124     *返回can_port，类比linux socketcan中的套接口，单片机例程中作为自定义CAN通道 
125     */
126     gCAN_COMM_STRUCT.can_port = gCAN_COMM_STRUCT.can_set_controller();
127     /** 
128     * 调用can_set_interrput配置CAN接收中断，类比socketcan中的接收线程，本例不用接收，因此回调函数传入NULL
129     */
130     gCAN_COMM_STRUCT.can_set_interrput( gCAN_COMM_STRUCT.can_port, NULL );
131 }
```

**（3）设计一个简单的周期发送报文功能**

我们需要先设计一个在10ms周期函数中调用的void app_can_tx_test(void)功能函数，这个函数在main主线程函数中进行调用。

CAN周期发送报文的功能函数代码实现如下：

```c
134 /**********************************************************************
135 * 函数名称： void app_can_tx_test(void)
136 * 功能描述： CAN应用层报文发送函数，用于测试周期发送报文
137 * 输入参数： 无
138 * 输出参数： 无
139 * 返 回 值： 无
140 * 修改日期             版本号        修改人           修改内容
141 * -----------------------------------------------
142 * 2020/05/13         V1.0             bert            创建
143 ***********************************************************************/
144 void app_can_tx_test(void)
145 {
146     // 以10ms为基准，运行CAN测试程序
147     
148     unsigned char i=0;
149     
150     /* 发送报文定义 */
151     CanTxMsg TxMessage;
152     
153     /* 发送报文中用一个字节来作为计数器 */
154     static unsigned char tx_counter = 0;
155     
156     /* 以10ms为基准，通过timer计数器设置该处理函数后面运行代码的周期为1秒钟*/  
157     static unsigned int timer =0;
158     if(timer++>100)
159     {
160         timer = 0;
161     }
162     else
163     {
164         return ;
165     }
166     
167     /* 发送报文报文数据填充，此报文周期是1秒 */
168     TxMessage.StdId = TX_CAN_ID;          /* 标准标识符为0x000~0x7FF */
169     TxMessage.ExtId = 0x0000;             /* 扩展标识符0x0000 */
170     TxMessage.IDE   = CAN_ID_STD;         /* 使用标准标识符 */
171     TxMessage.RTR   = CAN_RTR_DATA;       /* 设置为数据帧  */
172     TxMessage.DLC   = 8;                  /* 数据长度, can报文规定最大的数据长度为8字节 */
173     
174     /* 填充数据，此处可以根据实际应用填充 */
175     TxMessage.Data[0] = tx_counter++;       /* 用来识别报文发送计数器 */
176     for(i=1; i<TxMessage.DLC; i++)
177     {
178         TxMessage.Data[i] = i;            
179     }
180     
181     /*  调用can_write发送CAN报文 */
182     gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
183     
184 }
185
```

然后将void app_can_tx_test(void)函数加入到main函数中，进行10ms周期执行，其代码实现如下：

```c
188 /**********************************************************************
189 * 函数名称： int main(int argc, char **argv)
190 * 功能描述： 主函数
191 * 输入参数： 无
192 * 输出参数： 无
193 * 返 回 值： 无
194 * 修改日期             版本号        修改人           修改内容
195 * -----------------------------------------------
196 * 2020/05/13         V1.0             bert            创建
197 ***********************************************************************/
198 int main(int argc, char **argv)
199 {
200     /* CAN应用层初始化 */
201     app_can_init();
202     
203     while(1)
204     {
205         /* CAN应用层周期发送报文 */
206         app_can_tx_test();
207         
208         /* 利用linux的延时函数设计10ms的运行基准 */
209         usleep(10000);
210     }
211 }
```

##### **12.4.3.3 案例测试验证**

当我们上面代码完成编写后，目录文件如下：



![img](https://pic4.zhimg.com/80/v2-73bb47b19786e8ee3d4d742d1eb2703f_720w.webp)



**（1）编写Makfile**

Makefile文件内容如下：

```c
all:
    arm-linux-gnueabihf-gcc -lpthread -o socketcan_send   can_controller.c  app_can.c
clean:
    rm socketcan_send
```

**（2）编译socket_send**

注意：编译是在100ask-vmware_ubuntu18.04虚拟机环境中。

进入ubuntu虚拟机对应的socket_send目录下



![img](https://pic4.zhimg.com/80/v2-2ed8008aa5477b601932aa19c7de8993_720w.webp)



输入make命令：



![img](https://pic3.zhimg.com/80/v2-3f931f3ad2b87d8c49c04edec564905e_720w.webp)



通过make命令编译后，生成socket_send可执行文件。

**（3）运行socket_send**

注意：运行在100ask_imx6开发板上运行。

此处使用的是nfs文件进行运行。

先给100ask_imx6ull开发板上电，打开串口：



![img](https://pic1.zhimg.com/80/v2-5e41b6aeb6bfbaed6ec2edeb23c2547c_720w.webp)



输入root用户登录进入开发板linux系统；

然后挂载nfs，操作如下：

```c
Mount -t nfs -o nolock 192.168.1.100:/home/book  /mnt
```



![img](https://pic4.zhimg.com/80/v2-4e3616d66252cb84559696df310eca73_720w.webp)



注意：目前我的开发板IP：192.168.1.101， Ubuntu虚拟机是192.168.1.100.

然后再运行./socketcan_send

如果运行时提示权限不允许，可以使用chmod命令设置权限:

```c
Chmod 777 socketcan_send
```

运行后串口查看打印信息如下：



![img](https://pic2.zhimg.com/80/v2-7758063ff2ca125b0c24ea53d7b8483d_720w.webp)



然后再观察Vehcile Spy3上位机测试结果如下：

报文按照时间1S的周期性发送报文ID为0x101的CAN报文。



![img](https://pic4.zhimg.com/80/v2-eda8604f200680c02f86e114bcafadbb_720w.webp)



**（4）测试总结**

到此为止，我们已经通过socketcan建立起来了linux下应用编程的框架，并且成功的调试成功了CAN周期发送报文的功能编程。

后面将基于此框架，一步一步的了解linux下CAN应用编程；

对于相关案例章节的目的设置如下：

![img](https://pic4.zhimg.com/80/v2-91906c3e68e6444428f3441c2bd1fe47_720w.webp)

#### **12.4.4 socket_can 简单接收实例**

简单接收实例代码目录：“03_socketcan_recv”

我们在14.4.3章节已经了解了发送报文发送的功能，而且已经建立起了linux下应用编程的框架；本节重点了解简单接收功能。

案例描述：

1.实现接收报文0x201的报文。

##### **12.4.4.1 编写抽象框架的实现函数**

**（1）定义CAN设备**

参考“14.4.3.1 编写抽象框架的实现函数”中“（1）定义CAN设备”描述。

**（2）配置CAN控制器**

参考“14.4.3.1 编写抽象框架的实现函数”中“（2）配置CAN控制器”描述。

因为在“14.4.3.1”中我们只发送，并且设置了过滤器为禁止所有报文。具体代码如下：

```c
109 /*************************************************************/
110 //禁用过滤规则，本进程不接收报文，只负责发送
111 setsockopt(sock_fd, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
```

而本案例需要配置接收，过滤器配置会有相应差异，我们目前是配置仅仅接收报文ID为0x201的报文，

具体实现代码如下：

```c
110     //定义接收规则，只接收表示符等于 0x201 的报文
111     struct can_filter rfilter[1];
112     rfilter[0].can_id = 0x201;
113     rfilter[0].can_mask = CAN_SFF_MASK;
114     //设置过滤规则
115     setsockopt(sock_fd, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter));
```

作为扩展，我们也可以设置多个过滤器：

定义过滤器：

```c
struct can_filter rfilter[5];  /*定义10个过滤器*/
rfilter[0].can_id = 0x201;
rfilter[0].can_mask = 0x7FF;  /*过滤规则：can_id & mask = 0x201 & 0x7FF = 0x201*/
rfilter[1].can_id = 0x302;
rfilter[1].can_mask = 0x7FF;  /*过滤规则：can_id & mask = 0x302& 0x7FF = 0x302*/
rfilter[2].can_id = 0x403;
rfilter[2].can_mask = 0x7FF;  /*过滤规则：can_id & mask = 0x403& 0x7FF = 0x403*/
rfilter[3].can_id = 0x504;
rfilter[3].can_mask = 0x700;  /*过滤规则：can_id & mask = 0x504 & 0x700 = 0x500,即接收报文ID为0x5**的报文*/
rfilter[3].can_id = 0x605;
rfilter[3].can_mask = 0x700;  /*过滤规则：can_id & mask = 0x504 & 0x700 = 0x600*/
setsockopt(sock_fd, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter));
```

**（3）创建CAN接收线程**

参考“14.4.3.1 编写抽象框架的实现函数”中“（3）创建CAN接收线程”描述。

**（4）CAN报文读取函数**

参考“14.4.3.1 编写抽象框架的实现函数”中“（4）CAN报文读取函数”描述。

**（5）CAN报文发送函数**

参考“14.4.3.1 编写抽象框架的实现函数”中“（5）CAN报文发送函数”描述。

**（6）CAN抽象结构体框架初始化**

参考“14.4.3.1 编写抽象框架的实现函数”中“（6）CAN抽象结构体框架初始化”描述。

##### **12.4.4.2** **编写应用层代码**

**（1）CAN应用层注册实例**

参考“14.4.3.2 编写应用层代码”中“（1）CAN应用层注册实例”描述。

**（2）CAN应用层初始化**

在本简单接收实例中，我们需要将接收线程里的回调指针函数CAN_RX_IRQHandler_Callback传入，在这个函数里，应用层可以自行进行读取CAN报文等处理。

```c
105 /**********************************************************************
106 * 函数名称： void app_can_init(void)
107 * 功能描述： CAN应用层初始化
108 * 输入参数： 无
109 * 输出参数： 无
110 * 返 回 值： 无
111 * 修改日期             版本号        修改人           修改内容
112 * -----------------------------------------------
113 * 2020/05/13         V1.0             bert            创建
114 ***********************************************************************/
115 void app_can_init(void)
116 {
117     /** 
118     * 应用层进行CAN1结构体注册
119     */
120     CAN1_contoller_add();
121     
122     /*
123     *调用can_set_controller进行CAN控制器配置，
124     *返回can_port，类比linux socketcan中的套接口，单片机例程中作为自定义CAN通道 
125     */
126     gCAN_COMM_STRUCT.can_port = gCAN_COMM_STRUCT.can_set_controller();
127     /** 
128     * 调用can_set_interrput配置CAN接收中断，类比socketcan中的接收线程
129     */
130     gCAN_COMM_STRUCT.can_set_interrput( gCAN_COMM_STRUCT.can_port, CAN_RX_IRQHandler_Callback );
131 }
```

**（3）设计一个简单的接收报文功能**

关于void CAN_RX_IRQHandler_Callback(void)的具体实现如下所示：

CAN_RX_IRQHandler_Callback是在接收线程中循环执行，应用层在CAN_RX_IRQHandler_Callback函数进行gCAN_COMM_STRUCT.can_read读取CAN报文。

```c
133 /**********************************************************************
134 * 函数名称： void CAN_RX_IRQHandler_Callback(void)
135 * 功能描述： CAN1接收中断函数；在linux中可以类比用线程，或定时器去读CAN数据
136 * 输入参数： 无
137 * 输出参数： 无
138 * 返 回 值： 无
139 * 修改日期             版本号        修改人           修改内容
140 * -----------------------------------------------
141 * 2020/05/13         V1.0             bert            创建
142 ***********************************************************************/
143 void CAN_RX_IRQHandler_Callback(void)
144 {
145     /* 接收报文定义 */
146     CanRxMsg RxMessage; 
147     
148     /* 接收报文清零 */
149     memset( &RxMessage, 0, sizeof(CanRxMsg) );
150    
151     /* 通过can_read接口读取寄存器已经接收到的报文 */
152     gCAN_COMM_STRUCT.can_read(gCAN_COMM_STRUCT.can_port, &RxMessage);
153 
154     /* 将读取到的CAN报文存拷贝到全局报文结构体g_CAN1_Rx_Message */
155     memcpy(&g_CAN1_Rx_Message, &RxMessage, sizeof( CanRxMsg ) );
156     
157 }
```

本案例无发送报文功能，主线程中无代码处理，只需要空跑运行即可。

```c
159 /**********************************************************************
160 * 函数名称： int main(int argc, char **argv)
161 * 功能描述： 主函数
162 * 输入参数： 无
163 * 输出参数： 无
164 * 返 回 值： 无
165 * 修改日期             版本号        修改人           修改内容
166 * -----------------------------------------------
167 * 2020/05/13         V1.0             bert            创建
168 ***********************************************************************/
169 int main(int argc, char **argv)
170 {
171     /* CAN应用层初始化 */
172     app_can_init();
173     
174     while(1)
175     {        
176         /* 利用linux的延时函数设计10ms的运行基准 */
177         usleep(10000);
178     }
179 }
180
```

##### **12.4.4.3** **案例测试验证**

**（1）编写Makfile**

Makefile文件内容如下：

```c
all:

   arm-linux-gnueabihf-gcc -lpthread -o socketcan_recv  can_controller.c app_can.c

clean:

   rm socketcan_recv
```

**（2）编译socket_recv**

注意：编译是在100ask-vmware_ubuntu18.04虚拟机环境中。

进入ubuntu虚拟机对应的socket_recv目录下，执行make all进行编译。

编译过程如下：



![img](https://pic1.zhimg.com/80/v2-6ad7c9a955dc1cb63ecb9306feee7adc_720w.webp)



**（3）运行socket_recv**

注意：运行在100ask_imx6开发板上运行。

此处使用的是nfs文件进行运行。

Nfs挂载，请参考“14.4,3.3 案例测试验证”。

在100ask_imx6开发板环境下，执行“./socket_recv”,运行程序；

然后通过Vhicle Spy3向100ask_imx6开发板CAN端发送报文ID未0x201的报文，报文trace如下：



![img](https://pic4.zhimg.com/80/v2-e5eadb386d02b558693f0b84574f240f_720w.webp)



100ask_imx6开发板串口打印信息如下：



![img](https://pic2.zhimg.com/80/v2-bab091e37d1a04c50fa3ee9c2ca832cd_720w.webp)



**（4）测试总结**

到此为止，我们已经调试成功了CAN报文接收的功能编程。

#### **12.4.5 socket_can 接收和发送实例**

简单接收实例代码目录：“04_socketcan_recv_send”

本案例整合了“14.4.3 简单发送实例”和“14.4.3 简单接收实例”，构建成一个发送和接收均有的组合案例。

案例描述：

1. 实现周期1秒发送报文ID：0x101的报文；
2. 实现接收报文0x201的报文，并将内容复制到报文0x301的报文，并发送出去；

##### **12.4.5.1 编写抽象框架的实现函数**

**（1）定义CAN设备**

参考“14.4.3.1 编写抽象框架的实现函数”中“（1）定义CAN设备”描述。

参考“14.4.4.1 编写抽象框架的实现函数”中“（1）定义CAN设备”描述。

**（2）配置CAN控制器**

参考“14.4.3.1 编写抽象框架的实现函数”中“（2）配置CAN控制器”描述。

参考“14.4.4.1 编写抽象框架的实现函数”中“（2）配置CAN控制器”描述。

**（3）创建CAN接收线程**

参考“14.4.3.1 编写抽象框架的实现函数”中“（3）创建CAN接收线程”描述。

参考“14.4.4.1 编写抽象框架的实现函数”中“（3）创建CAN接收线程”描述。

**（4）CAN报文读取函数**

参考“14.4.3.1 编写抽象框架的实现函数”中“（4）CAN报文读取函数”描述。

参考“14.4.4.1 编写抽象框架的实现函数”中“（4）CAN报文读取函数”描述。

**（5）CAN报文发送函数**

参考“14.4.3.1 编写抽象框架的实现函数”中“（5）CAN报文发送函数”描述。

参考“14.4.4.1 编写抽象框架的实现函数”中“（5）CAN报文发送函数”描述。

**（6）CAN抽象结构体框架初始化**

参考“14.4.3.1 编写抽象框架的实现函数”中“（6）CAN抽象结构体框架初始化”描述。

参考“14.4.4.1 编写抽象框架的实现函数”中“（6）CAN抽象结构体框架初始化”描述。

##### **12.4.5.2** **编写应用层代码**

**（1）CAN应用层注册实例**

参考“14.4.3.2 编写应用层代码”中“（1）CAN应用层注册实例”描述。

参考“14.4.4.2 编写应用层代码”中“（1）CAN应用层注册实例”描述。

**（2）CAN应用层初始化**

参考“14.4.4.2 编写应用层代码”中“（2）CAN应用层初始化”描述。

**（3）设计一个简单的周期发送报文功能**

参考“14.4.3.2 编写应用层代码”中“（3）设计一个简单的发送报文功能”描述。

**（4）设计一个简单的周期接收报文功能**

参考“14.4.4.2 编写应用层代码”中“（3）设计一个简单的接收报文功能”描述。

 同时，我们此处需要将接收到的ID:0X201的报文，将内容复制给报文ID：0x301的报文，并发送出去。

我们在“14.4.4 简单接收报文”的基础上增加一个简单的逻辑，在接收线程的回调函数CAN_RX_IRQHandler_Callback中，调用gCAN_COMM_STRUCT.can_read(gCAN_COMM_STRUCT.can_port, &RxMessage);接收到报文ID：0x201的报文后，设置标志g_CAN1_Rx_Flag = 1; 然后去主线程去判断此标志是否被设置为1，标识已经接收到，则在void app_can_rx_test(void)中去拷贝报文ID:0X201的报文内容，然后赋值给报文ID:0x301的报文。

接收线程回调函数CAN_RX_IRQHandler_Callback的实现代码如下：

```c
231 /**********************************************************************
232 * 函数名称： void CAN_RX_IRQHandler_Callback(void)
233 * 功能描述： CAN1接收中断函数；在linux中可以类比用线程，或定时器去读CAN数据
234 * 输入参数： 无
235 * 输出参数： 无
236 * 返 回 值： 无
237 * 修改日期             版本号        修改人           修改内容
238 * -----------------------------------------------
239 * 2020/05/13         V1.0             bert            创建
240 ***********************************************************************/
241 void CAN_RX_IRQHandler_Callback(void)
242 {
243     /* 接收报文定义 */
244     CanRxMsg RxMessage; 
245     
246     /* 接收报文清零 */
247     memset( &RxMessage, 0, sizeof(CanRxMsg) );
248    
249     /* 通过can_read接口读取寄存器已经接收到的报文 */
250     gCAN_COMM_STRUCT.can_read(gCAN_COMM_STRUCT.can_port, &RxMessage);
251 
252     /* 将读取到的CAN报文存拷贝到全局报文结构体g_CAN1_Rx_Message */
253     memcpy(&g_CAN1_Rx_Message, &RxMessage, sizeof( CanRxMsg ) );
254     
255     /* 设置当前接收完成标志，判断当前接收报文ID为RX_CAN_ID，则设置g_CAN1_Rx_Flag=1*/
256     if( g_CAN1_Rx_Message.StdId == RX_CAN_ID )
257     {
258         g_CAN1_Rx_Flag = 1;  
259     }
260 }
```

主线程中app_can_rx_test的接收触发处理函数代码如下：

```c
187 /**********************************************************************
188 * 函数名称： void app_can_rx_test(void)
189 * 功能描述： CAN应用层接收报文处理函数，用于处理中断函数中接收的报文
190 * 输入参数： 无
191 * 输出参数： 无
192 * 返 回 值： 无
193 * 修改日期             版本号        修改人           修改内容
194 * -----------------------------------------------
195 * 2020/05/13         V1.0             bert            创建
196 ***********************************************************************/
197 void app_can_rx_test(void)
198 {
199     unsigned char i=0;
200     
201     /* 发送报文定义 */
202     CanTxMsg TxMessage;
203     
204     /* 发送报文中用一个字节来作为计数器 */
205     static unsigned char rx_counter = 0;
206     
207     
208     if( g_CAN1_Rx_Flag == 1)
209     {
210         g_CAN1_Rx_Flag = 0;
211         
212         /* 发送报文报文数据填充，此报文周期是1秒 */
213         TxMessage.StdId = RX_TO_TX_CAN_ID;    /* 标准标识符为0x000~0x7FF */
214         TxMessage.ExtId = 0x0000;             /* 扩展标识符0x0000 */
215         TxMessage.IDE   = CAN_ID_STD;         /* 使用标准标识符 */
216         TxMessage.RTR   = CAN_RTR_DATA;       /* 设置为数据帧  */
217         TxMessage.DLC   = 8;                  /* 数据长度, can报文规定最大的数据长度为8字节 */
218         
219         /* 填充数据，此处可以根据实际应用填充 */
220         TxMessage.Data[0] = rx_counter++;      /* 用来识别报文发送计数器 */
221         for(i=1; i<TxMessage.DLC; i++)
222         {
223             TxMessage.Data[i] = g_CAN1_Rx_Message.Data[i];            
224         }
225         
226         /*  调用can_write发送CAN报文 */
227         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
228     }
229 }
```

##### **12.4.5.3** **案例测试验证**

**（1）编写Makfile**

Makefile文件容如下：

```c
all:

   arm-linux-gnueabihf-gcc -lpthread -o socketcan_recv_send  can_controller.c app_can.c

clean:

   rm socketcan_recv_send
```

**（2）编译socket_recv_send**

注意：编译是在100ask-vmware_ubuntu18.04虚拟机环境中。

进入ubuntu虚拟机对应的socket_send目录下，执行make all进行编译。

编译过程如下：



![img](https://pic1.zhimg.com/80/v2-1be65dc8ae6fe2e6a07a1428a02add50_720w.webp)



**（3）运行socket_recv_send**

注意：运行在100ask_imx6开发板上运行。

此处使用的是nfs文件进行运行。

Nfs挂载，请参考“14.4,3.3 案例测试验证”。

在100ask_imx6开发板环境下，执行“./socket_recv_send”,运行程序；

然后通过Vhicle Spy3向100ask_imx6开发板CAN端发送报文ID未0x201的报文，报文trace如下：



![img](https://pic4.zhimg.com/80/v2-bdebf109106138e8c32cebfd4f8341cb_720w.webp)



然后观察100ask_imx6开发串口打印信息如下：



![img](https://pic2.zhimg.com/80/v2-bab091e37d1a04c50fa3ee9c2ca832cd_720w.webp)



**（4）测试总结**

到此为止，我们已经调试成功了CAN报文接收和发送的功能编程。

### **12.5** **汽车行业CAN总线应用**

#### **12.5.1** **车厂CAN总线需求**

CAN总线应用最广泛的应该是汽车领域，几乎所有的车均支持CAN总线，在这里就简单介绍一些汽车相关的CAN总线需求。

##### **12.5.1.1** **网络拓扑结构**

下面这张网络拓扑图和我开发过的大部分实际车辆拓扑大致一致。一般是汽车厂商提供给零部件供应商的。

如下图所示：



![img](https://pic1.zhimg.com/80/v2-7362b001e73147c354d7d63d20cf0738_720w.webp)





图14.5.1 整车网络拓扑



一般车身网络分为如下6个局域CAN网络：

![img](https://pic2.zhimg.com/80/v2-0c8fc2e8107092c05b571b13590fa20d_720w.webp)



##### **12.5.1.2 CAN 报文分类**

在汽车CAN网络里面，CAN报文主要分为三种：应用报文，网络报文，和诊断报文。

不论是网络报文，还是诊断报文，均是按照不同的功能需求划分的，根据不同的需求，制定CAN报文数据的不同协议。

**（1）CAN应用报文**

CAN应用报文，主要用于车身网络中不同ECU节点之间的数据信息的发送和接收，与具体应用功能相关；

汽车CAN应用报文，由车厂进行定义和发布“信号矩阵表（excel格式）”和“信号矩阵（DBC格式）”。

详见“14.5.2 CAN应用报文应用分析及实例”。

**（2）CAN网络管理报文**

汽车电子系统通过车载网络对所有的ECU 进行配置管理和协调工作的过程称之为网络管理。

网络管理可以通过对于网络上的各个 ECU 的控制，发出一些命令规则，实现各个 ECU 的协同睡眠和唤醒，用于协同控制的CAN报文，就是网络管理报文。

网络管理有OSEK网络管理和AUTOSAR网络管理两种。一般前装车厂项目才会要求支持网络管理。

**（3）CAN诊断报文**

CAN诊断主要是是实现车辆的功能监控，故障检测，记录/存储故障信息，存储/读取数据，还有EOL下线检测，ECU升级等功能。

基于CAN的通信分层模型：

![img](https://pic2.zhimg.com/80/v2-f77846e1db47624af9aca8ddb113312d_720w.webp)



![img](https://pic3.zhimg.com/80/v2-f2d0246ac2e9af5cf6fe80a925f06f66_720w.webp)





图 CAN诊断服务OSI模型



#### **12.5.2 CAN 应用报文应用分析及实例**

##### **12.5.2.1 CAN 应用报文定义**

当一个车厂项目启动之后，根据项目的需求，车厂会提供CAN信号矩阵（excel），和DBC信号矩阵数据库。

**（1）CAN信号矩阵-excel格式**

车厂提供的信号矩阵（excel）的文件格式，详见第14章代码目录：CAN_Signal_Matrix.xlsx，

从CAN_Signal_Matrix.xlsx中截取报文定义，如下所示：

ECU_TX_MSG1: (周期发送报文，ID：0x123）



![img](https://pic2.zhimg.com/80/v2-39fe77d5c5e85ebe144fc1cd8461fc65_720w.webp)



ECU_TX_MSG2: (事件发送报文，ID：0x124）



![img](https://pic1.zhimg.com/80/v2-0706242bc5a21e4e116e440cfb01d438_720w.webp)



ECU_TX_MSG3: (周期&事件发送报文，ID：0x125）



![img](https://pic4.zhimg.com/80/v2-06c7e4cb39b837285f8e5124fd34d14b_720w.webp)



ECU_RX_MSG1:(事件接收报文，ID: 0X201)



![img](https://pic1.zhimg.com/80/v2-dda6c2c682a3ef91928567cc0c2e6e80_720w.webp)



 从上报文定义可以看出，车厂会定义报文的很多属性，如报文名称，报文ID,报文长度, 报文周期，报文发送类型， 以及报文中的信号名称，信号起始字节，信号长度，排列格式（Intel或Motorala），信号的取值范围，信号的发送方式等等。

（2）CAN信号矩阵-DBC

本章提供的示例CAN矩阵“CAN_Signal_Matrix.xlsx”对应的DBC文件，该DBC文件使用vector CANdb+ Editor编辑；如下图所示为DBC文件所显示的报文信息内容，和excel表格所展示内容是一致的，文件格式不是最关键的，只要理解车厂对CAN信号的要求即可。



![img](https://pic1.zhimg.com/80/v2-2bdaace98e58c52a708bec8d6a0e4fd0_720w.webp)





图 CAN信号矩阵DBC



##### 12.5.2.2 CAN应用报文发送规则

 我们提到车厂会提供CAN信号矩阵表，会定义周期报文，事件报文，周期事件混合报文，那么定义这些信号的通用规则在哪里？一般车厂会提供关于CAN总线的通信规范，车厂根据通信规范才定义出CAN信号矩阵。

 下面是某车厂的通信规范《XXX Communication Requirement Specification.pdf》，其规范目录如下图所示，从目录可以看出，主要介绍CAN物理层，数据链路层，通信交互层等相关规则。

 本小节，我们主要介绍应用报文相关的通信交互层“4 Interaction Layer”相关的内容：CAN报文发送类型（Message Send Type）。



![img](https://pic2.zhimg.com/80/v2-d2c544bae6cc41d755a3c7c68ed5c60d_720w.webp)



CAN报文发送类型按照之前矩阵表展示的逐一介绍如下：

**（1）周期型报文（Cyclic Message）**

周期报文，即为周期定时发送，周期为T。

如下图所示：



![img](https://pic4.zhimg.com/80/v2-47d609edabd2c8efeb218a1ddd42a907_720w.webp)



当系统运行后，ECU就按照周期T定时发送CAN报文。

**（2）事件型报文（Event Message）**

触发事件时发送事件型消息，如下图所示：



![img](https://pic3.zhimg.com/80/v2-11cc65e0abb7de153ec949bc2b130ec6_720w.webp)



当系统运行后，ECU并不主动发送事件型报文，而是当ECU被某一条件触发（Event），则ECU会连续发送三帧事件报文。

当然车厂要求不仅仅如此，车厂还会有更多其他要求，

比如，

要求1,：触发发送三帧报文后，要求信号恢复为默认值；

要求2：触发发送三帧，帧与帧间间隔要求50ms;

**（3）周期事件型报文（Cyclic And Event Message）**

 周期事件混合型报文（简称CE），当无事件触发的情况下，按照周期T定时发送报文，当有事件触发的情况下，按照event事件触发方式发送报文。

如下图所示：



![img](https://pic4.zhimg.com/80/v2-49607bf33ff825092a8f2632ebcb2cf7_720w.webp)



实际车厂定义的CAN报文发送类型并不仅仅是上面三种，但是这三种是最重要的发送方式。

##### 12.5.2.3 汽车CAN应用报文发送应用实例

通过上一小节的描述，我们已经了解了车厂规范中三个应用报文发送类型，现在我们就开始在100ask_imx6开发板上进行试验，实现车厂应用报文的需求。

关于linux socketcan的应用编程框架我们已经在“14.4 linux socketcan基础应用编程”详细讲解了，我们现在就基于“14.4.5 socketcan接收和发送实例”进行本章案例应用编程，重点侧重于app_can.c编程，can_controller.c可以完全沿用。

以下应用编程，我们使用14.5.2.1中介绍的CAN报文矩阵中的CAN报文。

**（1）linux can编程框架准备**

使用案例“04_socketcan_recv_send”代码，复制文件夹改名为“06_socketcan_ecu_application”。

在app_can.c文件中定义报文ID:

```c
30 /**************宏定义**************************************************/
31 /* 本例程中测试周期发送的CAN报文ID */
32 #define TX_CAN_CYCLIC_ID    0X123
33 #define TX_CAN_EVENT_ID     0X124
34 #define TX_CAN_CE_ID        0X125
35 
36 /* 本例程中测试接收的CAN报文ID */
37 #define RX_CAN_ID           0x201
```

**（2）周期型报文实现**

实现功能：

A.编程实现周期发送报文ID:0x123， 周期T为1000ms。

代码实现如下：

```c
136 /**********************************************************************
137 * 函数名称： void app_can_cyclicmsg_test(void)
138 * 功能描述： CAN应用层测试发送周期型报文(ID:0X123)
139 * 输入参数： 无
140 * 输出参数： 无
141 * 返 回 值： 无
142 * 修改日期             版本号        修改人           修改内容
143 * -----------------------------------------------
144 * 2020/05/13         V1.0             bert            创建
145 ***********************************************************************/
146 void app_can_cyclicmsg_test(void)
147 {
148     // 以10ms为基准，运行CAN测试程序
149     
150     unsigned char i=0;
151     
152     /* 发送报文定义 */
153     CanTxMsg TxMessage;
154     
155     /* 发送报文中用一个字节来作为计数器 */
156     static unsigned char tx_counter = 0;
157     
158     /* 以10ms为基准，通过timer计数器设置该处理函数后面运行代码的周期为1秒钟*/  
159     static unsigned int timer =0;
160     if(timer++>100)
161     {
162         timer = 0;
163     }
164     else
165     {
166         return ;
167     }
168     
169     /* 发送报文报文数据填充，此报文周期是1秒 */
170     TxMessage.StdId = TX_CAN_CYCLIC_ID;   /* 标准标识符为0x000~0x7FF */
171     TxMessage.ExtId = 0x0000;             /* 扩展标识符0x0000 */
172     TxMessage.IDE   = CAN_ID_STD;         /* 使用标准标识符 */
173     TxMessage.RTR   = CAN_RTR_DATA;       /* 设置为数据帧  */
174     TxMessage.DLC   = 8;                  /* 数据长度, can报文规定最大的数据长度为8字节 */
175     
176     /* 填充数据，此处可以根据实际应用填充 */
177     TxMessage.Data[0] = tx_counter++;       /* 用来识别报文发送计数器 */
178     for(i=1; i<TxMessage.DLC; i++)
179     {
180         TxMessage.Data[i] = i;            
181     }
182     
183     /*  调用can_write发送CAN报文 */
184     gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
185     
186 }
```

**（3）事件型报文实现**

实现功能：

A. 编程实现当接收到一帧报文（ID：0x201）的信号ECU_RX_MSG1_signal1=1时，触发发送事件型报文（ID:0x124），让ECU_MSG2_signal2（Byte1字节）=2 且两帧报文间时间间隔为50ms。

B. 事件触发条件：接收到报文(ID:0x201)，且ECU_RX_MSG1_signal1（Byte0字节bit0）为1

代码实现如下：

```c
188 /**********************************************************************
189 * 函数名称： void app_can_eventmsg_test(void)
190 * 功能描述： CAN应用层测试发送事件型报文(ID:0X124)
191 * 输入参数： 无
192 * 输出参数： 无
193 * 返 回 值： 无
194 * 修改日期             版本号        修改人           修改内容
195 * -----------------------------------------------
196 * 2020/05/13         V1.0             bert            创建
197 ***********************************************************************/
198 void app_can_eventmsg_test(void)
199 {
200     unsigned char i=0;
201 
202     /* 发送报文中用一个字节来作为事件触发计数器 */
203     static unsigned char tx_counter = 0;
204 
205     /* 发送报文定义 */
206     CanTxMsg TxMessage;
207 
208     if( g_CAN1_Rx_Event_Flag == 1 )
209     {
210     g_CAN1_Rx_Event_Flag = 0;
211     printf("Message:0x124 is Triggered!\n");
212 
213         /* 发送报文报文数据填充，此报文周期是1秒 */
214         TxMessage.StdId = TX_CAN_EVENT_ID;    /* 标准标识符为0x000~0x7FF */
215         TxMessage.ExtId = 0x0000;             /* 扩展标识符0x0000 */
216         TxMessage.IDE   = CAN_ID_STD;         /* 使用标准标识符 */
217         TxMessage.RTR   = CAN_RTR_DATA;       /* 设置为数据帧  */
218         TxMessage.DLC   = 8;                  /* 数据长度, can报文规定最大的数据长度为8字节 */
219         
220         /* 填充数据，此处可以根据实际应用填充 */
221         for(i=0; i<TxMessage.DLC; i++)
222         {
223             TxMessage.Data[i] = 0x00;            
224         }
225         /* 填充数据，此处可以根据实际应用填充 */
226     tx_counter = 0;
227     
228     /*更新第1帧数据*/
229     TxMessage.Data[1] = 0x02;
230     TxMessage.Data[7] = (++tx_counter);
231         /*  调用can_write发送CAN报文，第1帧 */
232         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
233     /*延时50ms,作为事件报文间隔*/
234     usleep(50000);
235 
236     /*更新第2帧数据*/
237     TxMessage.Data[1] = 0x02;
238     TxMessage.Data[7] = (++tx_counter);
239     /*  调用can_write发送CAN报文，第2帧 */
240         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
241     /*延时50ms,作为事件报文间隔*/
242     usleep(50000);
243 
244     /*更新第3帧数据*/
245     TxMessage.Data[1] = 0x02;
246     TxMessage.Data[7] = (++tx_counter);
247     /*  调用can_write发送CAN报文，第3帧 */
248         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
249     /*延时50ms,作为事件报文间隔*/
250     usleep(50000);
251     }
252 }
```

**（4）周期事件型报文实现**

实现功能：

A. 编程实现周期发送报文（ID：0x125）；

B. 而当接收到一帧报文（ID：0x201）的信号ECU_RX_MSG1_signal2=1时，触发发送周期事件型报文（ID:0x125）， 让ECU_MSG3_signal9（Byte1字节bit0）=1，且连续发送三帧，且两帧报文间时间间隔为50ms，三帧发送完成后恢复成ECU_MSG3_signal5=0；

A. 事件触发条件：接收到报文(ID:0x201)，且ECU_RX_MSG1_signal2（Byte0字节bit1）为1

代码实现如下：

```c
255 /**********************************************************************
256 * 函数名称： void app_can_cycliceventmsg_test(void)
257 * 功能描述： CAN应用层测试发送周期事件混合报文(ID:0X125)
258 * 输入参数： 无
259 * 输出参数： 无
260 * 返 回 值： 无
261 * 修改日期             版本号        修改人           修改内容
262 * -----------------------------------------------
263 * 2020/05/13         V1.0             bert            创建
264 ***********************************************************************/
265 void app_can_cycliceventmsg_test(void)
266 {
267     unsigned char i=0;
268     
269     /* 发送报文定义 */
270     CanTxMsg TxMessage;
271     
272     /* 发送报文中用一个字节来作为事件触发计数器 */
273     static unsigned char tx_counter = 0;
274 
275     /* 以10ms为基准，通过timer计数器设置该处理函数后面运行代码的周期为1秒钟*/  
276     static unsigned int timer =0;
277 
278     if( g_CAN1_Rx_CE_Flag == 1)
279     {
280     g_CAN1_Rx_CE_Flag = 0;
281     printf("Message:0x125 is Triggered!\n");
282 
283     /* 发送报文报文数据填充，此报文周期是1秒 */
284         TxMessage.StdId = TX_CAN_CE_ID;      /* 标准标识符为0x000~0x7FF */
285         TxMessage.ExtId = 0x0000;             /* 扩展标识符0x0000 */
286         TxMessage.IDE   = CAN_ID_STD;         /* 使用标准标识符 */
287         TxMessage.RTR   = CAN_RTR_DATA;       /* 设置为数据帧  */
288         TxMessage.DLC   = 8;                  /* 数据长度, can报文规定最大的数据长度为8字节 */
289         
290         /* 清零数据区 */
291         for(i=0; i<TxMessage.DLC; i++)
292         {
293             TxMessage.Data[i] = 0x00;            
294         }
295     /* 填充数据，此处可以根据实际应用填充 */
296     tx_counter = 0;
297 
298         /*更新第1帧数据*/
299     TxMessage.Data[1] = 0x01;
300     TxMessage.Data[7] = (++tx_counter);
301         /*  调用can_write发送CAN报文，第1帧 */
302         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
303     /*延时50ms,作为事件报文间隔*/
304     usleep(50000);
305 
306     /*更新第2帧数据*/
307     TxMessage.Data[1] = 0x01;
308     TxMessage.Data[7] = (++tx_counter);
309     /*  调用can_write发送CAN报文，第2帧 */
310         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
311     /*延时50ms,作为事件报文间隔*/
312     usleep(50000);
313 
314     /*更新第3帧数据*/
315     TxMessage.Data[1] = 0x01;
316     TxMessage.Data[7] = (++tx_counter);
317     /*  调用can_write发送CAN报文，第3帧 */
318         gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
319     /*延时50ms,作为事件报文间隔*/
320     usleep(50000);
321     }
322 
323     /* 以10ms为基准，通过timer计数器设置该处理函数后面运行代码的周期为1秒钟*/  
324     if(timer++>100)
325     {
326         timer = 0;
327     }
328     else
329     {
330         return ;
331     }
332 
333     /* 发送报文报文数据填充，此报文周期是1秒 */
334     TxMessage.StdId = TX_CAN_CE_ID;   /* 标准标识符为0x000~0x7FF */
335     TxMessage.ExtId = 0x0000;             /* 扩展标识符0x0000 */
336     TxMessage.IDE   = CAN_ID_STD;         /* 使用标准标识符 */
337     TxMessage.RTR   = CAN_RTR_DATA;       /* 设置为数据帧  */
338     TxMessage.DLC   = 8;                  /* 数据长度, can报文规定最大的数据长度为8字节 */
339         
340     /* 填充数据，此处可以根据实际应用填充 */
341     for(i=1; i<TxMessage.DLC; i++)
342     {
343     TxMessage.Data[i] = 0x00;            
344     }
345      
346     /*  调用can_write发送CAN报文 */
347     gCAN_COMM_STRUCT.can_write(gCAN_COMM_STRUCT.can_port, TxMessage);
348 }
```

**（4）案例测试**

**第一步：测试周期报文**

运行socket_ecu_test，串口打印信息如下所示：



![img](https://pic3.zhimg.com/80/v2-cae0c9c9b4ac2cf4fb7ac4b9f1372d16_720w.webp)



然后观察Vehicle Spy3软件获取的报文trace，如下所示：

报文ID:0x123,0x125两个报文均以1000ms的周期发送报文；



![img](https://pic3.zhimg.com/80/v2-588345fcf6e89c596a24e9f077c35fe6_720w.webp)



**第二步：测试事件型报文**

在Vehicle Spy3软件上Messages里面过滤出报文ID:0X201,0X124.

然后手动点击右侧的Tx Panel上的ID:0X201的报文，左侧Messages的记录为100ask_imx6开发板发出3帧ID:0x124的报文。

通过开发板串口打印信息看出：“Message:0x124 is Triggered!”,在这条打印信息之后，存在三帧ID:0x124的报文。



![img](https://pic3.zhimg.com/80/v2-ab9175878cfea0eed3a6cc131a82123a_720w.webp)



观察出左侧的Messages的trace如下图所示：



![img](https://pic3.zhimg.com/80/v2-7c61cdd5109b14a08063bb448e9d37de_720w.webp)



**第三步：测试周期事件型报文**

在Vehicle Spy3软件上Messages里面过滤出报文ID:0X201,0X125.

然后手动点击右侧的Tx Panel上的ID:0X201的报文，左侧Messages的记录为100ask_imx6开发板发出3帧ID:0x125的报文，但是报文数据与默认数据不同，数据内容Byte7依次为0x01,0x02,0x03。

通过开发板串口打印信息看出：“Message:0x125 is Triggered!”,在这条打印信息之后，存在三帧ID:0x124的报文。



![img](https://pic4.zhimg.com/80/v2-8eef988896d49cbd4b53119cd2940f57_720w.webp)



观察出左侧的Messages的trace如下图所示：

ID:0X125正常情况下以1000ms的周期发送默认报文，当ID:201的报文触发事件，引起ID:0X125发送事件报文。

**（5）事件报文发送改进**

通过前面步骤，我们已经了解应用报文的发送类型和实现不同发送类型的方式，但是上面事件处理有一个缺陷，就是当事件触发时，发送时通过ucsleep()函数实现的报文间隔，这个延时会使得周期报文的周期变长，这个可以通过观察CAN报文trace查找到。

这里对案例“06_socketcan_ecu_application”做了一个小小的改进，对触发事件的处理采用周期计数来实现，具体请查看案例代码“07_socketcan_ecu_application_new”。



![img](https://pic1.zhimg.com/80/v2-873170a7fe435dcf44a429b548c2de8c_720w.webp)





# Makefile

## 1 Makefile介绍

make命令执行时，需要一个Makefile文件，以告诉make命令需要怎么样的去编译和链接程序。

首先，我们用一个示例来说明Makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：

1. 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。
2. 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。
3. 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。

只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。

### 1.1 Makefile的规则

在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。

```
target ... : prerequisites ...
    recipe
    ...
    ...
```

- target

  可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。

- prerequisites

  生成该target所依赖的文件和/或target。

- recipe

  该target要执行的命令（任意的shell命令）。

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:

```
prerequisites中如果有一个以上的文件比target文件要新的话，recipe所定义的命令就会被执行。
```

这就是Makefile的规则，也就是Makefile中最核心的内容。

说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile 的主线和核心，但要写好一个Makefile还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。:)

### 1.2 一个示例

正如前面所说，如果一个工程有3个头文件和8个C文件，为了完成前面所述的那三个规则，我们的Makefile 应该是下面的这个样子的。

```
edit : main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o

main.o : main.c defs.h
    cc -c main.c
kbd.o : kbd.c defs.h command.h
    cc -c kbd.c
command.o : command.c defs.h command.h
    cc -c command.c
display.o : display.c defs.h buffer.h
    cc -c display.c
insert.o : insert.c defs.h buffer.h
    cc -c insert.c
search.o : search.c defs.h buffer.h
    cc -c search.c
files.o : files.c defs.h buffer.h command.h
    cc -c files.c
utils.o : utils.c defs.h
    cc -c utils.c
clean :
    rm edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
```

反斜杠（ `\` ）是换行符的意思。这样比较便于Makefile的阅读。我们可以把这个内容保存在名字为“Makefile”或“Makefile”的文件中，然后在该目录下直接输入命令 `make` 就可以生成执行文件edit。如果要删除可执行文件和所有的中间目标文件，那么，只要简单地执行一下 `make clean` 就可以了。

在这个Makefile中，目标文件（target）包含：可执行文件edit和中间目标文件（ `*.o` ），依赖文件（prerequisites）就是冒号后面的那些 `.c` 文件和 `.h` 文件。每一个 `.o` 文件都有一组依赖文件，而这些 `.o` 文件又是可执行文件 `edit` 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。

在定义好依赖关系后，后续的recipe行定义了如何生成目标文件的操作系统命令，一定要以一个 `Tab` 键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。

这里要说明一点的是， `clean` 不是一个文件，它只不过是一个动作名字，有点像C语言中的label一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一个Makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。

### 1.3 make是如何工作的

在默认的方式下，也就是我们只输入 `make` 命令。那么，

1. make会在当前目录下找名字叫“Makefile”或“Makefile”的文件。
2. 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
3. 如果edit文件不存在，或是edit所依赖的后面的 `.o` 文件的文件修改时间要比 `edit` 这个文件新，那么，他就会执行后面所定义的命令来生成 `edit` 这个文件。
4. 如果 `edit` 所依赖的 `.o` 文件也不存在，那么make会在当前文件中找目标为 `.o` 文件的依赖性，如果找到则再根据那一个规则生成 `.o` 文件。（这有点像一个堆栈的过程）
5. 当然，你的C文件和头文件是存在的啦，于是make会生成 `.o` 文件，然后再用 `.o` 文件生成make的终极任务，也就是可执行文件 `edit` 了。

这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。

通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令—— `make clean` ，以此来清除所有的目标文件，以便重编译。

于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 `file.c` ，那么根据我们的依赖性，我们的目标 `file.o` 会被重编译（也就是在这个依性关系后面所定义的命令），于是 `file.o` 的文件也是最新的啦，于是 `file.o` 的文件修改时间要比 `edit` 要新，所以 `edit` 也会被重新链接了（详见 `edit` 目标文件后定义的命令）。

而如果我们改变了 `command.h` ，那么， `kdb.o` 、 `command.o` 和 `files.o` 都会被重编译，并且， `edit` 会被重链接。

### 1.4 Makefile中使用变量

在上面的例子中，先让我们看看edit的规则：

```
edit : main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
```

我们可以看到 `.o` 文件的字符串被重复了两次，如果我们的工程需要加入一个新的 `.o` 文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的Makefile并不复杂，所以在两个地方加也不累，但如果Makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了Makefile的易维护，在Makefile中我们可以使用变量。Makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。

比如，我们声明一个变量，叫 `objects` ， `OBJECTS` ， `objs` ， `OBJS` ， `obj` 或是 `OBJ` ，反正不管什么啦，只要能够表示obj文件就行了。我们在Makefile一开始就这样定义：

```
objects = main.o kbd.o command.o display.o \
     insert.o search.o files.o utils.o
```

于是，我们就可以很方便地在我们的Makefile中以 `$(objects)` 的方式来使用这个变量了，于是我们的改良版Makefile就变成下面这个样子：

```
objects = main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)
main.o : main.c defs.h
    cc -c main.c
kbd.o : kbd.c defs.h command.h
    cc -c kbd.c
command.o : command.c defs.h command.h
    cc -c command.c
display.o : display.c defs.h buffer.h
    cc -c display.c
insert.o : insert.c defs.h buffer.h
    cc -c insert.c
search.o : search.c defs.h buffer.h
    cc -c search.c
files.o : files.c defs.h buffer.h command.h
    cc -c files.c
utils.o : utils.c defs.h
    cc -c utils.c
clean :
    rm edit $(objects)
```

于是如果有新的 `.o` 文件加入，我们只需简单地修改一下 `objects` 变量就可以了。

关于变量更多的话题，我会在后续给你一一道来。

### 1.5 让make自动推导

GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 `.o` 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。

只要make看到一个 `.o` 文件，它就会自动的把 `.c` 文件加在依赖关系中，如果make找到一个 `whatever.o` ，那么 `whatever.c` 就会是 `whatever.o` 的依赖文件。并且 `cc -c whatever.c` 也会被推导出来，于是，我们的Makefile再也不用写得这么复杂。我们的新Makefile又出炉了。

```
objects = main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
    rm edit $(objects)
```

这种方法就是make的“隐式规则”。上面文件内容中， `.PHONY` 表示 `clean` 是个伪目标文件。

关于更为详细的“隐式规则”和“伪目标文件”，我会在后续给你一一道来。

### 1.6 Makefile的另一种风格

既然我们的make可以自动推导命令，那么我看到那堆 `.o` 和 `.h` 的依赖就有点不爽，那么多的重复的 `.h` ，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的Makefile吧。

```
objects = main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h

.PHONY : clean
clean :
    rm edit $(objects)
```

这里 `defs.h` 是所有目标文件的依赖文件， `command.h` 和 `buffer.h` 是对应目标文件的依赖文件。

这种风格能让我们的Makefile变得很短，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的 `.o` 文件，那就理不清楚了。

### 1.7 清空目录的规则

每个Makefile中都应该写一个清空目标文件（ `.o` ）和可执行文件的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：

```
clean:
    rm edit $(objects)
```

更为稳健的做法是：

```
.PHONY : clean
clean :
    -rm edit $(objects)
```

前面说过， `.PHONY` 表示 `clean` 是一个“伪目标”。而在 `rm` 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， `clean` 的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。

上面就是一个Makefile的概貌，也是Makefile的基础，下面还有很多Makefile的相关细节，准备好了吗？准备好了就来。

### 1.8 Makefile里有什么？

Makefile里主要包含了五个东西：显式规则、隐式规则、变量定义、指令和注释。

1. 显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。
2. 隐式规则。由于我们的make有自动推导的功能，所以隐式规则可以让我们比较简略地书写Makefile，这是由make所支持的。
3. 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
4. 指令。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。
5. 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 `#` 字符，这个就像C/C++中的 `//` 一样。如果你要在你的Makefile中使用 `#` 字符，可以用反斜杠进行转义，如： `\#` 。

最后，还值得一提的是，在Makefile中的命令，必须要以 `Tab` 键开始。

### 1.9 Makefile的文件名

默认的情况下，make命令会在当前目录下按顺序寻找文件名为 `GNUMakefile` 、 `Makefile` 和 `Makefile` 的文件。在这三个文件名中，最好使用 `Makefile` 这个文件名，因为这个文件名在排序上靠近其它比较重要的文件，比如 `README`。最好不要用 `GNUMakefile`，因为这个文件名只能由GNU `make` ，其它版本的 `make` 无法识别，但是基本上来说，大多数的 `make` 都支持 `Makefile` 和 `Makefile` 这两种默认文件名。

当然，你可以使用别的文件名来书写Makefile，比如：“Make.Solaris”，“Make.Linux”等，如果要指定特定的Makefile，你可以使用make的 `-f` 或 `--file` 参数，如： `make -f Make.Solaris` 或 `make --file Make.Linux` 。如果你使用多条 `-f` 或 `--file` 参数，你可以指定多个Makefile。

### 1.10 包含其它Makefile

在Makefile使用 `include` 指令可以把别的Makefile包含进来，这很像C语言的 `#include` ，被包含的文件会原模原样的放在当前文件的包含位置。 `include` 的语法是：

```
include <filenames>...
```

`<filenames>` 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。

在 `include` 前面可以有一些空字符，但是绝不能是 `Tab` 键开始。 `include` 和 `<filenames>` 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile： `a.mk` 、 `b.mk` 、 `c.mk` ，还有一个文件叫 `foo.make` ，以及一个变量 `$(bar)` ，其包含了 `bish` 和 `bash` ，那么，下面的语句：

```
include foo.make *.mk $(bar)
```

等价于：

```
include foo.make a.mk b.mk c.mk bish bash
```

make命令开始时，会找寻 `include` 所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的 `#include` 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：

1. 如果make执行时，有 `-I` 或 `--include-dir` 参数，那么make就会在这个参数所指定的目录下去寻找。
2. 接下来按顺序寻找目录 `<prefix>/include` （一般是 `/usr/local/bin` ）、 `/usr/gnu/include` 、 `/usr/local/include` 、 `/usr/include` 。

环境变量 `.INCLUDE_DIRS` 包含当前 make 会寻找的目录列表。你应当避免使用命令行参数 `-I` 来寻找以上这些默认目录，否则会使得 `make` “忘掉”所有已经设定的包含目录，包括默认目录。

如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成Makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：

```
-include <filenames>...
```

其表示，无论include过程中出现什么错误，都不要报错继续执行。如果要和其它版本 `make` 兼容，可以使用 `sinclude` 代替 `-include` 。

### 1.11 环境变量MakefileS

如果你的当前环境中定义了环境变量 `MakefileS` ，那么make会把这个变量中的值做一个类似于 `include` 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 `include` 不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。

但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。

### 1.12 make的工作方式

GNU的make工作时的执行步骤如下：（想来其它的make也是类似）

1. 读入所有的Makefile。
2. 读入被include的其它Makefile。
3. 初始化文件中的变量。
4. 推导隐式规则，并分析所有规则。
5. 为所有的目标文件创建依赖关系链。
6. 根据依赖关系，决定哪些目标要重新生成。
7. 执行生成命令。

1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。

## 2 书写规则

规则包含两个部分，一个是依赖关系，一个是生成目标的方法。

在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。

好了，还是让我们来看一看如何书写规则。

### 2.1 规则举例

```
foo.o: foo.c defs.h       # foo模块
    cc -c -g foo.c
```

看到这个例子，各位应该不是很陌生了，前面也已说过， `foo.o` 是我们的目标， `foo.c` 和 `defs.h` 是目标所依赖的源文件，而只有一个命令 `cc -c -g foo.c` （以Tab键开头）。这个规则告诉我们两件事：

1. 文件的依赖关系， `foo.o` 依赖于 `foo.c` 和 `defs.h` 的文件，如果 `foo.c` 和 `defs.h` 的文件日期要比 `foo.o` 文件日期要新，或是 `foo.o` 不存在，那么依赖关系发生。
2. 生成或更新 `foo.o` 文件，就是那个cc命令。它说明了如何生成 `foo.o` 这个文件。（当然，foo.c文件include了defs.h文件）

### 2.2 规则的语法

```
targets : prerequisites
    command
    ...
```

或是这样：

```
targets : prerequisites ; command
    command
    ...
```

targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。

command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 `Tab` 键开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）

prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。

如果命令太长，你可以使用反斜杠（ `\` ）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何生成目标文件。

一般来说，make会以UNIX的标准Shell，也就是 `/bin/sh` 来执行命令。

### 2.3 在规则中使用通配符

如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三个通配符： `*` ， `?` 和 `~` 。这是和Unix的B-Shell是相同的。

波浪号（ `~` ）字符在文件名中也有比较特殊的用途。如果是 `~/test` ，这就表示当前用户的 `$HOME` 目录下的test目录。而 `~hchen/test` 则表示用户hchen的宿主目录下的test 目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是 MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。

通配符代替了你一系列的文件，如 `*.c` 表示所有后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如： `*` ，那么可以用转义字符 `\` ，如 `\*` 来表示真实的 `*` 字符，而不是任意长度的字符串。

好吧，还是先来看几个例子吧：

```
clean:
    rm -f *.o
```

其实在这个clean:后面可以加上你想做的一些事情，如果你想看到在编译完后看看main.c的源代码，你可以在加上cat这个命令，例子如下：

```
clean:
    cat main.c
    rm -f *.o
```

其结果你试一下就知道的。 上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。

```
print: *.c
    lpr -p $?
    touch print
```

上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的 `.c` 文件。其中的 `$?` 是一个自动化变量，我会在后面给你讲述。

```
objects = *.o
```

上面这个例子，表示了通配符同样可以用在变量中。并不是说 `*.o` 会展开，不！objects的值就是 `*.o` 。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有 `.o` 的文件名的集合，那么，你可以这样：

```
objects := $(wildcard *.o)
```

另给一个变量使用通配符的例子：

1. 列出一确定文件夹中的所有 `.c` 文件。

   ```
   objects := $(wildcard *.c)
   ```

2. 列出(1)中所有文件对应的 `.o` 文件，在（3）中我们可以看到它是由make自动编译出的:

   ```
   $(patsubst %.c,%.o,$(wildcard *.c))
   ```

3. 由(1)(2)两步，可写出编译并链接所有 `.c` 和 `.o` 文件

   ```
   objects := $(patsubst %.c,%.o,$(wildcard *.c))
   foo : $(objects)
       cc -o foo $(objects)
   ```

这种用法由关键字“wildcard”，“patsubst”指出，关于Makefile的关键字，我们将在后面讨论。

### 2.4 文件搜寻

在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。

Makefile文件中的特殊变量 `VPATH` 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。

```
VPATH = src:../headers
```

上面的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）

另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：

- `vpath <pattern> <directories>`

  为符合模式<pattern>的文件指定搜索目录<directories>。

- `vpath <pattern>`

  清除符合模式<pattern>的文件的搜索目录。

- `vpath`

  清除所有已被设置好了的文件搜索目录。

vpath使用方法中的<pattern>需要包含 `%` 字符。 `%` 的意思是匹配零或若干字符，（需引用 `%` ，使用 `\` ）例如， `%.h` 表示所有以 `.h` 结尾的文件。<pattern>指定了要搜索的文件集，而<directories>则指定了< pattern>的文件集的搜索的目录。例如：

```
vpath %.h ../headers
```

该语句表示，要求make在“../headers”目录下搜索所有以 `.h` 结尾的文件。（如果某文件在当前目录没有找到的话）

我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的<pattern> ，或是被重复了的<pattern>，那么，make会按照vpath语句的先后顺序来执行搜索。如：

```
vpath %.c foo
vpath %   blish
vpath %.c bar
```

其表示 `.c` 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。

```
vpath %.c foo:bar
vpath %   blish
```

而上面的语句则表示 `.c` 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。

### 2.5 伪目标

最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，

```
clean:
    rm *.o temp
```

正像我们前面例子中的“clean”一样，既然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）

因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。

当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。

```
.PHONY : clean
```

只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：

```
.PHONY : clean
clean :
    rm *.o temp
```

伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：

```
all : prog1 prog2 prog3
.PHONY : all

prog1 : prog1.o utils.o
    cc -o prog1 prog1.o utils.o

prog2 : prog2.o
    cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o
```

我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，伪目标只是一个标签不会生成文件，所以不会有“all”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 `.PHONY : all` 声明了“all”这个目标为“伪目标”。（注：这里的显式“.PHONY : all” 不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一个伪目标，执行make不会生成“all”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）

随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：

```
.PHONY : cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
    rm program

cleanobj :
    rm *.o

cleandiff :
    rm *.diff
```

“make cleanall”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。

### 2.6 多目标

Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 `$@` （关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。

```
bigoutput littleoutput : text.g
    generate text.g -$(subst output,,$@) > $@
```

上述规则等价于：

```
bigoutput : text.g
    generate text.g -big > bigoutput
littleoutput : text.g
    generate text.g -little > littleoutput
```

其中， `-$(subst output,,$@)` 中的 `$` 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， `$@` 表示目标的集合，就像一个数组， `$@` 依次取出目标，并执于命令。

### 2.7 静态模式

静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：

```
<targets ...> : <target-pattern> : <prereq-patterns ...>
    <commands>
    ...
```

targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。

target-pattern是指明了targets的模式，也就是的目标集模式。

prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。

这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-pattern>定义成 `%.o` ，意思是我们的<target>;集合中都是以 `.o` 结尾的，而如果我们的<prereq-patterns>定义成 `%.c` ，意思是对<target-pattern>所形成的目标集进行二次定义，其计算方法是，取<target-pattern>模式中的 `%` （也就是去掉了 `.o` 这个结尾），并为其加上 `.c` 这个结尾，形成的新集合。

所以，我们的“目标模式”或是“依赖模式”中都应该有 `%` 这个字符，如果你的文件名中有 `%` 那么你可以使用反斜杠 `\` 进行转义，来标明真实的 `%` 字符。

看一个例子：

```
objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
```

上面的例子中，指明了我们的目标从$object中获取， `%.o` 表明要所有以 `.o` 结尾的目标，也就是 `foo.o bar.o` ，也就是变量 `$object` 集合的模式，而依赖模式 `%.c` 则取模式 `%.o` 的 `%` ，也就是 `foo bar` ，并为其加下 `.c` 的后缀，于是，我们的依赖目标就是 `foo.c bar.c` 。而命令中的 `$<` 和 `$@` 则是自动化变量， `$<` 表示第一个依赖文件， `$@` 表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：

```
foo.o : foo.c
    $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o : bar.c
    $(CC) -c $(CFLAGS) bar.c -o bar.o
```

试想，如果我们的 `%.o` 有几百个，那么我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会是一个很强大的功能。再看一个例子：

```
files = foo.elc bar.o lose.o

$(filter %.o,$(files)): %.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
$(filter %.elc,$(files)): %.elc: %.el
    emacs -f batch-byte-compile $<
```

$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。其它的内容，我就不用多说了吧。这个例子展示了Makefile中更大的弹性。

### 2.8 自动生成依赖性

在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句 `#include "defs.h"` ，那么我们的依赖关系应该是：

```
main.o : main.c defs.h
```

但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令:

```
cc -M main.c
```

其输出是：

```
main.o : main.c defs.h
```

于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用 `-MM` 参数，不然， `-M` 参数会把一些标准库的头文件也包含进来。

gcc -M main.c的输出是:

```
main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \
    /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \
    /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \
    /usr/include/bits/sched.h /usr/include/libio.h \
    /usr/include/_G_config.h /usr/include/wchar.h \
    /usr/include/bits/wchar.h /usr/include/gconv.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \
    /usr/include/bits/stdio_lim.h
```

gcc -MM main.c的输出则是:

```
main.o: main.c defs.h
```

那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让 Makefile 自己依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 `name.c` 的文件都生成一个 `name.d` 的Makefile文件， `.d` 文件中就存放对应 `.c` 文件的依赖关系。

于是，我们可以写出 `.c` 文件和 `.d` 文件的依赖关系，并让make自动更新或生成 `.d` 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。

这里，我们给出了一个模式规则来产生 `.d` 文件：

```
%.d: %.c
    @set -e; rm -f $@; \
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
    rm -f $@.$$$$
```

这个规则的意思是，所有的 `.d` 文件依赖于 `.c` 文件， `rm -f $@` 的意思是删除所有的目标，也就是 `.d` 文件，第二行的意思是，为每个依赖文件 `$<` ，也就是 `.c` 文件生成依赖文件， `$@` 表示模式 `%.d` 文件，如果有一个C文件是name.c，那么 `%` 就是 `name` ， `$$$$` 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。

总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 `.d` 文件的依赖，即把依赖关系：

```
main.o : main.c defs.h
```

转成：

```
main.o main.d : main.c defs.h
```

于是，我们的 `.d` 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 `.d` 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 `.d` 文件都包含一个完整的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：

```
sources = foo.c bar.c

include $(sources:.c=.d)
```

上述语句中的 `$(sources:.c=.d)` 中的 `.c=.d` 的意思是做一个替换，把变量 `$(sources)` 所有 `.c` 的字串都替换成 `.d` ，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次序来载入文件，最先载入的 `.d` 文件中的目标会成为默认目标。



## 3 书写命令

每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以 `Tab` 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。

我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被 `/bin/sh` ——UNIX的标准Shell 解释执行的。除非你特别指定一个其它的Shell。Makefile中， `#` 是注释符，很像C/C++中的 `//` ，其后的本行字符都被注释。

### 3.1 显示命令

通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 `@` 字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:

```
@echo 正在编译XXX模块......
```

当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出:

```
echo 正在编译XXX模块......
正在编译XXX模块......
```

如果make执行时，带入make参数 `-n` 或 `--just-print` ，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。

而make参数 `-s` 或 `--silent` 或 `--quiet` 则是全面禁止命令的显示。

### 3.2 命令执行

当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：

- 示例一：

```
exec:
    cd /home/hchen
    pwd
```

- 示例二：

```
exec:
    cd /home/hchen; pwd
```

当我们执行 `make exec` 时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。

make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如 `.exe` 、 `.com` 、 `.bat` 、 `.sh` 等后缀。

### 3.3 命令出错

每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。

有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。

为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号 `-` （在Tab键之后），标记为不管命令出不出错都认为是成功的。如：

```
clean:
    -rm -f *.o
```

还有一个全局的办法是，给make加上 `-i` 或是 `--ignore-errors` 参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以 `.IGNORE` 作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。

还有一个要提一下的make的参数的是 `-k` 或是 `--keep-going` ，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。

### 3.4 嵌套执行make

在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。

例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：

```
subsystem:
    cd subdir && $(MAKE)
```

其等价于：

```
subsystem:
    $(MAKE) -C subdir
```

定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。

我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了 `-e` 参数。

如果你要传递变量到下级Makefile中，那么你可以使用这样的声明:

```
export <variable ...>;
```

如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明:

```
unexport <variable ...>;
```

如：

示例一：

```
export variable = value
```

其等价于：

```
variable = value
export variable
```

其等价于：

```
export variable := value
```

其等价于：

```
variable := value
export variable
```

示例二：

```
export variable += value
```

其等价于：

```
variable += value
export variable
```

如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。

需要注意的是，有两个变量，一个是 `SHELL` ，一个是 `MAKEFLAGS` ，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是 `MAKEFLAGS` 变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么 `MAKEFLAGS` 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。

但是make命令中的有几个参数并不往下传递，它们是 `-C` , `-f` , `-h`, `-o` 和 `-W` （有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：

```
subsystem:
    cd subdir && $(MAKE) MAKEFLAGS=
```

如果你定义了环境变量 `MAKEFLAGS` ，那么你得确信其中的选项是大家都会用到的，如果其中有 `-t` , `-n` 和 `-q` 参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。

还有一个在“嵌套执行”中比较有用的参数， `-w` 或是 `--print-directory` 会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用 `make -w` 来执行，那么当进入该目录时，我们会看到:

```
make: Entering directory `/home/hchen/gnu/make'.
```

而在完成下层make后离开目录时，我们会看到:

```
make: Leaving directory `/home/hchen/gnu/make'
```

当你使用 `-C` 参数来指定make下层Makefile时， `-w` 会被自动打开的。如果参数中有 `-s` （ `--slient` ）或是 `--no-print-directory` ，那么， `-w` 总是失效的。

### 3.5 定义命令包

如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 `define` 开始，以 `endef` 结束，如:

```
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
```

这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在 `define` 和 `endef` 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。

```
foo.c : foo.y
    $(run-yacc)
```

我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的 `$^` 就是 `foo.y` ， `$@` 就是 `foo.c` （有关这种以 `$` 开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。



## 4 使用变量

在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”， “命令”或是Makefile的其它部分中。

变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 `:` 、 `#` 、 `=` 或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。

有一些变量是很奇怪字串，如 `$<` 、 `$@` 等，这些是自动化变量，我会在后面介绍。

### 4.1 变量的基础

变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 `$` 符号，但最好用小括号 `()` 或是大括号 `{}` 把变量给包括起来。如果你要使用真实的 `$` 字符，那么你需要用 `$$` 来表示。

变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：

```
objects = program.o foo.o utils.o
program : $(objects)
    cc -o program $(objects)

$(objects) : defs.h
```

变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：

```
foo = c
prog.o : prog.$(foo)
    $(foo)$(foo) -$(foo) prog.$(foo)
```

展开后得到：

```
prog.o : prog.c
    cc -c prog.c
```

当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。

另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。

### 4.2 变量中的变量

在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。

先看第一种方式，也就是简单的使用 `=` 号，在 `=` 左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：

```
foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:
    echo $(foo)
```

我们执行“make all”将会打出变量 `$(foo)` 的值是 `Huh?` （ `$(foo)` 的值是 `$(bar)` ， `$(bar)` 的值是 `$(ugh)` ， `$(ugh)` 的值是 `Huh?` ）可见，变量是可以使用后面的变量来定义的。

这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：

```
CFLAGS = $(include_dirs) -O
include_dirs = -Ifoo -Ibar
```

当 `CFLAGS` 在命令中被展开时，会是 `-Ifoo -Ibar -O` 。但这种形式也有不好的地方，那就是递归定义，如：

```
CFLAGS = $(CFLAGS) -O
```

或：

```
A = $(B)
B = $(A)
```

这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。

为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是 `:=` 操作符，如：

```
x := foo
y := $(x) bar
x := later
```

其等价于：

```
y := foo bar
x := later
```

值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：

```
y := $(x) bar
x := foo
```

那么，y的值是“bar”，而不是“foo bar”。

上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：

```
ifeq (0,${MAKELEVEL})
cur-dir   := $(shell pwd)
whoami    := $(shell whoami)
host-type := $(shell arch)
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
endif
```

关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。

下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：

```
nullstring :=
space := $(nullstring) # end of the line
```

nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：

```
dir := /foo/bar    # directory to put the frobs in
```

dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这个变量来指定别的目录——“$(dir)/file”那么就完蛋了。

还有一个比较有用的操作符是 `?=` ，先看示例：

```
FOO ?= bar
```

其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：

```
ifeq ($(origin FOO), undefined)
    FOO = bar
endif
```

### 4.3 变量高级用法

这里介绍两种变量的高级使用方法，第一种是变量值的替换。

我们可以替换变量中的共有的部分，其格式是 `$(var:a=b)` 或是 `${var:a=b}` ，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。

还是看一个示例吧：

```
foo := a.o b.o c.o
bar := $(foo:.o=.c)
```

这个示例中，我们先定义了一个 `$(foo)` 变量，而第二行的意思是把 `$(foo)` 中所有以 `.o` 字串“结尾”全部替换成 `.c` ，所以我们的 `$(bar)` 的值就是“a.c b.c c.c”。

另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：

```
foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
```

这依赖于被替换字串中的有相同的模式，模式中必须包含一个 `%` 字符，这个例子同样让 `$(bar)` 变量的值为“a.c b.c c.c”。

第二种高级用法是——“把变量的值再当成变量”。先看一个例子：

```
x = y
y = z
a := $($(x))
```

在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）

我们还可以使用更多的层次：

```
x = y
y = z
z = u
a := $($($(x)))
```

这里的 `$(a)` 的值是“u”，相关的推导留给读者自己去做吧。

让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：

```
x = $(y)
y = z
z = Hello
a := $($(x))
```

这里的 `$($(x))` 被替换成了 `$($(y))` ，因为 `$(y)` 值是“z”，所以，最终结果是： `a:=$(z)` ，也就是“Hello”。

再复杂一点，我们再加上函数：

```
x = variable1
variable2 := Hello
y = $(subst 1,2,$(x))
z = y
a := $($($(z)))
```

这个例子中， `$($($(z)))` 扩展为 `$($(y))` ，而其再次被扩展为 `$($(subst 1,2,$(x)))` 。 `$(x)` 的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成 “variable2”，再取其值，所以，最终， `$(a)` 的值就是 `$(variable2)` 的值——“Hello”。（喔，好不容易）

在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：

```
first_second = Hello
a = first
b = second
all = $($a_$b)
```

这里的 `$a_$b` 组成了“first_second”，于是， `$(all)` 的值就是“Hello”。

再来看看结合第一种技术的例子：

```
a_objects := a.o b.o c.o
1_objects := 1.o 2.o 3.o

sources := $($(a1)_objects:.o=.c)
```

这个例子中，如果 `$(a1)` 的值是“a”的话，那么， `$(sources)` 的值就是“a.c b.c c.c”；如果 `$(a1)` 的值是“1”，那么 `$(sources)` 的值是“1.c 2.c 3.c”。

再来看一个这种技术和“函数”与“条件语句”一同使用的例子：

```
ifdef do_sort
    func := sort
else
    func := strip
endif

bar := a d b g q c

foo := $($(func) $(bar))
```

这个示例中，如果定义了“do_sort”，那么： `foo := $(sort a d b g q c)` ，于是 `$(foo)` 的值就是 “a b c d g q”，而如果没有定义“do_sort”，那么： `foo := $(strip a d b g q c)` ，调用的就是strip函数。

当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:

```
dir = foo
$(dir)_sources := $(wildcard $(dir)/*.c)
define $(dir)_print
lpr $($(dir)_sources)
endef
```

这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。

### 4.4 追加变量值

我们可以使用 `+=` 操作符给变量追加值，如：

```
objects = main.o foo.o bar.o utils.o
objects += another.o
```

于是，我们的 `$(objects)` 值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）

使用 `+=` 操作符，可以模拟为下面的这种例子：

```
objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o
```

所不同的是，用 `+=` 更为简洁。

如果变量之前没有定义过，那么， `+=` 会自动变成 `=` ，如果前面有变量定义，那么 `+=` 会继承于前次操作的赋值符。如果前一次的是 `:=` ，那么 `+=` 会以 `:=` 作为其赋值符，如：

```
variable := value
variable += more
```

等价于：

```
variable := value
variable := $(variable) more
```

但如果是这种情况：

```
variable = value
variable += more
```

由于前次的赋值符是 `=` ，所以 `+=` 也会以 `=` 来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。

### 4.5 override 指令

如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指令。其语法是:

```
override <variable>; = <value>;

override <variable>; := <value>;
```

当然，你还可以追加:

```
override <variable>; += <more text>;
```

对于多行的变量定义，我们用define指令，在define指令前，也同样可以使用override指令，如:

```
override define foo
bar
endef
```

### 4.6 多行变量

还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。

define指令后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 `Tab` 键开头，那么make 就不会把其认为是命令。

下面的这个示例展示了define的用法:

```
define two-lines
echo foo
echo $(bar)
endef
```

### 4.7 环境变量

make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）

因此，如果我们在环境变量中设置了 `CFLAGS` 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。

当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用export关键字来声明。（参见前面章节）

当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。

### 4.8 目标变量

前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如 `$<` 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。

当然，我也同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。

其语法是：

```
<target ...> : <variable-assignment>;

<target ...> : overide <variable-assignment>
```

<variable-assignment>;可以是前面讲过的各种赋值表达式，如 `=` 、 `:=` 、 `+=` 或是 `?=` 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。

这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：

```
prog : CFLAGS = -g
prog : prog.o foo.o bar.o
    $(CC) $(CFLAGS) prog.o foo.o bar.o

prog.o : prog.c
    $(CC) $(CFLAGS) prog.c

foo.o : foo.c
    $(CC) $(CFLAGS) foo.c

bar.o : bar.c
    $(CC) $(CFLAGS) bar.c
```

在这个示例中，不管全局的 `$(CFLAGS)` 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， `$(CFLAGS)` 的值都是 `-g`

### 4.9 模式变量

在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。

我们知道，make的“模式”一般是至少含有一个 `%` 的，所以，我们可以以如下方式给所有以 `.o` 结尾的目标定义目标变量：

```makefile
%.o : CFLAGS = -O
```

同样，模式变量的语法和“目标变量”一样：

```makefile
<pattern ...>; : <variable-assignment>;

<pattern ...>; : override <variable-assignment>;
```

override同样是针对于系统环境传入的变量，或是make命令行指定的变量。

## 5 使用条件判断

使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。

### 5.1 示例

下面的例子，判断 `$(CC)` 变量是否 `gcc` ，如果是的话，则使用GNU函数编译目标。

```
libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
    $(CC) -o foo $(objects) $(libs_for_gcc)
else
    $(CC) -o foo $(objects) $(normal_libs)
endif
```

可见，在上面示例的这个规则中，目标 `foo` 可以根据变量 `$(CC)` 值来选取不同的函数库来编译程序。

我们可以从上面的示例中看到三个关键字： `ifeq` 、 `else` 和 `endif` 。 `ifeq` 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 `else` 表示条件表达式为假的情况。 `endif` 表示一个条件语句的结束，任何一个条件表达式都应该以 `endif` 结束。

当我们的变量 `$(CC)` 值是 `gcc` 时，目标 `foo` 的规则是：

```
foo: $(objects)
    $(CC) -o foo $(objects) $(libs_for_gcc)
```

而当我们的变量 `$(CC)` 值不是 `gcc` 时（比如 `cc` ），目标 `foo` 的规则是：

```
foo: $(objects)
    $(CC) -o foo $(objects) $(normal_libs)
```

当然，我们还可以把上面的那个例子写得更简洁一些：

```
libs_for_gcc = -lgnu
normal_libs =

ifeq ($(CC),gcc)
    libs=$(libs_for_gcc)
else
    libs=$(normal_libs)
endif

foo: $(objects)
    $(CC) -o foo $(objects) $(libs)
```

### 5.3 语法

条件表达式的语法为:

```
<conditional-directive>
<text-if-true>
endif
```

以及:

```
<conditional-directive>
<text-if-true>
else
<text-if-false>
endif
```

其中 `<conditional-directive>` 表示条件关键字，如 `ifeq` 。这个关键字有四个。

第一个是我们前面所见过的 `ifeq`

```
ifeq (<arg1>, <arg2>)
ifeq '<arg1>' '<arg2>'
ifeq "<arg1>" "<arg2>"
ifeq "<arg1>" '<arg2>'
ifeq '<arg1>' "<arg2>"
```

比较参数 `arg1` 和 `arg2` 的值是否相同。当然，参数中我们还可以使用make的函数。如:

```
ifeq ($(strip $(foo)),)
<text-if-empty>
endif
```

这个示例中使用了 `strip` 函数，如果这个函数的返回值是空（Empty），那么 `<text-if-empty>` 就生效。

第二个条件关键字是 `ifneq` 。语法是：

```
ifneq (<arg1>, <arg2>)
ifneq '<arg1>' '<arg2>'
ifneq "<arg1>" "<arg2>"
ifneq "<arg1>" '<arg2>'
ifneq '<arg1>' "<arg2>"
```

其比较参数 `arg1` 和 `arg2` 的值是否相同，如果不同，则为真。和 `ifeq` 类似。

第三个条件关键字是 `ifdef` 。语法是：

```
ifdef <variable-name>
```

如果变量 `<variable-name>` 的值非空，那到表达式为真。否则，表达式为假。当然， `<variable-name>` 同样可以是一个函数的返回值。注意， `ifdef` 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：

示例一：

```
bar =
foo = $(bar)
ifdef foo
    frobozz = yes
else
    frobozz = no
endif
```

示例二：

```
foo =
ifdef foo
    frobozz = yes
else
    frobozz = no
endif
```

第一个例子中， `$(frobozz)` 值是 `yes` ，第二个则是 `no`。

第四个条件关键字是 `ifndef` 。其语法是：

```
ifndef <variable-name>
```

这个我就不多说了，和 `ifdef` 是相反的意思。

在 `<conditional-directive>` 这一行上，多余的空格是被允许的，但是不能以 `Tab` 键作为开始（不然就被认为是命令）。而注释符 `#` 同样也是安全的。 `else` 和 `endif` 也一样，只要不是以 `Tab` 键开始就行了。

特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如 `$@` 等）放入条件表达式中，因为自动化变量是在运行时才有的。

而且为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。

## 6 使用函数

在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make 所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。

### 6.1 函数的调用语法

函数调用，很像变量的使用，也是以 `$` 来标识的，其语法如下：

```
$(<function> <arguments>)
```

或是:

```
${<function> <arguments>}
```

这里， `<function>` 就是函数名，make支持的函数不多。 `<arguments>` 为函数的参数，参数间以逗号 `,` 分隔，而函数名和参数之间以“空格”分隔。函数调用以 `$` 开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用 `$(subst a,b,$(x))` 这样的形式，而不是 `$(subst a,b, ${x})` 的形式。因为统一会更清楚，也会减少一些不必要的麻烦。

还是来看一个示例：

```
comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
```

在这个示例中， `$(comma)` 的值是一个逗号。 `$(space)` 使用了 `$(empty)` 定义了一个空格， `$(foo)` 的值是 `a b c` ， `$(bar)` 的定义用，调用了函数 `subst` ，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把 `$(foo)` 中的空格替换成逗号，所以 `$(bar)` 的值是 `a,b,c` 。

### 6.2 字符串处理函数

#### 6.2.1 subst

```
$(subst <from>,<to>,<text>)
```

- 名称：字符串替换函数

- 功能：把字串 `<text>` 中的 `<from>` 字符串替换成 `<to>` 。

- 返回：函数返回被替换过后的字符串。

- 示例：

  > ```
  > $(subst ee,EE,feet on the street)
  > ```

把 `feet on the street` 中的 `ee` 替换成 `EE` ，返回结果是 `fEEt on the strEEt` 。

#### 6.2.2 patsubst

```
$(patsubst <pattern>,<replacement>,<text>)
```

- 名称：模式字符串替换函数。

- 功能：查找 `<text>` 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 `<pattern>` ，如果匹配的话，则以 `<replacement>` 替换。这里， `<pattern>` 可以包括通配符 `%` ，表示任意长度的字串。如果 `<replacement>` 中也包含 `%` ，那么， `<replacement>` 中的这个 `%` 将是 `<pattern>` 中的那个 `%` 所代表的字串。（可以用 `\` 来转义，以 `\%` 来表示真实含义的 `%` 字符）

- 返回：函数返回被替换过后的字符串。

- 示例：

  > ```
  > $(patsubst %.c,%.o,x.c.c bar.c)
  > ```

把字串 `x.c.c bar.c` 符合模式 `%.c` 的单词替换成 `%.o` ，返回结果是 `x.c.o bar.o`

- 备注：这和我们前面“变量章节”说过的相关知识有点相似。如 `$(var:<pattern>=<replacement>;)` 相当于 `$(patsubst <pattern>,<replacement>,$(var))` ，而 `$(var: <suffix>=<replacement>)` 则相当于 `$(patsubst %<suffix>,%<replacement>,$(var))` 。

  例如有:

  ```
  objects = foo.o bar.o baz.o，
  ```

  那么， `$(objects:.o=.c)` 和 `$(patsubst %.o,%.c,$(objects))` 是一样的。

#### 6.2.3 strip

```
$(strip <string>)
```

- 名称：去空格函数。

- 功能：去掉 `<string>` 字串中开头和结尾的空字符。

- 返回：返回被去掉空格的字符串值。

- 示例：

  > ```
  > $(strip a b c )
  > ```

  把字串 `a b c ` 去掉开头和结尾的空格，结果是 `a b c`。

#### 6.2.4 findstring

```
$(findstring <find>,<in>)
```

- 名称：查找字符串函数

- 功能：在字串 `<in>` 中查找 `<find>` 字串。

- 返回：如果找到，那么返回 `<find>` ，否则返回空字符串。

- 示例：

  > ```
  > $(findstring a,a b c)
  > $(findstring a,b c)
  > ```

第一个函数返回 `a` 字符串，第二个返回空字符串

#### 6.2.5 filter

```
$(filter <pattern...>,<text>)
```

- 名称：过滤函数

- 功能：以 `<pattern>` 模式过滤 `<text>` 字符串中的单词，保留符合模式 `<pattern>` 的单词。可以有多个模式。

- 返回：返回符合模式 `<pattern>` 的字串。

- 示例：

  > ```
  > sources := foo.c bar.c baz.s ugh.h
  > foo: $(sources)
  >     cc $(filter %.c %.s,$(sources)) -o foo
  > ```

  `$(filter %.c %.s,$(sources))` 返回的值是 `foo.c bar.c baz.s` 。

#### 6.2.6 filter-out

```
$(filter-out <pattern...>,<text>)
```

- 名称：反过滤函数

- 功能：以 `<pattern>` 模式过滤 `<text>` 字符串中的单词，去除符合模式 `<pattern>` 的单词。可以有多个模式。

- 返回：返回不符合模式 `<pattern>` 的字串。

- 示例：

  > ```
  > objects=main1.o foo.o main2.o bar.o
  > mains=main1.o main2.o
  > ```

  `$(filter-out $(mains),$(objects))` 返回值是 `foo.o bar.o` 。

#### 6.2.7 sort

```
$(sort <list>)
```

- 名称：排序函数
- 功能：给字符串 `<list>` 中的单词排序（升序）。
- 返回：返回排序后的字符串。
- 示例： `$(sort foo bar lose)` 返回 `bar foo lose` 。
- 备注： `sort` 函数会去掉 `<list>` 中相同的单词。

#### 6.2.8 word

```
$(word <n>,<text>)
```

- 名称：取单词函数
- 功能：取字符串 `<text>` 中第 `<n>` 个单词。（从一开始）
- 返回：返回字符串 `<text>` 中第 `<n>` 个单词。如果 `<n>` 比 `<text>` 中的单词数要大，那么返回空字符串。
- 示例： `$(word 2, foo bar baz)` 返回值是 `bar` 。

#### 6.2.9 wordlist

```
$(wordlist <ss>,<e>,<text>)
```

- 名称：取单词串函数
- 功能：从字符串 `<text>` 中取从 `<ss>` 开始到 `<e>` 的单词串。 `<ss>` 和 `<e>` 是一个数字。
- 返回：返回字符串 `<text>` 中从 `<ss>` 到 `<e>` 的单词字串。如果 `<ss>` 比 `<text>` 中的单词数要大，那么返回空字符串。如果 `<e>` 大于 `<text>` 的单词数，那么返回从 `<ss>` 开始，到 `<text>` 结束的单词串。
- 示例： `$(wordlist 2, 3, foo bar baz)` 返回值是 `bar baz` 。

#### 6.2.10 words

```
$(words <text>)
```

- 名称：单词个数统计函数
- 功能：统计 `<text>` 中字符串中的单词个数。
- 返回：返回 `<text>` 中的单词数。
- 示例： `$(words, foo bar baz)` 返回值是 `3` 。
- 备注：如果我们要取 `<text>` 中最后的一个单词，我们可以这样： `$(word $(words <text>),<text>)` 。

#### 6.2.11 firstword

```
$(firstword <text>)
```

- 名称：首单词函数——firstword。
- 功能：取字符串 `<text>` 中的第一个单词。
- 返回：返回字符串 `<text>` 的第一个单词。
- 示例： `$(firstword foo bar)` 返回值是 `foo`。
- 备注：这个函数可以用 `word` 函数来实现： `$(word 1,<text>)` 。

以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用 `VPATH` 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 `CFLAGS` ，如：

```
override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))
```

如果我们的 `$(VPATH)` 值是 `src:../headers` ，那么 `$(patsubst %,-I%,$(subst :, ,$(VPATH)))` 将返回 `-Isrc -I../headers` ，这正是cc或gcc搜索头文件路径的参数。

### 6.3 文件名操作函数

下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。

#### 6.3.1 dir

```
$(dir <names...>)
```

- 名称：取目录函数——dir。
- 功能：从文件名序列 `<names>` 中取出目录部分。目录部分是指最后一个反斜杠（ `/` ）之前的部分。如果没有反斜杠，那么返回 `./` 。
- 返回：返回文件名序列 `<names>` 的目录部分。
- 示例： `$(dir src/foo.c hacks)` 返回值是 `src/ ./` 。

#### 6.3.2 notdir

```
$(notdir <names...>)
```

- 名称：取文件函数——notdir。
- 功能：从文件名序列 `<names>` 中取出非目录部分。非目录部分是指最後一个反斜杠（ `/` ）之后的部分。
- 返回：返回文件名序列 `<names>` 的非目录部分。
- 示例: `$(notdir src/foo.c hacks)` 返回值是 `foo.c hacks` 。

#### 6.3.3 suffix

```
$(suffix <names...>)
```

- 名称：取後缀函数——suffix。
- 功能：从文件名序列 `<names>` 中取出各个文件名的后缀。
- 返回：返回文件名序列 `<names>` 的后缀序列，如果文件没有后缀，则返回空字串。
- 示例： `$(suffix src/foo.c src-1.0/bar.c hacks)` 返回值是 `.c .c`。

#### 6.3.4 basename

```
$(basename <names...>)
```

- 名称：取前缀函数——basename。
- 功能：从文件名序列 `<names>` 中取出各个文件名的前缀部分。
- 返回：返回文件名序列 `<names>` 的前缀序列，如果文件没有前缀，则返回空字串。
- 示例： `$(basename src/foo.c src-1.0/bar.c hacks)` 返回值是 `src/foo src-1.0/bar hacks` 。6.

#### 6.3.5 addsuffix

```
$(addsuffix <suffix>,<names...>)
```

- 名称：加后缀函数——addsuffix。
- 功能：把后缀 `<suffix>` 加到 `<names>` 中的每个单词后面。
- 返回：返回加过后缀的文件名序列。
- 示例： `$(addsuffix .c,foo bar)` 返回值是 `foo.c bar.c` 。

#### 6.3.6 addprefix

```
$(addprefix <prefix>,<names...>)
```

- 名称：加前缀函数——addprefix。
- 功能：把前缀 `<prefix>` 加到 `<names>` 中的每个单词前面。
- 返回：返回加过前缀的文件名序列。
- 示例： `$(addprefix src/,foo bar)` 返回值是 `src/foo src/bar` 。

#### 6.3.7 join

```
$(join <list1>,<list2>)
```

- 名称：连接函数——join。
- 功能：把 `<list2>` 中的单词对应地加到 `<list1>` 的单词后面。如果 `<list1>` 的单词个数要比 `<list2>` 的多，那么， `<list1>` 中的多出来的单词将保持原样。如果 `<list2>` 的单词个数要比 `<list1>` 多，那么， `<list2>` 多出来的单词将被复制到 `<list1>` 中。
- 返回：返回连接过后的字符串。
- 示例： `$(join aaa bbb , 111 222 333)` 返回值是 `aaa111 bbb222 333` 。

### 6.4 foreach 函数

foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：

```
$(foreach <var>,<list>,<text>)
```

这个函数的意思是，把参数 `<list>` 中的单词逐一取出放到参数 `<var>` 所指定的变量中，然后再执行 `<text>` 所包含的表达式。每一次 `<text>` 会返回一个字符串，循环过程中， `<text>` 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， `<text>` 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。

所以， `<var>` 最好是一个变量名， `<list>` 可以是一个表达式，而 `<text>` 中一般会使用 `<var>` 这个参数来依次枚举 `<list>` 中的单词。举个例子：

```
names := a b c d

files := $(foreach n,$(names),$(n).o)
```

上面的例子中， `$(name)` 中的单词会被挨个取出，并存到变量 `n` 中， `$(n).o` 每次根据 `$(n)` 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以， `$(files)` 的值是 `a.o b.o c.o d.o` 。

注意，foreach中的 `<var>` 参数是一个临时的局部变量，foreach函数执行完后，参数 `<var>` 的变量将不在作用，其作用域只在foreach函数当中。

### 6.5 if 函数

if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：

```
$(if <condition>,<then-part>)
```

或是

```
$(if <condition>,<then-part>,<else-part>)
```

可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。 `<condition>` 参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， `<then-part>` 会被计算，否则 `<else-part>` 会被计算。

而if函数的返回值是，如果 `<condition>` 为真（非空字符串），那个 `<then-part>` 会是整个函数的返回值，如果 `<condition>` 为假（空字符串），那么 `<else-part>` 会是整个函数的返回值，此时如果 `<else-part>` 没有被定义，那么，整个函数返回空字串。

所以， `<then-part>` 和 `<else-part>` 只会有一个被计算。

### 6.6 call函数

call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。其语法是：

```
$(call <expression>,<parm1>,<parm2>,...,<parmn>)
```

当make执行这个函数时， `<expression>` 参数中的变量，如 `$(1)` 、 `$(2)` 等，会被参数 `<parm1>` 、 `<parm2>` 、 `<parm3>` 依次取代。而 `<expression>` 的返回值就是 call 函数的返回值。例如：

```
reverse =  $(1) $(2)

foo = $(call reverse,a,b)
```

那么， `foo` 的值就是 `a b` 。当然，参数的次序是可以自定义的，不一定是顺序的，如：

```
reverse =  $(2) $(1)

foo = $(call reverse,a,b)
```

此时的 `foo` 的值就是 `b a` 。

需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。

### 6.7 origin函数

origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：

```
$(origin <variable>)
```

- 注意， `<variable>` 是变量的名字，不应该是引用。所以你最好不要在 `<variable>` 中使用

  `$` 字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:

- `undefined`

  如果 `<variable>` 从来没有定义过，origin函数返回这个值 `undefined`

- `default`

  如果 `<variable>` 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。

- `environment`

  如果 `<variable>` 是一个环境变量，并且当Makefile被执行时， `-e` 参数没有被打开。

- `file`

  如果 `<variable>` 这个变量被定义在Makefile中。

- `command line`

  如果 `<variable>` 这个变量是被命令行定义的。

- `override`

  如果 `<variable>` 是被override指示符重新定义的。

- `automatic`

  如果 `<variable>` 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。

这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：

```
ifdef bletch
    ifeq "$(origin bletch)" "environment"
        bletch = barf, gag, etc.
    endif
endif
```

当然，你也许会说，使用 `override` 关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 `override` 是可以达到这样的效果，可是 `override` 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。

### 6.8 shell函数

shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：

```
contents := $(shell cat foo)
files := $(shell echo *.c)
```

注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐式规则可能会让你的shell函数执行的次数比你想像的多得多。

### 6.9 控制make的函数

make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。

```
$(error <text ...>)
```

产生一个致命的错误， `<text ...>` 是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：

示例一：

```
ifdef ERROR_001
    $(error error is $(ERROR_001))
endif
```

示例二：

```
ERR = $(error found an error!)

.PHONY: err

err: $(ERR)
```

示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。

```
$(warning <text ...>)
```

这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。

## 7 make 的运行

一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。

### 7.1 make的退出码

make命令执行后有三个退出码：

- 0

  表示成功执行。

- 1

  如果make运行时出现任何错误，其返回1。

- 2

  如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。

Make的相关参数我们会在后续章节中讲述。

### 7.2 指定Makefile

前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。

当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的 `-f` 或是 `--file` 参数（ `--makefile` 参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：

```
make –f hchen.mk
```

如果在make的命令行是，你不只一次地使用了 `-f` 参数，那么，所有指定的makefile将会被连在一起传递给make执行。

### 7.3 指定目标

一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）

任何在makefile中的目标都可以被指定成终极目标，但是除了以 `-` 打头，或是包含了 `=` 的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。

有一个make的环境变量叫 `MAKECMDGOALS` ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：

```
sources = foo.c bar.c
ifneq ( $(MAKECMDGOALS),clean)
    include $(sources:.c=.d)
endif
```

基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。

使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：

```
.PHONY: all
all: prog1 prog2 prog3 prog4
```

从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”，“prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用 “make prog2”来单独编译目标“prog2”。

即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。

- all:这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
- clean:这个伪目标功能是删除所有被make创建的文件。
- install:这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。
- print:这个伪目标的功能是例出改变过的源文件。
- tar:这个伪目标功能是把源程序打包备份。也就是一个tar文件。
- dist:这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。
- TAGS:这个伪目标功能是更新所有的目标，以备完整地重编译使用。
- check和test:这两个伪目标一般用来测试makefile的流程。

当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的 UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。

### 7.4 检查规则

有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：

- `-n`, `--just-print`, `--dry-run`, `--recon`

  不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。

- `-t`, `--touch`

  这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。

- `-q`, `--question`

  这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。

- `-W <file>`, `--what-if=<file>`, `--assume-new=<file>`, `--new-file=<file>`

  这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。

另外一个很有意思的用法是结合 `-p` 和 `-v` 来输出makefile被执行时的信息（这个将在后面讲述）。

### 7.5 make的参数

下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。

- `-b`, `-m`

  这两个参数的作用是忽略和其它版本make的兼容性。

- `-B`, `--always-make`

  认为所有的目标都需要更新（重编译）。

- `-C` *<dir>*, `--directory`=*<dir>*

  指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make -C ~hchen/test -C prog”等价于“make -C ~hchen/test/prog”。

- `-debug`[=*<options>*]

  输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：a: 也就是all，输出所有的调试信息。（会非常的多）b: 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。v: 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i: 也就是implicit，输出所有的隐含规则。j: 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。m: 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。

- `-d`

  相当于“–debug=a”。

- `-e`, `--environment-overrides`

  指明环境变量的值覆盖makefile中定义的变量的值。

- `-f`=*<file>*, `--file`=*<file>*, `--makefile`=*<file>*

  指定需要执行的makefile。

- `-h`, `--help`

  显示帮助信息。

- `-i` , `--ignore-errors`

  在执行时忽略所有的错误。

- `-I` *<dir>*, `--include-dir`=*<dir>*

  指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。

- `-j` [*<jobsnum>*], `--jobs`[=*<jobsnum>*]

  指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）

- `-k`, `--keep-going`

  出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。

- `-l` *<load>*, `--load-average`[=*<load>*], `-max-load`[=*<load>*]

  指定make运行命令的负载。

- `-n`, `--just-print`, `--dry-run`, `--recon`

  仅输出执行过程中的命令序列，但并不执行。

- `-o` *<file>*, `--old-file`=*<file>*, `--assume-old`=*<file>*

  不重新生成的指定的<file>，即使这个目标的依赖文件新于它。

- `-p`, `--print-data-base`

  输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用 “make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的 makefile会是很有用的，特别是当你的环境变量很复杂的时候。

- `-q`, `--question`

  不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。

- `-r`, `--no-builtin-rules`

  禁止make使用任何隐含规则。

- `-R`, `--no-builtin-variabes`

  禁止make使用任何作用于变量上的隐含规则。

- `-s`, `--silent`, `--quiet`

  在命令运行时不输出命令的输出。

- `-S`, `--no-keep-going`, `--stop`

  取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。

- `-t`, `--touch`

  相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。

- `-v`, `--version`

  输出make程序的版本、版权等关于make的信息。

- `-w`, `--print-directory`

  输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。

- `--no-print-directory`

  禁止“-w”选项。

- `-W` *<file>*, `--what-if`=*<file>*, `--new-file`=*<file>*, `--assume-file`=*<file>*

  假定目标<file>;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>;的修改时间为当前时间。

- `--warn-undefined-variables`

  只要make发现有未定义的变量，那么就输出警告信息。

[ Previous](https://seisman.github.io/how-to-write-makefile/functions.html)[Next ](https://seisman.github.io/how-to-write-makefile/implicit_rules.html)

8 